"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Address: () => Address,
  FUEL_BECH32_HRP_PREFIX: () => FUEL_BECH32_HRP_PREFIX,
  addressify: () => addressify,
  clearFirst12BytesFromB256: () => clearFirst12BytesFromB256,
  fromBech32: () => fromBech32,
  getBytesFromBech32: () => getBytesFromBech32,
  getRandomB256: () => getRandomB256,
  isB256: () => isB256,
  isBech32: () => isBech32,
  isEvmAddress: () => isEvmAddress,
  isPublicKey: () => isPublicKey,
  normalizeBech32: () => normalizeBech32,
  padFirst12BytesOfEvmAddress: () => padFirst12BytesOfEvmAddress,
  toB256: () => toB256,
  toBech32: () => toBech32
});
module.exports = __toCommonJS(src_exports);

// src/utils.ts
var import_crypto = require("@fuel-ts/crypto");
var import_errors = require("@fuel-ts/errors");
var import_interfaces = require("@fuel-ts/interfaces");
var import_bech32 = require("bech32");
var import_ethers = require("ethers");
var FUEL_BECH32_HRP_PREFIX = "fuel";
function fromBech32(address) {
  return import_bech32.bech32m.decode(address);
}
function toBech32(address) {
  return import_bech32.bech32m.encode(
    FUEL_BECH32_HRP_PREFIX,
    import_bech32.bech32m.toWords((0, import_ethers.getBytesCopy)((0, import_ethers.hexlify)(address)))
  );
}
function isBech32(address) {
  return typeof address === "string" && address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 && fromBech32(address).prefix === FUEL_BECH32_HRP_PREFIX;
}
function isB256(address) {
  return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
}
function isPublicKey(address) {
  return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
}
function isEvmAddress(address) {
  return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
}
function getBytesFromBech32(address) {
  return new Uint8Array(import_bech32.bech32m.fromWords(fromBech32(address).words));
}
function toB256(address) {
  if (!isBech32(address)) {
    throw new import_errors.FuelError(
      import_errors.FuelError.CODES.INVALID_BECH32_ADDRESS,
      `Invalid Bech32 Address: ${address}.`
    );
  }
  return (0, import_ethers.hexlify)(getBytesFromBech32(address));
}
function normalizeBech32(address) {
  const { words } = fromBech32(address);
  return import_bech32.bech32m.encode(FUEL_BECH32_HRP_PREFIX, words);
}
var addressify = (addressLike) => {
  if (addressLike instanceof import_interfaces.AbstractAccount) {
    return addressLike.address;
  }
  if (addressLike instanceof import_interfaces.AbstractContract) {
    return addressLike.id;
  }
  return addressLike;
};
var getRandomB256 = () => (0, import_ethers.hexlify)((0, import_crypto.randomBytes)(32));
var clearFirst12BytesFromB256 = (b256) => {
  let bytes;
  try {
    if (!isB256(b256)) {
      throw new import_errors.FuelError(
        import_errors.FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${b256}.`
      );
    }
    bytes = getBytesFromBech32(toBech32(b256));
    bytes = (0, import_ethers.hexlify)(bytes.fill(0, 0, 12));
  } catch (error) {
    throw new import_errors.FuelError(
      import_errors.FuelError.CODES.PARSE_FAILED,
      `Cannot generate EVM Address B256 from: ${b256}.`
    );
  }
  return bytes;
};
var padFirst12BytesOfEvmAddress = (address) => {
  if (!isEvmAddress(address)) {
    throw new import_errors.FuelError(import_errors.FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
  }
  return address.replace("0x", "0x000000000000000000000000");
};

// src/address.ts
var import_errors2 = require("@fuel-ts/errors");
var import_interfaces2 = require("@fuel-ts/interfaces");
var import_ethers2 = require("ethers");
var Address = class extends import_interfaces2.AbstractAddress {
  // #region address-2
  bech32Address;
  // #endregion address-2
  /**
   * @param address - A Bech32 address
   */
  constructor(address) {
    super();
    this.bech32Address = normalizeBech32(address);
    if (!isBech32(this.bech32Address)) {
      throw new import_errors2.FuelError(
        import_errors2.FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${address}.`
      );
    }
  }
  /**
   * Returns the `bech32Address` property
   *
   * @returns The `bech32Address` property
   */
  toAddress() {
    return this.bech32Address;
  }
  /**
   * Converts and returns the `bech32Address` property to a 256 bit hash string
   *
   * @returns The `bech32Address` property as a 256 bit hash string
   */
  toB256() {
    return toB256(this.bech32Address);
  }
  /**
   * Converts and returns the `bech32Address` property to a byte array
   *
   * @returns The `bech32Address` property as a byte array
   */
  toBytes() {
    return getBytesFromBech32(this.bech32Address);
  }
  /**
   * Converts
   *
   * @returns The `bech32Address` property as a 256 bit hash string
   */
  toHexString() {
    return this.toB256();
  }
  /**
   * Converts and returns the `bech32Address` property as a string
   *
   * @returns The `bech32Address` property as a string
   */
  toString() {
    return this.bech32Address;
  }
  /**
   * Converts and returns the `bech32Address` property as a string
   *
   * @returns The `bech32Address` property as a string
   */
  toJSON() {
    return this.bech32Address;
  }
  /**
   * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`
   *
   * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}
   */
  toEvmAddress() {
    const b256Address = toB256(this.bech32Address);
    return {
      value: clearFirst12BytesFromB256(b256Address)
    };
  }
  /**
   * Wraps the `bech32Address` property and returns as an `AssetId`.
   *
   * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}
   */
  toAssetId() {
    return {
      value: this.toB256()
    };
  }
  /**
   * Returns the value of the `bech32Address` property
   *
   * @returns The value of `bech32Address` property
   */
  valueOf() {
    return this.bech32Address;
  }
  /**
   * Compares this the `bech32Address` property to another for direct equality
   *
   * @param other - Another address to compare against
   * @returns The equality of the comparison
   */
  equals(other) {
    return this.bech32Address === other.bech32Address;
  }
  /**
   * Takes a Public Key, hashes it, and creates an `Address`
   *
   * @param publicKey - A wallets public key
   * @returns A new `Address` instance
   */
  static fromPublicKey(publicKey) {
    if (!isPublicKey(publicKey)) {
      throw new import_errors2.FuelError(import_errors2.FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);
    }
    const b256Address = (0, import_ethers2.sha256)((0, import_ethers2.hexlify)((0, import_ethers2.getBytesCopy)(publicKey)));
    return new Address(toBech32(b256Address));
  }
  /**
   * Takes a B256 Address and creates an `Address`
   *
   * @param b256Address - A b256 hash
   * @returns A new `Address` instance
   */
  static fromB256(b256Address) {
    if (!isB256(b256Address)) {
      throw new import_errors2.FuelError(
        import_errors2.FuelError.CODES.INVALID_B256_ADDRESS,
        `Invalid B256 Address: ${b256Address}.`
      );
    }
    return new Address(toBech32(b256Address));
  }
  /**
   * Creates an `Address` with a randomized `bech32Address` property
   *
   * @returns A new `Address` instance
   */
  static fromRandom() {
    return this.fromB256(getRandomB256());
  }
  /**
   * Takes an ambiguous string and attempts to create an `Address`
   *
   * @param address - An ambiguous string
   * @returns A new `Address` instance
   */
  static fromString(address) {
    return isBech32(address) ? new Address(address) : this.fromB256(address);
  }
  /**
   * Takes an ambiguous string or address and creates an `Address`
   *
   * @returns a new `Address` instance
   */
  static fromAddressOrString(address) {
    return typeof address === "string" ? this.fromString(address) : address;
  }
  /**
   * Takes a dynamic string or `AbstractAddress` and creates an `Address`
   *
   * @param addressId - A string containing Bech32, B256, or Public Key
   * @throws Error - Unknown address if the format is not recognised
   * @returns A new `Address` instance
   */
  static fromDynamicInput(address) {
    if (typeof address !== "string" && "toB256" in address) {
      return Address.fromB256(address.toB256());
    }
    if (isPublicKey(address)) {
      return Address.fromPublicKey(address);
    }
    if (isBech32(address)) {
      return new Address(address);
    }
    if (isB256(address)) {
      return Address.fromB256(address);
    }
    if (isEvmAddress(address)) {
      return Address.fromEvmAddress(address);
    }
    throw new import_errors2.FuelError(
      import_errors2.FuelError.CODES.PARSE_FAILED,
      `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`
    );
  }
  /**
   * Takes an Evm Address and returns back an `Address`
   *
   * @returns A new `Address` instance
   */
  static fromEvmAddress(evmAddress) {
    if (!isEvmAddress(evmAddress)) {
      throw new import_errors2.FuelError(
        import_errors2.FuelError.CODES.INVALID_EVM_ADDRESS,
        `Invalid Evm Address: ${evmAddress}.`
      );
    }
    const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
    return new Address(toBech32(paddedAddress));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Address,
  FUEL_BECH32_HRP_PREFIX,
  addressify,
  clearFirst12BytesFromB256,
  fromBech32,
  getBytesFromBech32,
  getRandomB256,
  isB256,
  isBech32,
  isEvmAddress,
  isPublicKey,
  normalizeBech32,
  padFirst12BytesOfEvmAddress,
  toB256,
  toBech32
});
//# sourceMappingURL=index.js.map