{"version":3,"sources":["../src/encoding/coders/AbstractCoder.ts","../src/encoding/coders/v0/ArrayCoder.ts","../src/utils/constants.ts","../src/utils/utilities.ts","../src/encoding/coders/v0/BigNumberCoder.ts","../src/encoding/coders/v0/B256Coder.ts","../src/encoding/coders/v0/B512Coder.ts","../src/encoding/coders/v0/BooleanCoder.ts","../src/encoding/coders/v0/ByteCoder.ts","../src/encoding/coders/v0/EnumCoder.ts","../src/encoding/coders/v0/OptionCoder.ts","../src/encoding/coders/v0/NumberCoder.ts","../src/encoding/coders/v0/RawSliceCoder.ts","../src/encoding/coders/v0/StdStringCoder.ts","../src/encoding/coders/v0/StringCoder.ts","../src/encoding/coders/v0/StructCoder.ts","../src/encoding/coders/v0/TupleCoder.ts","../src/encoding/coders/v0/VecCoder.ts","../src/Interface.ts","../src/ResolvedAbiType.ts","../src/encoding/strategies/getCoderForEncoding.ts","../src/encoding/strategies/getCoderV0.ts","../src/encoding/strategies/getCoders.ts","../src/encoding/strategies/getCoderV1.ts","../src/encoding/coders/v1/BooleanCoder.ts","../src/encoding/coders/v1/ByteCoder.ts","../src/encoding/coders/v1/EnumCoder.ts","../src/encoding/coders/v1/NumberCoder.ts","../src/encoding/coders/v1/RawSliceCoder.ts","../src/encoding/coders/v1/StdStringCoder.ts","../src/encoding/coders/v1/StringCoder.ts","../src/encoding/coders/v1/StructCoder.ts","../src/encoding/coders/v1/TupleCoder.ts","../src/encoding/coders/v1/VecCoder.ts","../src/AbiCoder.ts","../src/FunctionFragment.ts"],"sourcesContent":["import type { BN } from '@fuel-ts/math';\nimport type { BytesLike } from 'ethers';\n\nimport type { Option } from './v0/OptionCoder';\n\ntype Primitive = string | number | boolean;\n\n/**\n * The type of value you can provide to `Coder.encode`\n */\nexport type InputValue<T = void> =\n  | Primitive\n  | BN\n  | Option<T>\n  | BytesLike\n  | InputValue[]\n  | { [key: string]: InputValue }\n  | Record<string, Primitive | BytesLike>;\n\n/**\n * The type of value you can get from `Coder.decode`\n */\nexport type DecodedValue =\n  | Primitive\n  | DecodedValue[]\n  | { [key: string]: DecodedValue }\n  | Record<string, Primitive>;\n\nexport type TypesOfCoder<TCoder> = TCoder extends Coder<infer TInput, infer TDecoded>\n  ? { Input: TInput; Decoded: TDecoded }\n  : never;\n\nexport abstract class Coder<TInput = unknown, TDecoded = unknown> {\n  readonly name: string;\n  readonly type: string;\n  readonly encodedLength: number;\n\n  constructor(name: string, type: string, encodedLength: number) {\n    this.name = name;\n    this.type = type;\n    this.encodedLength = encodedLength;\n  }\n\n  abstract encode(value: TInput, length?: number): Uint8Array;\n\n  abstract decode(data: Uint8Array, offset: number, length?: number): [TDecoded, number];\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { MAX_BYTES } from '../../../utils/constants';\nimport { concatWithDynamicData } from '../../../utils/utilities';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class ArrayCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n  length: number;\n\n  constructor(coder: TCoder, length: number) {\n    super('array', `[${coder.type}; ${length}]`, length * coder.encodedLength);\n    this.coder = coder;\n    this.length = length;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    if (this.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if (data.length < this.encodedLength || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid array data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Array(this.length)\n      .fill(0)\n      .map(() => {\n        let decoded;\n        [decoded, newOffset] = this.coder.decode(data, newOffset);\n        return decoded;\n      });\n\n    return [decodedValue as DecodedValueOf<TCoder>, newOffset];\n  }\n}\n","/**\n * Types and Type Regex\n */\nexport const U8_CODER_TYPE = 'u8';\nexport const U16_CODER_TYPE = 'u16';\nexport const U32_CODER_TYPE = 'u32';\nexport const U64_CODER_TYPE = 'u64';\nexport const U256_CODER_TYPE = 'u256';\nexport const RAW_PTR_CODER_TYPE = 'raw untyped ptr';\nexport const RAW_SLICE_CODER_TYPE = 'raw untyped slice';\nexport const BOOL_CODER_TYPE = 'bool';\nexport const B256_CODER_TYPE = 'b256';\nexport const B512_CODER_TYPE = 'struct B512';\nexport const OPTION_CODER_TYPE = 'enum Option';\nexport const VEC_CODER_TYPE = 'struct Vec';\nexport const BYTES_CODER_TYPE = 'struct Bytes';\nexport const STD_STRING_CODER_TYPE = 'struct String';\nexport const STR_SLICE_CODER_TYPE = 'str';\nexport const stringRegEx = /str\\[(?<length>[0-9]+)\\]/;\nexport const arrayRegEx = /\\[(?<item>[\\w\\s\\\\[\\]]+);\\s*(?<length>[0-9]+)\\]/;\nexport const structRegEx = /^struct (?<name>\\w+)$/;\nexport const enumRegEx = /^enum (?<name>\\w+)$/;\nexport const tupleRegEx = /^\\((?<items>.*)\\)$/;\nexport const genericRegEx = /^generic (?<name>\\w+)$/;\n/**\n * Encoding versions\n */\nexport const ENCODING_V0 = '0';\nexport const ENCODING_V1 = '1';\n/**\n * Property space and config constants\n */\nexport const WORD_SIZE = 8;\nexport const BYTES_32 = 32;\nexport const MAX_INPUTS = 255;\nexport const ASSET_ID_LEN = BYTES_32;\nexport const CONTRACT_ID_LEN = BYTES_32;\nexport const ADDRESS_LEN = BYTES_32;\nexport const NONCE_LEN = BYTES_32;\nexport const TX_LEN = WORD_SIZE * 4;\nexport const TX_POINTER_LEN = WORD_SIZE * 2;\nexport const MAX_BYTES = 2 ** 32 - 1; // Max u32\n\nexport const calculateVmTxMemory = ({ maxInputs }: { maxInputs: number }) =>\n  BYTES_32 + // Tx ID\n  WORD_SIZE + // Tx size\n  // Asset ID/Balance coin input pairs\n  maxInputs * (ASSET_ID_LEN + WORD_SIZE);\n\n// SCRIPT_FIXED_SIZE = 104\nexport const SCRIPT_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  WORD_SIZE + // Gas limit\n  WORD_SIZE + // Script size\n  WORD_SIZE + // Script data size\n  WORD_SIZE + // Policies\n  WORD_SIZE + // Inputs size\n  WORD_SIZE + // Outputs size\n  WORD_SIZE + // Witnesses size\n  BYTES_32; // Receipts root\n\n// INPUT_COIN_FIXED_SIZE = 176\nexport const INPUT_COIN_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  TX_LEN + // Utxo Length\n  WORD_SIZE + // Output Index\n  ADDRESS_LEN + // Owner\n  WORD_SIZE + // Amount\n  ASSET_ID_LEN + // Asset id\n  TX_POINTER_LEN + // TxPointer\n  WORD_SIZE + // Witnesses index\n  WORD_SIZE + // Maturity\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n\n// INPUT_MESSAGE_FIXED_SIZE = 168\nexport const INPUT_MESSAGE_FIXED_SIZE =\n  WORD_SIZE + // Identifier\n  ADDRESS_LEN + // Sender\n  ADDRESS_LEN + // Recipient\n  WORD_SIZE + // Amount\n  NONCE_LEN + // Nonce\n  WORD_SIZE + // witness_index\n  WORD_SIZE + // Data size\n  WORD_SIZE + // Predicate size\n  WORD_SIZE + // Predicate data size\n  WORD_SIZE; // Predicate gas used\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { concat, concatBytes, arrayify } from '@fuel-ts/utils';\n\nimport { BigNumberCoder } from '../encoding/coders/v0/BigNumberCoder';\n\nimport { BYTES_CODER_TYPE, VEC_CODER_TYPE, STD_STRING_CODER_TYPE, WORD_SIZE } from './constants';\n\nexport type DynamicData = {\n  [pointerIndex: number]: Uint8ArrayWithDynamicData;\n};\n\nexport type Uint8ArrayWithDynamicData = Uint8Array & {\n  dynamicData?: DynamicData;\n};\n\nconst VEC_PROPERTY_SPACE = 3; // ptr + cap + length\nexport const BASE_VECTOR_OFFSET = VEC_PROPERTY_SPACE * WORD_SIZE;\n\nconst RAW_SLICE_PROPERTY_SPACE = 2; // ptr + length\nexport const BASE_RAW_SLICE_OFFSET = RAW_SLICE_PROPERTY_SPACE * WORD_SIZE;\n\n// this is a fork of @ethersproject/bytes:concat\n// this collects individual dynamicData data and relocates it to top level\nexport function concatWithDynamicData(items: ReadonlyArray<BytesLike>): Uint8ArrayWithDynamicData {\n  const topLevelData: DynamicData = {};\n\n  let totalIndex = 0;\n  const objects = items.map((item) => {\n    const dynamicData = (item as Uint8ArrayWithDynamicData).dynamicData;\n    if (dynamicData) {\n      Object.entries(dynamicData).forEach(([pointerIndex, vData]) => {\n        topLevelData[parseInt(pointerIndex, 10) + totalIndex] = vData;\n      });\n    }\n\n    const byteArray = arrayify(item);\n    totalIndex += byteArray.byteLength / WORD_SIZE;\n\n    return byteArray;\n  });\n\n  const length = objects.reduce((accum, item) => accum + item.length, 0);\n  const result: Uint8ArrayWithDynamicData = new Uint8Array(length);\n\n  objects.reduce((offset, object) => {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n\n  // store vector data and pointer indices, but only if data exist\n  if (Object.keys(topLevelData).length) {\n    result.dynamicData = topLevelData;\n  }\n\n  return result;\n}\n\nexport function unpackDynamicData(\n  results: Uint8ArrayWithDynamicData,\n  baseOffset: number,\n  dataOffset: number\n): Uint8Array {\n  if (!results.dynamicData) {\n    return concat([results]);\n  }\n\n  let cumulativeDynamicByteLength = 0;\n  let updatedResults = results;\n  Object.entries(results.dynamicData).forEach(([pointerIndex, vData]) => {\n    // update value of pointer\n    const pointerOffset = parseInt(pointerIndex, 10) * WORD_SIZE;\n    const adjustedValue = new BigNumberCoder('u64').encode(\n      dataOffset + baseOffset + cumulativeDynamicByteLength\n    );\n    updatedResults.set(adjustedValue, pointerOffset);\n\n    // append dynamic data at the end\n    const dataToAppend = vData.dynamicData\n      ? // unpack child dynamic data\n        unpackDynamicData(\n          vData,\n          baseOffset,\n          dataOffset + vData.byteLength + cumulativeDynamicByteLength\n        )\n      : vData;\n    updatedResults = concat([updatedResults, dataToAppend]);\n\n    cumulativeDynamicByteLength += dataToAppend.byteLength;\n  });\n\n  return updatedResults;\n}\n\n/**\n * Turns:\n  Uint8Array(24) [\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 24\n  ]\n\n  Into:\n  Array [\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 1\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 2\n    ],\n    Uint8Array(8) [\n      0, 0, 0, 0, 0, 0, 0, 24\n    ]\n  ]\n *\n */\nexport const chunkByLength = (data: Uint8Array, length = WORD_SIZE): Uint8Array[] => {\n  const chunks = [];\n  let offset = 0;\n  let chunk = data.slice(offset, offset + length);\n  while (chunk.length) {\n    chunks.push(chunk);\n    offset += length;\n    chunk = data.slice(offset, offset + length);\n  }\n\n  return chunks;\n};\n\n/**\n * Checks if a given type is a pointer type\n * See: https://github.com/FuelLabs/sway/issues/1368\n */\nexport const isPointerType = (type: string) => {\n  switch (type) {\n    case 'u8':\n    case 'u16':\n    case 'u32':\n    case 'u64':\n    case 'bool': {\n      return false;\n    }\n    default: {\n      return true;\n    }\n  }\n};\n\nexport const isHeapType = (type: string) =>\n  type === VEC_CODER_TYPE || type === BYTES_CODER_TYPE || type === STD_STRING_CODER_TYPE;\n\nexport function findOrThrow<T>(\n  arr: readonly T[],\n  predicate: (val: T) => boolean,\n  throwFn: () => never = () => {\n    throw new FuelError(ErrorCode.ELEMENT_NOT_FOUND, 'Element not found in the array.');\n  }\n): T {\n  const found = arr.find(predicate);\n  if (found === undefined) {\n    throwFn();\n  }\n\n  return found;\n}\n\n/**\n * Because some properties can be single-bytes, we need to pad them\n * with zeros until they are aligned to a word-sized increment.\n * This is the case for `tuple` and `struct` properties.\n * Please refer to packages/abi-coder/src/coders/abstract-coder.ts for more details\n */\nexport const isMultipleOfWordSize = (length: number) => length % WORD_SIZE === 0;\n\nexport const getWordSizePadding = (length: number) => WORD_SIZE - (length % WORD_SIZE);\n\nexport const rightPadToWordSize = (encoded: Uint8Array) => {\n  if (isMultipleOfWordSize(encoded.length)) {\n    return encoded;\n  }\n  const padding = new Uint8Array(WORD_SIZE - (encoded.length % WORD_SIZE));\n  return concatBytes([encoded, padding]);\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { type BNInput, type BN, toBytes, bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport { Coder } from '../AbstractCoder';\n\ntype BigNumberCoderType = 'u64' | 'u256';\n\nconst encodedLengths: { [key in BigNumberCoderType]: number } = {\n  u64: WORD_SIZE,\n  u256: WORD_SIZE * 4,\n};\n\nexport class BigNumberCoder extends Coder<BNInput, BN> {\n  constructor(baseType: BigNumberCoderType) {\n    super('bigNumber', baseType, encodedLengths[baseType]);\n  }\n\n  encode(value: BNInput): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value, this.encodedLength);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n\n    return bytes;\n  }\n\n  decode(data: Uint8Array, offset: number): [BN, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n    bytes = bytes.slice(0, this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid ${this.type} byte data size.`);\n    }\n\n    return [bn(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport { Coder } from '../AbstractCoder';\n\nexport class B256Coder extends Coder<string, string> {\n  constructor() {\n    super('b256', 'b256', WORD_SIZE * 4);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(32);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b256 byte data size.`);\n    }\n\n    return [toHex(bytes, 32), offset + 32];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toHex } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport { Coder } from '../AbstractCoder';\n\nexport class B512Coder extends Coder<string, string> {\n  constructor() {\n    super('b512', 'struct B512', WORD_SIZE * 8);\n  }\n\n  encode(value: string): Uint8Array {\n    let encodedValue;\n    try {\n      encodedValue = arrayify(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    if (encodedValue.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);\n    }\n    return encodedValue;\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 data size.`);\n    }\n\n    let bytes = data.slice(offset, offset + this.encodedLength);\n\n    const decoded = bn(bytes);\n    if (decoded.isZero()) {\n      bytes = new Uint8Array(64);\n    }\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid b512 byte data size.`);\n    }\n\n    return [toHex(bytes, this.encodedLength), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../../../types/EncodingOptions';\nimport { Coder } from '../AbstractCoder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  paddingLength: number;\n  options: EncodingOptions;\n\n  constructor(\n    options: EncodingOptions = {\n      isSmallBytes: false,\n      isRightPadded: false,\n    }\n  ) {\n    const paddingLength = options.isSmallBytes ? 1 : 8;\n\n    super('boolean', 'boolean', paddingLength);\n\n    this.paddingLength = paddingLength;\n    this.options = options;\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n\n    if (!isTrueBool) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    const output: Uint8Array = toBytes(value ? 1 : 0, this.paddingLength);\n\n    if (this.options.isRightPadded) {\n      return output.reverse();\n    }\n\n    return output;\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    if (data.length < this.paddingLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n\n    let bytes;\n\n    if (this.options.isRightPadded) {\n      bytes = data.slice(offset, offset + 1);\n    } else {\n      bytes = data.slice(offset, offset + this.paddingLength);\n    }\n\n    const decodedValue = bn(bytes);\n    if (decodedValue.isZero()) {\n      return [false, offset + this.paddingLength];\n    }\n\n    if (!decodedValue.eq(bn(1))) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return [true, offset + this.paddingLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport type { Uint8ArrayWithDynamicData } from '../../../utils/utilities';\nimport { BASE_VECTOR_OFFSET, concatWithDynamicData } from '../../../utils/utilities';\nimport { Coder } from '../AbstractCoder';\n\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', BASE_VECTOR_OFFSET);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new BigNumberCoder('u64').encode(BASE_VECTOR_OFFSET);\n\n    // pointer dynamicData, encode the byte vector now and attach to its pointer\n    const data = this.#getPaddedData(value);\n    pointer.dynamicData = {\n      0: concatWithDynamicData([data]),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new BigNumberCoder('u64').encode(data.byteLength));\n\n    // length (len)\n    parts.push(new BigNumberCoder('u64').encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  #getPaddedData(value: number[]): Uint8Array {\n    const data: Uint8Array[] = [Uint8Array.from(value)];\n\n    const paddingLength = (WORD_SIZE - (value.length % WORD_SIZE)) % WORD_SIZE;\n    if (paddingLength) {\n      data.push(new Uint8Array(paddingLength));\n    }\n\n    return concat(data);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    if (data.length < BASE_VECTOR_OFFSET) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n\n    const len = data.slice(16, 24);\n    const encodedLength = bn(new BigNumberCoder('u64').decode(len, 0)[0]).toNumber();\n    const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + encodedLength);\n\n    if (byteData.length !== encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n\n    return [byteData, offset + BASE_VECTOR_OFFSET];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { concatWithDynamicData } from '../../../utils/utilities';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\n\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nconst isFullyNativeEnum = (enumCoders: { [s: string]: unknown } | ArrayLike<unknown>): boolean =>\n  Object.values(enumCoders).every(\n    // @ts-expect-error complicated types\n    ({ type, coders }) => type === '()' && JSON.stringify(coders) === JSON.stringify([])\n  );\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: BigNumberCoder;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new BigNumberCoder('u64');\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  #encodeNativeEnum(value: string): Uint8Array {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (typeof value === 'string' && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'A field for the case must be provided.');\n    }\n    if (empty.length !== 0) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'Only one field must be provided.');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concatWithDynamicData([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.#encodedValueSize) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    let newOffset = offset;\n\n    let decoded;\n    [decoded, newOffset] = new BigNumberCoder('u64').decode(data, newOffset);\n    const caseIndex = toNumber(decoded);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n\n    const valueCoder = this.coders[caseKey];\n    const padding = this.#encodedValueSize - valueCoder.encodedLength;\n    newOffset += padding;\n    [decoded, newOffset] = valueCoder.decode(data, newOffset);\n\n    if (isFullyNativeEnum(this.coders)) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { Coder } from '../AbstractCoder';\n\nimport type { InputValueOf, DecodedValueOf } from './EnumCoder';\nimport { EnumCoder } from './EnumCoder';\n\ntype SwayOption<T> = { None: [] } | { Some: T };\nexport type Option<T> = T | undefined;\n\nexport class OptionCoder<TCoders extends Record<string, Coder>> extends EnumCoder<TCoders> {\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    const result = super.encode(this.toSwayOption(value) as unknown as InputValueOf<TCoders>);\n    return result;\n  }\n\n  toSwayOption(input: InputValueOf<TCoders>): SwayOption<unknown> {\n    if (input !== undefined) {\n      return { Some: input };\n    }\n\n    return { None: [] };\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    // An empty option will be one less than the expected encoded length\n    if (data.length < this.encodedLength - 1) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid option data size.`);\n    }\n\n    const [decoded, newOffset] = super.decode(data, offset);\n    return [this.toOption(decoded) as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  toOption(output?: DecodedValueOf<TCoders>): Option<unknown> {\n    if (output && 'Some' in output) {\n      return output.Some;\n    }\n\n    return undefined;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport type { EncodingOptions } from '../../../types/EncodingOptions';\nimport { Coder } from '../AbstractCoder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32';\n\nexport class NumberCoder extends Coder<number, number> {\n  // This is to align the bits to the total bytes\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers\n  length: number;\n  paddingLength: number;\n  baseType: NumberCoderType;\n  options: EncodingOptions;\n\n  constructor(\n    baseType: NumberCoderType,\n    options: EncodingOptions = {\n      isSmallBytes: false,\n      isRightPadded: false,\n    }\n  ) {\n    const paddingLength = options.isSmallBytes && baseType === 'u8' ? 1 : 8;\n\n    super('number', baseType, paddingLength);\n    this.baseType = baseType;\n    switch (baseType) {\n      case 'u8':\n        this.length = 1;\n        break;\n      case 'u16':\n        this.length = 2;\n        break;\n      case 'u32':\n      default:\n        this.length = 4;\n        break;\n    }\n\n    this.paddingLength = paddingLength;\n    this.options = options;\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    const output = toBytes(bytes, this.paddingLength);\n\n    if (this.baseType !== 'u8') {\n      return output;\n    }\n\n    return this.options.isRightPadded ? output.reverse() : output;\n  }\n\n  private decodeU8(data: Uint8Array, offset: number): [number, number] {\n    let bytes;\n    if (this.options.isRightPadded) {\n      bytes = data.slice(offset, offset + 1);\n    } else {\n      bytes = data.slice(offset, offset + this.paddingLength);\n      bytes = bytes.slice(this.paddingLength - this.length, this.paddingLength);\n    }\n\n    return [toNumber(bytes), offset + this.paddingLength];\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    if (data.length < this.paddingLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n\n    if (this.baseType === 'u8') {\n      return this.decodeU8(data, offset);\n    }\n\n    let bytes = data.slice(offset, offset + this.paddingLength);\n    bytes = bytes.slice(8 - this.length, 8);\n\n    if (bytes.length !== this.paddingLength - (this.paddingLength - this.length)) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n\n    return [toNumber(bytes), offset + 8];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { Uint8ArrayWithDynamicData } from '../../../utils/utilities';\nimport { BASE_RAW_SLICE_OFFSET, concatWithDynamicData } from '../../../utils/utilities';\nimport { Coder } from '../AbstractCoder';\n\nimport { ArrayCoder } from './ArrayCoder';\nimport { BigNumberCoder } from './BigNumberCoder';\nimport { NumberCoder } from './NumberCoder';\n\nexport class RawSliceCoder extends Coder<number[], number[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', BASE_RAW_SLICE_OFFSET);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n    const coder = new NumberCoder('u8', { isSmallBytes: true });\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new BigNumberCoder('u64').encode(\n      BASE_RAW_SLICE_OFFSET\n    );\n\n    // pointer dynamicData, encode the vector now and attach to its pointer\n    pointer.dynamicData = {\n      0: concatWithDynamicData(value.map((v) => coder.encode(v))),\n    };\n\n    parts.push(pointer);\n\n    // length (len)\n    parts.push(new BigNumberCoder('u64').encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [number[], number] {\n    const dataBytes = data.slice(offset);\n    const internalCoder = new ArrayCoder(\n      new NumberCoder('u8', { isSmallBytes: true }),\n      dataBytes.length\n    );\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n\n    return [decodedValue, offset + dataBytes.length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport type { Uint8ArrayWithDynamicData } from '../../../utils/utilities';\nimport { BASE_VECTOR_OFFSET, concatWithDynamicData } from '../../../utils/utilities';\nimport { Coder } from '../AbstractCoder';\n\nimport { BigNumberCoder } from './BigNumberCoder';\n\nexport class StdStringCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct String', 1);\n  }\n\n  encode(value: string): Uint8Array {\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new BigNumberCoder('u64').encode(BASE_VECTOR_OFFSET);\n\n    // pointer dynamicData, encode the string vector now and attach to its pointer\n    const data = this.#getPaddedData(value);\n    pointer.dynamicData = {\n      0: concatWithDynamicData([data]),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new BigNumberCoder('u64').encode(data.byteLength));\n\n    // length (len)\n    parts.push(new BigNumberCoder('u64').encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  #getPaddedData(value: string): Uint8Array {\n    const data: Uint8Array[] = [toUtf8Bytes(value)];\n\n    const paddingLength = (WORD_SIZE - (value.length % WORD_SIZE)) % WORD_SIZE;\n    if (paddingLength) {\n      data.push(new Uint8Array(paddingLength));\n    }\n\n    return concat(data);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n\n    const len = data.slice(16, 24);\n    const encodedLength = bn(new BigNumberCoder('u64').decode(len, 0)[0]).toNumber();\n    const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + encodedLength);\n\n    if (byteData.length !== encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n\n    const value = toUtf8String(byteData);\n    return [value, offset + BASE_VECTOR_OFFSET];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concat } from '@fuel-ts/utils';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { Coder } from '../AbstractCoder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  length: TLength;\n  #paddingLength: number;\n\n  constructor(length: TLength) {\n    let paddingLength = (8 - length) % 8;\n    paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;\n    super('string', `str[${length}]`, length + paddingLength);\n    this.length = length;\n    this.#paddingLength = paddingLength;\n  }\n\n  encode(value: string): Uint8Array {\n    if (this.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    const encoded = toUtf8Bytes(value);\n    const padding = new Uint8Array(this.#paddingLength);\n    return concat([encoded, padding]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.length);\n\n    if (bytes.length !== this.length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n\n    const value = toUtf8String(bytes);\n\n    const padding = this.#paddingLength;\n    return [value, offset + this.length + padding];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport {\n  concatWithDynamicData,\n  getWordSizePadding,\n  isMultipleOfWordSize,\n  rightPadToWordSize,\n} from '../../../utils/utilities';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\n\nimport { OptionCoder } from './OptionCoder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>) {\n    const encodedFields = Object.keys(this.coders).map((fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      const fieldValue = value[fieldName];\n\n      if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n        throw new FuelError(\n          ErrorCode.ENCODE_ERROR,\n          `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n        );\n      }\n\n      const encoded = fieldCoder.encode(fieldValue);\n\n      if (!isMultipleOfWordSize(encoded.length)) {\n        return rightPadToWordSize(encoded);\n      }\n\n      return encoded;\n    });\n\n    return concatWithDynamicData([concatWithDynamicData(encodedFields)]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n\n      if (!isMultipleOfWordSize(newOffset)) {\n        newOffset += getWordSizePadding(newOffset);\n      }\n\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport {\n  concatWithDynamicData,\n  getWordSizePadding,\n  isMultipleOfWordSize,\n  rightPadToWordSize,\n} from '../../../utils/utilities';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatWithDynamicData(\n      this.coders.map((coder, i) => {\n        const encoded = coder.encode(value[i]);\n        if (!isMultipleOfWordSize(encoded.length)) {\n          return rightPadToWordSize(encoded);\n        }\n        return encoded;\n      })\n    );\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n\n      if (!isMultipleOfWordSize(newOffset)) {\n        newOffset += getWordSizePadding(newOffset);\n      }\n\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { MAX_BYTES } from '../../../utils/constants';\nimport type { Uint8ArrayWithDynamicData } from '../../../utils/utilities';\nimport { concatWithDynamicData, BASE_VECTOR_OFFSET, chunkByLength } from '../../../utils/utilities';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\n\nimport { BigNumberCoder } from './BigNumberCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, coder.encodedLength + BASE_VECTOR_OFFSET);\n    this.coder = coder;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const parts: Uint8Array[] = [];\n\n    // pointer (ptr)\n    const pointer: Uint8ArrayWithDynamicData = new BigNumberCoder('u64').encode(BASE_VECTOR_OFFSET);\n    // pointer dynamicData, encode the vector now and attach to its pointer\n    pointer.dynamicData = {\n      0: concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v))),\n    };\n\n    parts.push(pointer);\n\n    // capacity (cap)\n    parts.push(new BigNumberCoder('u64').encode(value.length));\n\n    // length (len)\n    parts.push(new BigNumberCoder('u64').encode(value.length));\n\n    return concatWithDynamicData(parts);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if (data.length < BASE_VECTOR_OFFSET || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n\n    const len = data.slice(16, 24);\n    const encodedLength = bn(new BigNumberCoder('u64').decode(len, 0)[0]).toNumber();\n    const vectorRawDataLength = encodedLength * this.coder.encodedLength;\n    const vectorRawData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + vectorRawDataLength);\n\n    if (vectorRawData.length !== vectorRawDataLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n\n    return [\n      chunkByLength(vectorRawData, this.coder.encodedLength).map(\n        (chunk) => this.coder.decode(chunk, 0)[0]\n      ),\n      offset + BASE_VECTOR_OFFSET,\n    ];\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { arrayify } from '@fuel-ts/utils';\n\nimport { AbiCoder } from './AbiCoder';\nimport { FunctionFragment } from './FunctionFragment';\nimport type { InputValue } from './encoding/coders/AbstractCoder';\nimport type { JsonAbi, JsonAbiConfigurable } from './types/JsonAbi';\nimport { findOrThrow } from './utils/utilities';\n\nexport class Interface<TAbi extends JsonAbi = JsonAbi> {\n  readonly functions!: Record<string, FunctionFragment>;\n\n  readonly configurables: Record<string, JsonAbiConfigurable>;\n  /*\n  TODO: Refactor so that there's no need for externalLoggedTypes\n\n  This is dedicated to external contracts added via `<base-invocation-scope.ts>.addContracts()` method.\n  This is used to decode logs from contracts other than the main contract\n  we're interacting with.\n  */\n  private externalLoggedTypes: Record<string, Interface>;\n  readonly jsonAbi: TAbi;\n\n  constructor(jsonAbi: TAbi) {\n    this.jsonAbi = jsonAbi;\n\n    this.externalLoggedTypes = {};\n\n    this.functions = Object.fromEntries(\n      this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)])\n    );\n\n    this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));\n  }\n\n  /**\n   * Returns function fragment for a dynamic input.\n   * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment\n   */\n  getFunction(nameOrSignatureOrSelector: string): FunctionFragment {\n    const fn = Object.values<FunctionFragment>(this.functions).find(\n      (f) =>\n        f.name === nameOrSignatureOrSelector ||\n        f.signature === nameOrSignatureOrSelector ||\n        f.selector === nameOrSignatureOrSelector\n    );\n\n    if (fn !== undefined) {\n      return fn;\n    }\n\n    throw new FuelError(\n      ErrorCode.FUNCTION_NOT_FOUND,\n      `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`\n    );\n  }\n\n  decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, 'Fragment not found.');\n    }\n\n    return fragment.decodeArguments(data);\n  }\n\n  encodeFunctionData(\n    functionFragment: FunctionFragment | string,\n    values: Array<InputValue>,\n    offset = 0\n  ): Uint8Array {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    if (!fragment) {\n      throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, 'Fragment not found.');\n    }\n\n    return fragment.encodeArguments(values, offset);\n  }\n\n  // Decode the result of a function call\n  decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): any {\n    const fragment =\n      typeof functionFragment === 'string' ? this.getFunction(functionFragment) : functionFragment;\n\n    return fragment.decodeOutput(data);\n  }\n\n  decodeLog(data: BytesLike, logId: number, receiptId: string): any {\n    const isExternalLoggedType = this.externalLoggedTypes[receiptId];\n    if (isExternalLoggedType) {\n      const externalInterface = this.externalLoggedTypes[receiptId];\n      return externalInterface.decodeLog(data, logId, receiptId);\n    }\n\n    const { loggedType } = findOrThrow(this.jsonAbi.loggedTypes, (type) => type.logId === logId);\n\n    return AbiCoder.decode(this.jsonAbi, loggedType, arrayify(data), 0, {\n      encoding: this.jsonAbi.encoding,\n    });\n  }\n\n  updateExternalLoggedTypes(id: string, loggedTypes: Interface) {\n    this.externalLoggedTypes[id] = loggedTypes;\n  }\n\n  encodeConfigurable(name: string, value: InputValue) {\n    const configurable = findOrThrow(\n      this.jsonAbi.configurables,\n      (c) => c.name === name,\n      () => {\n        throw new FuelError(\n          ErrorCode.CONFIGURABLE_NOT_FOUND,\n          `A configurable with the '${name}' was not found in the ABI.`\n        );\n      }\n    );\n\n    return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value, {\n      isRightPadded: true,\n    });\n  }\n\n  getTypeById(typeId: number) {\n    return findOrThrow(\n      this.jsonAbi.types,\n      (t) => t.typeId === typeId,\n      () => {\n        throw new FuelError(\n          ErrorCode.TYPE_NOT_FOUND,\n          `Type with typeId '${typeId}' doesn't exist in the ABI.`\n        );\n      }\n    );\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { JsonAbi, JsonAbiArgument } from './types/JsonAbi';\nimport { arrayRegEx, enumRegEx, genericRegEx, stringRegEx, structRegEx } from './utils/constants';\nimport { findOrThrow } from './utils/utilities';\n\nexport class ResolvedAbiType {\n  readonly abi: JsonAbi;\n  name: string;\n  readonly type: string;\n  readonly originalTypeArguments: readonly JsonAbiArgument[] | null;\n  readonly components: readonly ResolvedAbiType[] | null;\n\n  constructor(abi: JsonAbi, argument: JsonAbiArgument) {\n    this.abi = abi;\n    const type = findOrThrow(\n      abi.types,\n      (t) => t.typeId === argument.type,\n      () => {\n        throw new FuelError(\n          ErrorCode.TYPE_NOT_FOUND,\n          `Type does not exist in the provided abi: ${JSON.stringify({\n            argument,\n            abi: this.abi,\n          })}`\n        );\n      }\n    );\n\n    this.name = argument.name;\n\n    this.type = type.type;\n    this.originalTypeArguments = argument.typeArguments;\n    this.components = ResolvedAbiType.getResolvedGenericComponents(\n      abi,\n      argument,\n      type.components,\n      type.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, type.components)\n    );\n  }\n\n  private static getResolvedGenericComponents(\n    abi: JsonAbi,\n    arg: JsonAbiArgument,\n    components: readonly JsonAbiArgument[] | null,\n    typeParameters: readonly number[] | null\n  ) {\n    if (components === null) {\n      return null;\n    }\n    if (typeParameters === null || typeParameters.length === 0) {\n      return components.map((c) => new ResolvedAbiType(abi, c));\n    }\n\n    const typeParametersAndArgsMap = typeParameters.reduce(\n      (obj, typeParameter, typeParameterIndex) => {\n        const o: Record<number, JsonAbiArgument> = { ...obj };\n        o[typeParameter] = structuredClone(\n          arg.typeArguments?.[typeParameterIndex]\n        ) as JsonAbiArgument;\n        return o;\n      },\n      {} as Record<number, JsonAbiArgument>\n    );\n\n    const resolvedComponents = this.resolveGenericArgTypes(\n      abi,\n      components,\n      typeParametersAndArgsMap\n    );\n\n    return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));\n  }\n\n  private static resolveGenericArgTypes(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[],\n    typeParametersAndArgsMap: Record<number, JsonAbiArgument>\n  ): readonly JsonAbiArgument[] {\n    return args.map((arg) => {\n      if (typeParametersAndArgsMap[arg.type] !== undefined) {\n        return {\n          ...typeParametersAndArgsMap[arg.type],\n          name: arg.name,\n        };\n      }\n\n      if (arg.typeArguments) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: this.resolveGenericArgTypes(\n            abi,\n            arg.typeArguments,\n            typeParametersAndArgsMap\n          ),\n        };\n      }\n\n      const argType = findOrThrow(abi.types, (t) => t.typeId === arg.type);\n      const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);\n\n      if (implicitTypeParameters && implicitTypeParameters.length > 0) {\n        return {\n          ...structuredClone(arg),\n          typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp]),\n        };\n      }\n\n      return arg;\n    });\n  }\n\n  private static getImplicitGenericTypeParameters(\n    abi: JsonAbi,\n    args: readonly JsonAbiArgument[] | null,\n    implicitGenericParametersParam?: number[]\n  ) {\n    if (!Array.isArray(args)) {\n      return null;\n    }\n\n    const implicitGenericParameters: number[] = implicitGenericParametersParam ?? [];\n\n    args.forEach((a) => {\n      const argType = findOrThrow(abi.types, (t) => t.typeId === a.type);\n\n      if (genericRegEx.test(argType.type)) {\n        implicitGenericParameters.push(argType.typeId);\n        return;\n      }\n\n      if (!Array.isArray(a.typeArguments)) {\n        return;\n      }\n      this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);\n    });\n\n    return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;\n  }\n\n  getSignature(): string {\n    const prefix = this.getArgSignaturePrefix();\n    const content = this.getArgSignatureContent();\n\n    return `${prefix}${content}`;\n  }\n\n  private getArgSignaturePrefix(): string {\n    const structMatch = structRegEx.test(this.type);\n    if (structMatch) {\n      return 's';\n    }\n\n    const arrayMatch = arrayRegEx.test(this.type);\n    if (arrayMatch) {\n      return 'a';\n    }\n\n    const enumMatch = enumRegEx.test(this.type);\n    if (enumMatch) {\n      return 'e';\n    }\n\n    return '';\n  }\n\n  private getArgSignatureContent(): string {\n    if (this.type === 'raw untyped ptr') {\n      return 'rawptr';\n    }\n\n    if (this.type === 'raw untyped slice') {\n      return 'rawslice';\n    }\n\n    const strMatch = stringRegEx.exec(this.type)?.groups;\n    if (strMatch) {\n      return `str[${strMatch.length}]`;\n    }\n\n    if (this.components === null) {\n      return this.type;\n    }\n\n    const arrayMatch = arrayRegEx.exec(this.type)?.groups;\n\n    if (arrayMatch) {\n      return `[${this.components[0].getSignature()};${arrayMatch.length}]`;\n    }\n\n    const typeArgumentsSignature =\n      this.originalTypeArguments !== null\n        ? `<${this.originalTypeArguments\n            .map((a) => new ResolvedAbiType(this.abi, a).getSignature())\n            .join(',')}>`\n        : '';\n\n    const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(',')})`;\n\n    return `${typeArgumentsSignature}${componentsSignature}`;\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport { ENCODING_V0, ENCODING_V1 } from '../../utils/constants';\n\nimport { getCoder as getCoderV0 } from './getCoderV0';\nimport { getCoder as getCoderV1 } from './getCoderV1';\n\n/**\n * Retrieves the appropriate encoding function for a given encoding version.\n *\n * @param encoding - the version to provide a strategy for.\n * @throws for an unsupported encoding version.\n * @returns the appropriate encoding strategy.\n */\nexport function getCoderForEncoding(encoding: string = ENCODING_V0): GetCoderFn {\n  switch (encoding) {\n    case ENCODING_V1:\n      return getCoderV1;\n    case ENCODING_V0:\n      return getCoderV0;\n    default:\n      throw new FuelError(\n        ErrorCode.UNSUPPORTED_ENCODING_VERSION,\n        `Encoding version ${encoding} is unsupported.`\n      );\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport {\n  B256_CODER_TYPE,\n  B512_CODER_TYPE,\n  BOOL_CODER_TYPE,\n  BYTES_CODER_TYPE,\n  ENCODING_V0,\n  OPTION_CODER_TYPE,\n  RAW_PTR_CODER_TYPE,\n  RAW_SLICE_CODER_TYPE,\n  STD_STRING_CODER_TYPE,\n  STR_SLICE_CODER_TYPE,\n  U16_CODER_TYPE,\n  U256_CODER_TYPE,\n  U32_CODER_TYPE,\n  U64_CODER_TYPE,\n  U8_CODER_TYPE,\n  VEC_CODER_TYPE,\n  arrayRegEx,\n  enumRegEx,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n} from '../../utils/constants';\nimport { findOrThrow } from '../../utils/utilities';\nimport type { Coder } from '../coders/AbstractCoder';\nimport { ArrayCoder } from '../coders/v0/ArrayCoder';\nimport { B256Coder } from '../coders/v0/B256Coder';\nimport { B512Coder } from '../coders/v0/B512Coder';\nimport { BigNumberCoder } from '../coders/v0/BigNumberCoder';\nimport { BooleanCoder } from '../coders/v0/BooleanCoder';\nimport { ByteCoder } from '../coders/v0/ByteCoder';\nimport { EnumCoder } from '../coders/v0/EnumCoder';\nimport { NumberCoder } from '../coders/v0/NumberCoder';\nimport { OptionCoder } from '../coders/v0/OptionCoder';\nimport { RawSliceCoder } from '../coders/v0/RawSliceCoder';\nimport { StdStringCoder } from '../coders/v0/StdStringCoder';\nimport { StringCoder } from '../coders/v0/StringCoder';\nimport { StructCoder } from '../coders/v0/StructCoder';\nimport { TupleCoder } from '../coders/v0/TupleCoder';\nimport { VecCoder } from '../coders/v0/VecCoder';\n\nimport { getCoders } from './getCoders';\n\n/**\n * Retrieves coders that adhere to the v0 spec.\n *\n * @param resolvedAbiType - the resolved type to return a coder for.\n * @param options - options to be utilized during the encoding process.\n * @returns the coder for a given type.\n */\nexport const getCoder: GetCoderFn = (\n  resolvedAbiType: ResolvedAbiType,\n  options?: EncodingOptions\n): Coder => {\n  switch (resolvedAbiType.type) {\n    case U8_CODER_TYPE:\n    case U16_CODER_TYPE:\n    case U32_CODER_TYPE:\n      return new NumberCoder(resolvedAbiType.type, options);\n    case U64_CODER_TYPE:\n    case RAW_PTR_CODER_TYPE:\n      return new BigNumberCoder('u64');\n    case U256_CODER_TYPE:\n      return new BigNumberCoder('u256');\n    case RAW_SLICE_CODER_TYPE:\n      return new RawSliceCoder();\n    case BOOL_CODER_TYPE:\n      return new BooleanCoder(options);\n    case B256_CODER_TYPE:\n      return new B256Coder();\n    case B512_CODER_TYPE:\n      return new B512Coder();\n    case BYTES_CODER_TYPE:\n      return new ByteCoder();\n    case STD_STRING_CODER_TYPE:\n      return new StdStringCoder();\n    default:\n      break;\n  }\n\n  const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n  if (stringMatch) {\n    const length = parseInt(stringMatch.length, 10);\n\n    return new StringCoder(length);\n  }\n\n  // ABI types underneath MUST have components by definition\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const components = resolvedAbiType.components!;\n\n  const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n  if (arrayMatch) {\n    const length = parseInt(arrayMatch.length, 10);\n    const arg = components[0];\n    if (!arg) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided Array type is missing an item of 'component'.`\n      );\n    }\n\n    const arrayElementCoder = getCoder(arg, { isSmallBytes: true });\n    return new ArrayCoder(arrayElementCoder as Coder, length);\n  }\n\n  if (resolvedAbiType.type === VEC_CODER_TYPE) {\n    const arg = findOrThrow(components, (c) => c.name === 'buf').originalTypeArguments?.[0];\n    if (!arg) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided Vec type is missing the 'type argument'.`\n      );\n    }\n    const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n\n    const itemCoder = getCoder(argType, { isSmallBytes: true, encoding: ENCODING_V0 });\n    return new VecCoder(itemCoder as Coder);\n  }\n\n  const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;\n  if (structMatch) {\n    const coders = getCoders(components, { isRightPadded: true, getCoder });\n    return new StructCoder(structMatch.name, coders);\n  }\n\n  const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;\n  if (enumMatch) {\n    const coders = getCoders(components, { getCoder });\n\n    const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n    if (isOptionEnum) {\n      return new OptionCoder(enumMatch.name, coders);\n    }\n    return new EnumCoder(enumMatch.name, coders);\n  }\n\n  const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n  if (tupleMatch) {\n    const coders = components.map((component) =>\n      getCoder(component, { isRightPadded: true, encoding: ENCODING_V0 })\n    );\n    return new TupleCoder(coders as Coder[]);\n  }\n\n  if (resolvedAbiType.type === STR_SLICE_CODER_TYPE) {\n    throw new FuelError(\n      ErrorCode.INVALID_DATA,\n      'String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`'\n    );\n  }\n\n  throw new FuelError(\n    ErrorCode.CODER_NOT_FOUND,\n    `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n  );\n};\n","import type { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport type { Coder } from '../coders/AbstractCoder';\n\n/**\n * @param components - types array to create coders for.\n * @param options - options - options to be utilized during the encoding process.\n * @returns an object containing types and an appropriate coder.\n */\nexport function getCoders(\n  components: readonly ResolvedAbiType[],\n  options: EncodingOptions & { getCoder: GetCoderFn }\n) {\n  const { getCoder } = options;\n  return components.reduce((obj, component) => {\n    const o: Record<string, Coder> = obj;\n\n    o[component.name] = getCoder(component, options);\n    return o;\n  }, {});\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport { ResolvedAbiType } from '../../ResolvedAbiType';\nimport type { EncodingOptions } from '../../types/EncodingOptions';\nimport type { GetCoderFn } from '../../types/GetCoder';\nimport {\n  B256_CODER_TYPE,\n  B512_CODER_TYPE,\n  BOOL_CODER_TYPE,\n  BYTES_CODER_TYPE,\n  ENCODING_V0,\n  OPTION_CODER_TYPE,\n  RAW_PTR_CODER_TYPE,\n  RAW_SLICE_CODER_TYPE,\n  STD_STRING_CODER_TYPE,\n  STR_SLICE_CODER_TYPE,\n  U16_CODER_TYPE,\n  U256_CODER_TYPE,\n  U32_CODER_TYPE,\n  U64_CODER_TYPE,\n  U8_CODER_TYPE,\n  VEC_CODER_TYPE,\n  arrayRegEx,\n  enumRegEx,\n  stringRegEx,\n  structRegEx,\n  tupleRegEx,\n} from '../../utils/constants';\nimport { findOrThrow } from '../../utils/utilities';\nimport type { Coder } from '../coders/AbstractCoder';\nimport { ArrayCoder } from '../coders/v0/ArrayCoder';\nimport { B256Coder } from '../coders/v0/B256Coder';\nimport { B512Coder } from '../coders/v0/B512Coder';\nimport { BigNumberCoder } from '../coders/v0/BigNumberCoder';\nimport { OptionCoder } from '../coders/v0/OptionCoder';\nimport { BooleanCoder } from '../coders/v1/BooleanCoder';\nimport { ByteCoder } from '../coders/v1/ByteCoder';\nimport { EnumCoder } from '../coders/v1/EnumCoder';\nimport { NumberCoder } from '../coders/v1/NumberCoder';\nimport { RawSliceCoder } from '../coders/v1/RawSliceCoder';\nimport { StdStringCoder } from '../coders/v1/StdStringCoder';\nimport { StringCoder } from '../coders/v1/StringCoder';\nimport { StructCoder } from '../coders/v1/StructCoder';\nimport { TupleCoder } from '../coders/v1/TupleCoder';\nimport { VecCoder } from '../coders/v1/VecCoder';\n\nimport { getCoders } from './getCoders';\n\n/**\n * Retrieves coders that adhere to the v0 spec.\n *\n * @param resolvedAbiType - the resolved type to return a coder for.\n * @param options - options to be utilized during the encoding process.\n * @returns the coder for a given type.\n */\nexport const getCoder: GetCoderFn = (\n  resolvedAbiType: ResolvedAbiType,\n  _options?: EncodingOptions\n): Coder => {\n  switch (resolvedAbiType.type) {\n    case U8_CODER_TYPE:\n    case U16_CODER_TYPE:\n    case U32_CODER_TYPE:\n      return new NumberCoder(resolvedAbiType.type);\n    case U64_CODER_TYPE:\n    case RAW_PTR_CODER_TYPE:\n      return new BigNumberCoder('u64');\n    case U256_CODER_TYPE:\n      return new BigNumberCoder('u256');\n    case RAW_SLICE_CODER_TYPE:\n      return new RawSliceCoder();\n    case BOOL_CODER_TYPE:\n      return new BooleanCoder();\n    case B256_CODER_TYPE:\n      return new B256Coder();\n    case B512_CODER_TYPE:\n      return new B512Coder();\n    case BYTES_CODER_TYPE:\n      return new ByteCoder();\n    case STD_STRING_CODER_TYPE:\n      return new StdStringCoder();\n    default:\n      break;\n  }\n\n  const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;\n  if (stringMatch) {\n    const length = parseInt(stringMatch.length, 10);\n\n    return new StringCoder(length);\n  }\n\n  // ABI types underneath MUST have components by definition\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const components = resolvedAbiType.components!;\n\n  const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;\n  if (arrayMatch) {\n    const length = parseInt(arrayMatch.length, 10);\n    const arg = components[0];\n    if (!arg) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided Array type is missing an item of 'component'.`\n      );\n    }\n\n    const arrayElementCoder = getCoder(arg, { isSmallBytes: true });\n    return new ArrayCoder(arrayElementCoder as Coder, length);\n  }\n\n  if (resolvedAbiType.type === VEC_CODER_TYPE) {\n    const arg = findOrThrow(components, (c) => c.name === 'buf').originalTypeArguments?.[0];\n    if (!arg) {\n      throw new FuelError(\n        ErrorCode.INVALID_COMPONENT,\n        `The provided Vec type is missing the 'type argument'.`\n      );\n    }\n    const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);\n\n    const itemCoder = getCoder(argType, { isSmallBytes: true, encoding: ENCODING_V0 });\n    return new VecCoder(itemCoder as Coder);\n  }\n\n  const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;\n  if (structMatch) {\n    const coders = getCoders(components, { isRightPadded: true, getCoder });\n    return new StructCoder(structMatch.name, coders);\n  }\n\n  const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;\n  if (enumMatch) {\n    const coders = getCoders(components, { getCoder });\n\n    const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;\n    if (isOptionEnum) {\n      return new OptionCoder(enumMatch.name, coders);\n    }\n    return new EnumCoder(enumMatch.name, coders);\n  }\n\n  const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;\n  if (tupleMatch) {\n    const coders = components.map((component) =>\n      getCoder(component, { isRightPadded: true, encoding: ENCODING_V0 })\n    );\n    return new TupleCoder(coders as Coder[]);\n  }\n\n  if (resolvedAbiType.type === STR_SLICE_CODER_TYPE) {\n    throw new FuelError(\n      ErrorCode.INVALID_DATA,\n      'String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`'\n    );\n  }\n\n  throw new FuelError(\n    ErrorCode.CODER_NOT_FOUND,\n    `Coder not found: ${JSON.stringify(resolvedAbiType)}.`\n  );\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from '../AbstractCoder';\n\nexport class BooleanCoder extends Coder<boolean, boolean> {\n  constructor() {\n    super('boolean', 'boolean', 1);\n  }\n\n  encode(value: boolean): Uint8Array {\n    const isTrueBool = value === true || value === false;\n\n    if (!isTrueBool) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return toBytes(value ? 1 : 0, this.encodedLength);\n  }\n\n  decode(data: Uint8Array, offset: number): [boolean, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean data size.`);\n    }\n\n    const bytes = bn(data.slice(offset, offset + this.encodedLength));\n\n    if (bytes.isZero()) {\n      return [false, offset + this.encodedLength];\n    }\n\n    if (!bytes.eq(bn(1))) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);\n    }\n\n    return [true, offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport { Coder } from '../AbstractCoder';\nimport { BigNumberCoder } from '../v0/BigNumberCoder';\n\nexport class ByteCoder extends Coder<number[], Uint8Array> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct Bytes', WORD_SIZE);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const bytes = new Uint8Array(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [Uint8Array, number] {\n    if (data.length < WORD_SIZE) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid byte data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid bytes byte data size.`);\n    }\n\n    return [dataBytes, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber } from '@fuel-ts/math';\nimport { concat } from '@fuel-ts/utils';\nimport type { RequireExactlyOne } from 'type-fest';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\nimport { BigNumberCoder } from '../v0/BigNumberCoder';\n\nexport type InputValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n}>;\nexport type DecodedValueOf<TCoders extends Record<string, Coder>> = RequireExactlyOne<{\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n}>;\n\nconst isFullyNativeEnum = (enumCoders: { [s: string]: unknown } | ArrayLike<unknown>): boolean =>\n  Object.values(enumCoders).every(\n    // @ts-expect-error complicated types\n    ({ type, coders }) => type === '()' && JSON.stringify(coders) === JSON.stringify([])\n  );\n\nexport class EnumCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n  #caseIndexCoder: BigNumberCoder;\n  #encodedValueSize: number;\n\n  constructor(name: string, coders: TCoders) {\n    const caseIndexCoder = new BigNumberCoder('u64');\n    const encodedValueSize = Object.values(coders).reduce(\n      (max, coder) => Math.max(max, coder.encodedLength),\n      0\n    );\n    super('enum', `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);\n    this.name = name;\n    this.coders = coders;\n    this.#caseIndexCoder = caseIndexCoder;\n    this.#encodedValueSize = encodedValueSize;\n  }\n\n  #encodeNativeEnum(value: string): Uint8Array {\n    const valueCoder = this.coders[value];\n    const encodedValue = valueCoder.encode([]);\n    const caseIndex = Object.keys(this.coders).indexOf(value);\n\n    const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);\n    return concat([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (typeof value === 'string' && this.coders[value]) {\n      return this.#encodeNativeEnum(value);\n    }\n\n    const [caseKey, ...empty] = Object.keys(value);\n    if (!caseKey) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'A field for the case must be provided.');\n    }\n    if (empty.length !== 0) {\n      throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, 'Only one field must be provided.');\n    }\n    const valueCoder = this.coders[caseKey];\n    const caseIndex = Object.keys(this.coders).indexOf(caseKey);\n    const encodedValue = valueCoder.encode(value[caseKey]);\n\n    return new Uint8Array([...this.#caseIndexCoder.encode(caseIndex), ...encodedValue]);\n  }\n\n  #decodeNativeEnum(caseKey: string, newOffset: number): [DecodedValueOf<TCoders>, number] {\n    return [caseKey as unknown as DecodedValueOf<TCoders>, newOffset];\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.#encodedValueSize) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid enum data size.`);\n    }\n\n    const caseBytes = new BigNumberCoder('u64').decode(data, offset)[0];\n    const caseIndex = toNumber(caseBytes);\n    const caseKey = Object.keys(this.coders)[caseIndex];\n    if (!caseKey) {\n      throw new FuelError(\n        ErrorCode.INVALID_DECODE_VALUE,\n        `Invalid caseIndex \"${caseIndex}\". Valid cases: ${Object.keys(this.coders)}.`\n      );\n    }\n\n    const valueCoder = this.coders[caseKey];\n    const offsetAndCase = offset + WORD_SIZE;\n\n    const [decoded, newOffset] = valueCoder.decode(data, offsetAndCase);\n\n    if (isFullyNativeEnum(this.coders)) {\n      return this.#decodeNativeEnum(caseKey, newOffset);\n    }\n\n    return [{ [caseKey]: decoded } as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toNumber, toBytes } from '@fuel-ts/math';\n\nimport { Coder } from '../AbstractCoder';\n\ntype NumberCoderType = 'u8' | 'u16' | 'u32' | 'u64';\n\nconst getLength = (baseType: NumberCoderType): number => {\n  switch (baseType) {\n    case 'u8':\n      return 1;\n    case 'u16':\n      return 2;\n    case 'u32':\n      return 4;\n    default:\n      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Invalid number type: ${baseType}`);\n  }\n};\n\nexport class NumberCoder extends Coder<number, number> {\n  length: number;\n  baseType: NumberCoderType;\n\n  constructor(baseType: NumberCoderType) {\n    const length = getLength(baseType);\n    super('number', baseType, length);\n    this.baseType = baseType;\n    this.length = length;\n  }\n\n  encode(value: number | string): Uint8Array {\n    let bytes;\n\n    try {\n      bytes = toBytes(value);\n    } catch (error) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);\n    }\n\n    if (bytes.length > this.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);\n    }\n\n    return toBytes(bytes, this.length);\n  }\n\n  decode(data: Uint8Array, offset: number): [number, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.length);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid number byte data size.`);\n    }\n\n    return [toNumber(bytes), offset + this.length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport { Coder } from '../AbstractCoder';\nimport { ArrayCoder } from '../v0/ArrayCoder';\nimport { BigNumberCoder } from '../v0/BigNumberCoder';\n\nimport { NumberCoder } from './NumberCoder';\n\nexport class RawSliceCoder extends Coder<number[], number[]> {\n  constructor() {\n    super('raw untyped slice', 'raw untyped slice', WORD_SIZE);\n  }\n\n  encode(value: number[]): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), value.length);\n    const bytes = internalCoder.encode(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(bytes.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [number[], number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid raw slice byte data size.`);\n    }\n\n    const internalCoder = new ArrayCoder(new NumberCoder('u8'), length);\n    const [decodedValue] = internalCoder.decode(dataBytes, 0);\n\n    return [decodedValue, offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { WORD_SIZE } from '../../../utils/constants';\nimport { Coder } from '../AbstractCoder';\nimport { BigNumberCoder } from '../v0/BigNumberCoder';\n\nexport class StdStringCoder extends Coder<string, string> {\n  static memorySize = 1;\n  constructor() {\n    super('struct', 'struct String', WORD_SIZE);\n  }\n\n  encode(value: string): Uint8Array {\n    const bytes = toUtf8Bytes(value);\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...bytes]);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + length);\n\n    if (dataBytes.length !== length) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid std string byte data size.`);\n    }\n\n    return [toUtf8String(dataBytes), offsetAndLength + length];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { toUtf8Bytes, toUtf8String } from 'ethers';\n\nimport { Coder } from '../AbstractCoder';\n\nexport class StringCoder<TLength extends number = number> extends Coder<string, string> {\n  constructor(length: TLength) {\n    super('string', `str[${length}]`, length);\n  }\n\n  encode(value: string): Uint8Array {\n    if (value.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);\n    }\n\n    return toUtf8Bytes(value);\n  }\n\n  decode(data: Uint8Array, offset: number): [string, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string data size.`);\n    }\n\n    const bytes = data.slice(offset, offset + this.encodedLength);\n\n    if (bytes.length !== this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid string byte data size.`);\n    }\n\n    return [toUtf8String(bytes), offset + this.encodedLength];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\nimport { OptionCoder } from '../v0/OptionCoder';\n\ntype InputValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Record<string, Coder>> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class StructCoder<TCoders extends Record<string, Coder>> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  name: string;\n  coders: TCoders;\n\n  constructor(name: string, coders: TCoders) {\n    const encodedLength = Object.values(coders).reduce(\n      (acc, coder) => acc + coder.encodedLength,\n      0\n    );\n    super('struct', `struct ${name}`, encodedLength);\n    this.name = name;\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    return concatBytes(\n      Object.keys(this.coders).map((fieldName) => {\n        const fieldCoder = this.coders[fieldName];\n        const fieldValue = value[fieldName];\n\n        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {\n          throw new FuelError(\n            ErrorCode.ENCODE_ERROR,\n            `Invalid ${this.type}. Field \"${fieldName}\" not present.`\n          );\n        }\n\n        return fieldCoder.encode(fieldValue);\n      })\n    );\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid struct data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {\n      const fieldCoder = this.coders[fieldName];\n      let decoded;\n      [decoded, newOffset] = fieldCoder.decode(data, newOffset);\n\n      // eslint-disable-next-line no-param-reassign\n      obj[fieldName as keyof DecodedValueOf<TCoders>] = decoded;\n      return obj;\n    }, {} as DecodedValueOf<TCoders>);\n\n    return [decodedValue, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\n\ntype InputValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Input'];\n};\ntype DecodedValueOf<TCoders extends Coder[]> = {\n  [P in keyof TCoders]: TypesOfCoder<TCoders[P]>['Decoded'];\n};\n\nexport class TupleCoder<TCoders extends Coder[]> extends Coder<\n  InputValueOf<TCoders>,\n  DecodedValueOf<TCoders>\n> {\n  coders: TCoders;\n\n  constructor(coders: TCoders) {\n    const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);\n    super('tuple', `(${coders.map((coder) => coder.type).join(', ')})`, encodedLength);\n    this.coders = coders;\n  }\n\n  encode(value: InputValueOf<TCoders>): Uint8Array {\n    if (this.coders.length !== value.length) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);\n    }\n\n    return concatBytes(this.coders.map((coder, i) => coder.encode(value[i])));\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoders>, number] {\n    if (data.length < this.encodedLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid tuple data size.`);\n    }\n\n    let newOffset = offset;\n    const decodedValue = this.coders.map((coder) => {\n      let decoded;\n      [decoded, newOffset] = coder.decode(data, newOffset);\n\n      return decoded;\n    });\n\n    return [decodedValue as DecodedValueOf<TCoders>, newOffset];\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { concatBytes } from '@fuel-ts/utils';\n\nimport { MAX_BYTES, WORD_SIZE } from '../../../utils/constants';\nimport { chunkByLength } from '../../../utils/utilities';\nimport type { TypesOfCoder } from '../AbstractCoder';\nimport { Coder } from '../AbstractCoder';\nimport { BigNumberCoder } from '../v0/BigNumberCoder';\n\ntype InputValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Input']>;\ntype DecodedValueOf<TCoder extends Coder> = Array<TypesOfCoder<TCoder>['Decoded']>;\n\nexport class VecCoder<TCoder extends Coder> extends Coder<\n  InputValueOf<TCoder>,\n  DecodedValueOf<TCoder>\n> {\n  coder: TCoder;\n\n  constructor(coder: TCoder) {\n    super('struct', `struct Vec`, coder.encodedLength + WORD_SIZE);\n    this.coder = coder;\n  }\n\n  encode(value: InputValueOf<TCoder>): Uint8Array {\n    if (!Array.isArray(value)) {\n      throw new FuelError(ErrorCode.ENCODE_ERROR, `Expected array value.`);\n    }\n\n    const bytes = value.map((v) => this.coder.encode(v));\n    const lengthBytes = new BigNumberCoder('u64').encode(value.length);\n\n    return new Uint8Array([...lengthBytes, ...concatBytes(bytes)]);\n  }\n\n  decode(data: Uint8Array, offset: number): [DecodedValueOf<TCoder>, number] {\n    if (data.length < this.encodedLength || data.length > MAX_BYTES) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec data size.`);\n    }\n\n    const offsetAndLength = offset + WORD_SIZE;\n    const lengthBytes = data.slice(offset, offsetAndLength);\n    const length = bn(new BigNumberCoder('u64').decode(lengthBytes, 0)[0]).toNumber();\n    const dataLength = length * this.coder.encodedLength;\n    const dataBytes = data.slice(offsetAndLength, offsetAndLength + dataLength);\n\n    if (dataBytes.length !== dataLength) {\n      throw new FuelError(ErrorCode.DECODE_ERROR, `Invalid vec byte data size.`);\n    }\n\n    return [\n      chunkByLength(dataBytes, this.coder.encodedLength).map(\n        (chunk) => this.coder.decode(chunk, 0)[0]\n      ),\n      offsetAndLength + dataLength,\n    ];\n  }\n}\n","import { ResolvedAbiType } from './ResolvedAbiType';\nimport type { DecodedValue, InputValue, Coder } from './encoding/coders/AbstractCoder';\nimport { getCoderForEncoding } from './encoding/strategies/getCoderForEncoding';\nimport type { EncodingOptions } from './types/EncodingOptions';\nimport type { JsonAbi, JsonAbiArgument } from './types/JsonAbi';\n\nexport abstract class AbiCoder {\n  static getCoder(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    options: EncodingOptions = {\n      isSmallBytes: false,\n    }\n  ): Coder {\n    const resolvedAbiType = new ResolvedAbiType(abi, argument);\n    return getCoderForEncoding(options.encoding)(resolvedAbiType, options);\n  }\n\n  static encode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    value: InputValue,\n    options?: EncodingOptions\n  ) {\n    return this.getCoder(abi, argument, options).encode(value);\n  }\n\n  static decode(\n    abi: JsonAbi,\n    argument: JsonAbiArgument,\n    data: Uint8Array,\n    offset: number,\n    options?: EncodingOptions\n  ): [DecodedValue | undefined, number] {\n    return this.getCoder(abi, argument, options).decode(data, offset) as [\n      DecodedValue | undefined,\n      number,\n    ];\n  }\n}\n","import { bufferFromString } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BytesLike } from '@fuel-ts/interfaces';\nimport { bn } from '@fuel-ts/math';\nimport { arrayify } from '@fuel-ts/utils';\nimport { sha256 } from 'ethers';\n\nimport { AbiCoder } from './AbiCoder';\nimport { ResolvedAbiType } from './ResolvedAbiType';\nimport type { DecodedValue, InputValue } from './encoding/coders/AbstractCoder';\nimport { ByteCoder } from './encoding/coders/v0/ByteCoder';\nimport { TupleCoder } from './encoding/coders/v0/TupleCoder';\nimport { VecCoder } from './encoding/coders/v0/VecCoder';\nimport type {\n  JsonAbi,\n  JsonAbiArgument,\n  JsonAbiFunction,\n  JsonAbiFunctionAttribute,\n} from './types/JsonAbi';\nimport { OPTION_CODER_TYPE } from './utils/constants';\nimport type { Uint8ArrayWithDynamicData } from './utils/utilities';\nimport { isPointerType, unpackDynamicData, findOrThrow, isHeapType } from './utils/utilities';\n\nexport class FunctionFragment<\n  TAbi extends JsonAbi = JsonAbi,\n  FnName extends TAbi['functions'][number]['name'] = string,\n> {\n  readonly signature: string;\n  readonly selector: string;\n  readonly name: string;\n  readonly jsonFn: JsonAbiFunction;\n  readonly attributes: readonly JsonAbiFunctionAttribute[];\n  readonly isInputDataPointer: boolean;\n  readonly outputMetadata: {\n    isHeapType: boolean;\n    encodedLength: number;\n  };\n\n  private readonly jsonAbi: JsonAbi;\n\n  constructor(jsonAbi: JsonAbi, name: FnName) {\n    this.jsonAbi = jsonAbi;\n    this.jsonFn = findOrThrow(this.jsonAbi.functions, (f) => f.name === name);\n    this.name = name;\n    this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);\n    this.selector = FunctionFragment.getFunctionSelector(this.signature);\n    this.isInputDataPointer = this.#isInputDataPointer();\n    this.outputMetadata = {\n      isHeapType: this.#isOutputDataHeap(),\n      encodedLength: this.#getOutputEncodedLength(),\n    };\n\n    this.attributes = this.jsonFn.attributes ?? [];\n  }\n\n  private static getSignature(abi: JsonAbi, fn: JsonAbiFunction): string {\n    const inputsSignatures = fn.inputs.map((input) =>\n      new ResolvedAbiType(abi, input).getSignature()\n    );\n    return `${fn.name}(${inputsSignatures.join(',')})`;\n  }\n\n  private static getFunctionSelector(functionSignature: string) {\n    const hashedFunctionSignature = sha256(bufferFromString(functionSignature, 'utf-8'));\n    // get first 4 bytes of signature + 0x prefix. then left-pad it to 8 bytes using toHex(8)\n    return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);\n  }\n\n  #isInputDataPointer(): boolean {\n    const inputTypes = this.jsonFn.inputs.map((i) =>\n      this.jsonAbi.types.find((t) => t.typeId === i.type)\n    );\n\n    return this.jsonFn.inputs.length > 1 || isPointerType(inputTypes[0]?.type || '');\n  }\n\n  #isOutputDataHeap(): boolean {\n    const outputType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);\n\n    return isHeapType(outputType?.type || '');\n  }\n\n  #getOutputEncodedLength(): number {\n    try {\n      const heapCoder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);\n      if (heapCoder instanceof VecCoder) {\n        return heapCoder.coder.encodedLength;\n      }\n      if (heapCoder instanceof ByteCoder) {\n        return ByteCoder.memorySize;\n      }\n\n      return heapCoder.encodedLength;\n    } catch (e) {\n      return 0;\n    }\n  }\n\n  encodeArguments(values: InputValue[], offset = 0): Uint8Array {\n    FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);\n\n    const shallowCopyValues = values.slice();\n\n    const nonEmptyInputs = this.jsonFn.inputs.filter(\n      (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== '()'\n    );\n\n    if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {\n      shallowCopyValues.length = this.jsonFn.inputs.length;\n      shallowCopyValues.fill(undefined as unknown as InputValue, values.length);\n    }\n\n    const coders = nonEmptyInputs.map((t) =>\n      AbiCoder.getCoder(this.jsonAbi, t, {\n        isRightPadded: nonEmptyInputs.length > 1,\n      })\n    );\n\n    const coder = new TupleCoder(coders);\n    const results: Uint8ArrayWithDynamicData = coder.encode(shallowCopyValues);\n\n    return unpackDynamicData(results, offset, results.byteLength);\n  }\n\n  private static verifyArgsAndInputsAlign(\n    args: InputValue[],\n    inputs: readonly JsonAbiArgument[],\n    abi: JsonAbi\n  ) {\n    if (args.length === inputs.length) {\n      return;\n    }\n\n    const inputTypes = inputs.map((i) => findOrThrow(abi.types, (t) => t.typeId === i.type));\n    const optionalInputs = inputTypes.filter(\n      (x) => x.type === OPTION_CODER_TYPE || x.type === '()'\n    );\n    if (optionalInputs.length === inputTypes.length) {\n      return;\n    }\n    if (inputTypes.length - optionalInputs.length === args.length) {\n      return;\n    }\n\n    const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${\n      args.length\n    } arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${\n      optionalInputs.length\n    } optional inputs).`;\n\n    throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);\n  }\n\n  decodeArguments(data: BytesLike) {\n    const bytes = arrayify(data);\n    const nonEmptyInputs = this.jsonFn.inputs.filter(\n      (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== '()'\n    );\n\n    if (nonEmptyInputs.length === 0) {\n      // The VM is current return 0x0000000000000000, but we should treat it as undefined / void\n      if (bytes.length === 0) {\n        return undefined;\n      }\n\n      throw new FuelError(\n        ErrorCode.DECODE_ERROR,\n        `Types/values length mismatch during decode. ${JSON.stringify({\n          count: {\n            types: this.jsonFn.inputs.length,\n            nonEmptyInputs: nonEmptyInputs.length,\n            values: bytes.length,\n          },\n          value: {\n            args: this.jsonFn.inputs,\n            nonEmptyInputs,\n            values: bytes,\n          },\n        })}`\n      );\n    }\n\n    const result = nonEmptyInputs.reduce(\n      (obj: { decoded: unknown[]; offset: number }, input) => {\n        const coder = AbiCoder.getCoder(this.jsonAbi, input);\n        const [decodedValue, decodedValueByteSize] = coder.decode(bytes, obj.offset);\n\n        return {\n          decoded: [...obj.decoded, decodedValue],\n          offset: obj.offset + decodedValueByteSize,\n        };\n      },\n      { decoded: [], offset: 0 }\n    );\n\n    return result.decoded;\n  }\n\n  decodeOutput(data: BytesLike): [DecodedValue | undefined, number] {\n    const outputAbiType = findOrThrow(\n      this.jsonAbi.types,\n      (t) => t.typeId === this.jsonFn.output.type\n    );\n    if (outputAbiType.type === '()') {\n      return [undefined, 0];\n    }\n\n    const bytes = arrayify(data);\n    const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);\n\n    return coder.decode(bytes, 0) as [DecodedValue | undefined, number];\n  }\n}\n"],"mappings":"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","names":["ErrorCode","FuelError","ErrorCode","FuelError","FuelError","ErrorCode","FuelError","ErrorCode","ErrorCode","FuelError","bn","arrayify","arrayify","FuelError","ErrorCode","bn","ErrorCode","FuelError","bn","toHex","arrayify","arrayify","FuelError","ErrorCode","bn","toHex","ErrorCode","FuelError","bn","toBytes","FuelError","ErrorCode","toBytes","bn","ErrorCode","FuelError","bn","concat","FuelError","ErrorCode","bn","concat","ErrorCode","FuelError","concat","concat","FuelError","ErrorCode","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","toNumber","toBytes","toBytes","FuelError","ErrorCode","toNumber","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","bn","concat","_getPaddedData","getPaddedData_fn","FuelError","ErrorCode","bn","concat","ErrorCode","FuelError","concat","toUtf8Bytes","toUtf8String","FuelError","ErrorCode","toUtf8Bytes","concat","toUtf8String","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","bn","FuelError","ErrorCode","bn","ErrorCode","FuelError","arrayify","ErrorCode","FuelError","FuelError","ErrorCode","ErrorCode","FuelError","ErrorCode","FuelError","getCoder","FuelError","ErrorCode","ErrorCode","FuelError","ErrorCode","FuelError","bn","toBytes","BooleanCoder","FuelError","ErrorCode","toBytes","bn","ErrorCode","FuelError","bn","ByteCoder","FuelError","ErrorCode","bn","ErrorCode","FuelError","toNumber","concat","isFullyNativeEnum","EnumCoder","concat","FuelError","ErrorCode","toNumber","ErrorCode","FuelError","toNumber","toBytes","FuelError","ErrorCode","NumberCoder","toBytes","toNumber","ErrorCode","FuelError","bn","RawSliceCoder","FuelError","ErrorCode","NumberCoder","bn","ErrorCode","FuelError","bn","toUtf8Bytes","toUtf8String","StdStringCoder","toUtf8Bytes","FuelError","ErrorCode","bn","toUtf8String","ErrorCode","FuelError","toUtf8Bytes","toUtf8String","StringCoder","FuelError","ErrorCode","toUtf8Bytes","toUtf8String","ErrorCode","FuelError","concatBytes","StructCoder","concatBytes","FuelError","ErrorCode","ErrorCode","FuelError","concatBytes","TupleCoder","FuelError","ErrorCode","concatBytes","ErrorCode","FuelError","bn","concatBytes","VecCoder","FuelError","ErrorCode","concatBytes","bn","getCoder","NumberCoder","RawSliceCoder","BooleanCoder","ByteCoder","StdStringCoder","StringCoder","FuelError","ErrorCode","VecCoder","StructCoder","EnumCoder","TupleCoder","getCoder","FuelError","ErrorCode","ErrorCode","FuelError","bn","arrayify","bn","FuelError","ErrorCode","arrayify","FuelError","ErrorCode","arrayify"]}