{"version":3,"sources":["../src/index.ts","../src/contract-factory.ts","../src/util.ts"],"sourcesContent":["export { default as ContractFactory, DeployContractOptions } from './contract-factory';\n/**\n * @hidden\n */\nexport * as ContractUtils from './util';\n","import { Interface } from '@fuel-ts/abi-coder';\nimport type { JsonAbi, InputValue } from '@fuel-ts/abi-coder';\nimport { CreateTransactionRequest } from '@fuel-ts/account';\nimport type { Account, CreateTransactionRequestLike, Provider } from '@fuel-ts/account';\nimport { randomBytes } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { Contract } from '@fuel-ts/program';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport { getBytesCopy, type BytesLike } from 'ethers';\n\nimport { getContractId, getContractStorageRoot, hexlifyWithPrefix } from './util';\n\n/**\n * Options for deploying a contract.\n */\nexport type DeployContractOptions = {\n  salt?: BytesLike;\n  storageSlots?: StorageSlot[];\n  stateRoot?: BytesLike;\n  configurableConstants?: { [name: string]: unknown };\n} & CreateTransactionRequestLike;\n\n/**\n * `ContractFactory` provides utilities for deploying and configuring contracts.\n */\nexport default class ContractFactory {\n  bytecode: BytesLike;\n  interface: Interface;\n  provider!: Provider | null;\n  account!: Account | null;\n\n  /**\n   * Create a ContractFactory instance.\n   *\n   * @param bytecode - The bytecode of the contract.\n   * @param abi - The contract's ABI (Application Binary Interface).\n   * @param accountOrProvider - An account or provider to be associated with the factory.\n   */\n  constructor(\n    bytecode: BytesLike,\n    abi: JsonAbi | Interface,\n    accountOrProvider: Account | Provider | null = null\n  ) {\n    // Force the bytecode to be a byte array\n    this.bytecode = getBytesCopy(bytecode);\n\n    if (abi instanceof Interface) {\n      this.interface = abi;\n    } else {\n      this.interface = new Interface(abi);\n    }\n\n    /**\n     Instead of using `instanceof` to compare classes, we instead check\n      if `accountOrProvider` has a `provider` property inside. If yes,\n      than we assume it's a Wallet.\n\n      This approach is safer than using `instanceof` because it\n      there might be different versions and bundles of the library.\n\n      The same is done at:\n      - ./contract.ts\n\n      @see Contract\n      */\n    if (accountOrProvider && 'provider' in accountOrProvider) {\n      this.provider = accountOrProvider.provider;\n      this.account = accountOrProvider;\n    } else {\n      this.provider = accountOrProvider;\n      this.account = null;\n    }\n  }\n\n  /**\n   * Connect the factory to a provider.\n   *\n   * @param provider - The provider to be associated with the factory.\n   * @returns A new ContractFactory instance.\n   */\n  connect(provider: Provider) {\n    return new ContractFactory(this.bytecode, this.interface, provider);\n  }\n\n  /**\n   * Create a transaction request to deploy a contract with the specified options.\n   *\n   * @param deployContractOptions - Options for deploying the contract.\n   * @returns The CreateTransactionRequest object for deploying the contract.\n   */\n  createTransactionRequest(deployContractOptions?: DeployContractOptions) {\n    const storageSlots = deployContractOptions?.storageSlots\n      ?.map(({ key, value }) => ({\n        key: hexlifyWithPrefix(key, true),\n        value: hexlifyWithPrefix(value, true),\n      }))\n      .sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));\n\n    const options = {\n      salt: randomBytes(32),\n      ...deployContractOptions,\n      storageSlots: storageSlots || [],\n    };\n\n    if (!this.provider) {\n      throw new FuelError(\n        ErrorCode.MISSING_PROVIDER,\n        'Cannot create transaction request without provider'\n      );\n    }\n\n    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);\n    const contractId = getContractId(this.bytecode, options.salt, stateRoot);\n    const transactionRequest = new CreateTransactionRequest({\n      gasPrice: 0,\n      bytecodeWitnessIndex: 0,\n      witnesses: [this.bytecode],\n      ...options,\n    });\n    transactionRequest.addContractCreatedOutput(contractId, stateRoot);\n\n    return {\n      contractId,\n      transactionRequest,\n    };\n  }\n\n  /**\n   * Deploy a contract with the specified options.\n   *\n   * @param deployContractOptions - Options for deploying the contract.\n   * @returns A promise that resolves to the deployed contract instance.\n   */\n  async deployContract(deployContractOptions: DeployContractOptions = {}) {\n    if (!this.account) {\n      throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, 'Cannot deploy Contract without account.');\n    }\n\n    const { configurableConstants } = deployContractOptions;\n\n    if (configurableConstants) {\n      this.setConfigurableConstants(configurableConstants);\n    }\n\n    const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);\n\n    const { requiredQuantities, maxFee } =\n      await this.account.provider.getTransactionCost(transactionRequest);\n\n    transactionRequest.gasPrice = this.account.provider.getGasConfig().minGasPrice;\n    transactionRequest.maxFee = this.account.provider.getGasConfig().maxGasPerTx;\n\n    await this.account.fund(transactionRequest, requiredQuantities, maxFee);\n    await this.account.sendTransaction(transactionRequest, {\n      awaitExecution: true,\n    });\n\n    return new Contract(contractId, this.interface, this.account);\n  }\n\n  /**\n   * Set configurable constants of the contract with the specified values.\n   *\n   * @param configurableConstants - An object containing configurable names and their values.\n   */\n  setConfigurableConstants(configurableConstants: { [name: string]: unknown }) {\n    try {\n      const hasConfigurable = Object.keys(this.interface.configurables).length;\n\n      if (!hasConfigurable) {\n        throw new Error('Contract does not have configurables to be set');\n      }\n\n      Object.entries(configurableConstants).forEach(([key, value]) => {\n        if (!this.interface.configurables[key]) {\n          throw new Error(`Contract does not have a configurable named: '${key}'`);\n        }\n\n        const { offset } = this.interface.configurables[key];\n\n        const encoded = this.interface.encodeConfigurable(key, value as InputValue);\n\n        const bytes = getBytesCopy(this.bytecode);\n\n        bytes.set(encoded, offset);\n\n        this.bytecode = bytes;\n      });\n    } catch (err) {\n      throw new FuelError(\n        ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,\n        `Error setting configurable constants on contract: ${(<Error>err).message}.`\n      );\n    }\n  }\n}\n","import { FuelError } from '@fuel-ts/errors';\nimport { calcRoot, SparseMerkleTree } from '@fuel-ts/merkle';\nimport type { StorageSlot } from '@fuel-ts/transactions';\nimport { chunkAndPadBytes } from '@fuel-ts/utils';\nimport type { BytesLike } from 'ethers';\nimport { sha256, hexlify, concat, getBytesCopy } from 'ethers';\n\n/**\n * @hidden\n *\n * Get the Merkle root of a contract's bytecode.\n *\n * @param bytecode - The bytecode of the contract.\n * @returns The Merkle root of the contract's bytecode.\n */\nexport const getContractRoot = (bytecode: BytesLike): string => {\n  const chunkSize = 16 * 1024;\n  const bytes = getBytesCopy(bytecode);\n  const chunks = chunkAndPadBytes(bytes, chunkSize);\n\n  return calcRoot(chunks.map((c) => hexlify(c)));\n};\n\n/**\n * @hidden\n *\n * Get the Merkle root of a contract's storage slots.\n *\n * @param storageSlots - An array of storage slots containing key-value pairs.\n * @returns The Merkle root of the contract's storage slots.\n */\nexport const getContractStorageRoot = (storageSlots: StorageSlot[]): string => {\n  const tree = new SparseMerkleTree();\n\n  storageSlots.forEach(({ key, value }) => tree.update(sha256(key), value));\n\n  return tree.root;\n};\n\n/**\n * @hidden\n *\n * Get the contract ID of a contract based on its bytecode, salt,\n * and state root.\n *\n * @param bytecode - The bytecode of the contract.\n * @param salt - The salt value used for contract creation.\n * @param stateRoot - The state root of the contract.\n * @returns The contract ID of the contract.\n */\nexport const getContractId = (\n  bytecode: BytesLike,\n  salt: BytesLike,\n  stateRoot: BytesLike\n): string => {\n  const root = getContractRoot(getBytesCopy(bytecode));\n  const contractId = sha256(concat(['0x4655454C', salt, root, stateRoot]));\n  return contractId;\n};\n\n/**\n * @hidden\n *\n * Ensures that a string is hexlified.\n *\n * @param value - The value to be hexlified.\n * @param isKnownHex - Required if using hex values that need to be converted\n * @returns The input value hexlified with prefix.\n */\nexport const hexlifyWithPrefix = (value: string, isKnownHex = false) => {\n  if (value.startsWith('0x')) {\n    return hexlify(value);\n  }\n\n  if (isKnownHex) {\n    return hexlify(`0x${value}`);\n  }\n\n  throw new FuelError(FuelError.CODES.UNEXPECTED_HEX_VALUE, `Value should be hex string ${value}.`);\n};\n"],"mappings":"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","names":["import_errors","import_ethers"]}