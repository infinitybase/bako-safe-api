"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Account: () => Account,
  AddressType: () => AddressType,
  BaseTransactionRequest: () => BaseTransactionRequest,
  BaseWalletUnlocked: () => BaseWalletUnlocked,
  ChainName: () => ChainName,
  ChangeOutputCollisionError: () => ChangeOutputCollisionError,
  CreateTransactionRequest: () => CreateTransactionRequest,
  Fuel: () => Fuel,
  FuelConnector: () => FuelConnector,
  FuelConnectorEventType: () => FuelConnectorEventType,
  FuelConnectorEventTypes: () => FuelConnectorEventTypes,
  FuelConnectorMethods: () => FuelConnectorMethods,
  HDWallet: () => hdwallet_default,
  Language: () => Language,
  LocalStorage: () => LocalStorage,
  MNEMONIC_SIZES: () => MNEMONIC_SIZES,
  MemoryStorage: () => MemoryStorage,
  MessageTypes: () => MessageTypes,
  Mnemonic: () => mnemonic_default,
  MnemonicVault: () => MnemonicVault,
  NoWitnessAtIndexError: () => NoWitnessAtIndexError,
  NoWitnessByOwnerError: () => NoWitnessByOwnerError,
  OperationName: () => OperationName,
  Predicate: () => Predicate,
  PrivateKeyVault: () => PrivateKeyVault,
  Provider: () => Provider,
  ScriptTransactionRequest: () => ScriptTransactionRequest,
  Signer: () => Signer,
  StorageAbstract: () => StorageAbstract,
  TransactionResponse: () => TransactionResponse,
  TransactionStatus: () => TransactionStatus,
  TransactionType: () => import_transactions5.TransactionType,
  TransactionTypeName: () => TransactionTypeName,
  Vault: () => Vault,
  Wallet: () => Wallet,
  WalletLocked: () => WalletLocked,
  WalletManager: () => WalletManager,
  WalletUnlocked: () => WalletUnlocked,
  addAmountToAsset: () => addAmountToAsset,
  addOperation: () => addOperation,
  assembleReceiptByType: () => assembleReceiptByType,
  assembleTransactionSummary: () => assembleTransactionSummary,
  buildBlockExplorerUrl: () => buildBlockExplorerUrl,
  cacheFor: () => cacheFor,
  calculateMetadataGasForTxCreate: () => calculateMetadataGasForTxCreate,
  calculateMetadataGasForTxScript: () => calculateMetadataGasForTxScript,
  calculatePriceWithFactor: () => calculatePriceWithFactor,
  calculateTransactionFee: () => calculateTransactionFee,
  coinQuantityfy: () => coinQuantityfy,
  deferPromise: () => deferPromise,
  dispatchFuelConnectorEvent: () => dispatchFuelConnectorEvent,
  english: () => english,
  extractBurnedAssetsFromReceipts: () => extractBurnedAssetsFromReceipts,
  extractMintedAssetsFromReceipts: () => extractMintedAssetsFromReceipts,
  fromDateToTai64: () => fromDateToTai64,
  fromTai64ToDate: () => fromTai64ToDate,
  fromTai64ToUnix: () => fromTai64ToUnix,
  fromUnixToTai64: () => fromUnixToTai64,
  gasUsedByInputs: () => gasUsedByInputs,
  getContractCallOperations: () => getContractCallOperations,
  getContractCreatedOperations: () => getContractCreatedOperations,
  getContractTransferOperations: () => getContractTransferOperations,
  getDecodedLogs: () => getDecodedLogs,
  getGasUsedFromReceipts: () => getGasUsedFromReceipts,
  getInputAccountAddress: () => getInputAccountAddress,
  getInputContractFromIndex: () => getInputContractFromIndex,
  getInputFromAssetId: () => getInputFromAssetId,
  getInputsByType: () => getInputsByType,
  getInputsByTypes: () => getInputsByTypes,
  getInputsCoin: () => getInputsCoin,
  getInputsCoinAndMessage: () => getInputsCoinAndMessage,
  getInputsContract: () => getInputsContract,
  getInputsMessage: () => getInputsMessage,
  getMaxGas: () => getMaxGas,
  getMinGas: () => getMinGas,
  getOperations: () => getOperations,
  getOutputsByType: () => getOutputsByType,
  getOutputsChange: () => getOutputsChange,
  getOutputsCoin: () => getOutputsCoin,
  getOutputsContract: () => getOutputsContract,
  getOutputsContractCreated: () => getOutputsContractCreated,
  getOutputsVariable: () => getOutputsVariable,
  getPayProducerOperations: () => getPayProducerOperations,
  getPredicateRoot: () => getPredicateRoot,
  getReceiptsByType: () => getReceiptsByType,
  getReceiptsCall: () => getReceiptsCall,
  getReceiptsMessageOut: () => getReceiptsMessageOut,
  getReceiptsTransferOut: () => getReceiptsTransferOut,
  getReceiptsWithMissingData: () => getReceiptsWithMissingData,
  getTransactionStatusName: () => getTransactionStatusName,
  getTransactionSummary: () => getTransactionSummary,
  getTransactionSummaryFromRequest: () => getTransactionSummaryFromRequest,
  getTransactionTypeName: () => getTransactionTypeName,
  getTransactionsSummaries: () => getTransactionsSummaries,
  getTransferOperations: () => getTransferOperations,
  getWithdrawFromFuelOperations: () => getWithdrawFromFuelOperations,
  hasSameAssetId: () => hasSameAssetId,
  inputify: () => inputify,
  isCoin: () => isCoin,
  isMessage: () => isMessage,
  isRawCoin: () => isRawCoin,
  isRawMessage: () => isRawMessage,
  isType: () => isType,
  isTypeCreate: () => isTypeCreate,
  isTypeMint: () => isTypeMint,
  isTypeScript: () => isTypeScript,
  normalizeJSON: () => normalizeJSON,
  outputify: () => outputify,
  processGqlReceipt: () => processGqlReceipt,
  processGraphqlStatus: () => processGraphqlStatus,
  resolveGasDependentCosts: () => resolveGasDependentCosts,
  returnZeroScript: () => returnZeroScript,
  sleep: () => sleep,
  transactionRequestify: () => transactionRequestify,
  withTimeout: () => withTimeout,
  withdrawScript: () => withdrawScript
});
module.exports = __toCommonJS(src_exports);

// src/account.ts
var import_address4 = require("@fuel-ts/address");
var import_configs10 = require("@fuel-ts/address/configs");
var import_errors15 = require("@fuel-ts/errors");
var import_interfaces = require("@fuel-ts/interfaces");
var import_math17 = require("@fuel-ts/math");
var import_ethers21 = require("ethers");

// src/providers/coin-quantity.ts
var import_configs = require("@fuel-ts/address/configs");
var import_math = require("@fuel-ts/math");
var import_ethers = require("ethers");
var coinQuantityfy = (coinQuantityLike) => {
  let assetId;
  let amount;
  let max2;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1] ?? import_configs.BaseAssetId;
    max2 = coinQuantityLike[2] ?? void 0;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId ?? import_configs.BaseAssetId;
    max2 = coinQuantityLike.max ?? void 0;
  }
  const bnAmount = (0, import_math.bn)(amount);
  return {
    assetId: (0, import_ethers.hexlify)(assetId),
    amount: bnAmount.lt(1) ? (0, import_math.bn)(1) : bnAmount,
    max: max2 ? (0, import_math.bn)(max2) : void 0
  };
};
var addAmountToAsset = (params) => {
  const { amount, assetId } = params;
  const coinQuantities = [...params.coinQuantities];
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
};

// src/providers/provider.ts
var import_address3 = require("@fuel-ts/address");
var import_errors13 = require("@fuel-ts/errors");
var import_math14 = require("@fuel-ts/math");
var import_transactions17 = require("@fuel-ts/transactions");
var import_versions = require("@fuel-ts/versions");
var import_ethers18 = require("ethers");
var import_graphql_request = require("graphql-request");
var import_ramda3 = require("ramda");

// src/providers/__generated__/operations.ts
var import_graphql_tag = __toESM(require("graphql-tag"));
var ReceiptFragmentFragmentDoc = import_graphql_tag.default`
    fragment receiptFragment on Receipt {
  contract {
    id
  }
  pc
  is
  to {
    id
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var TransactionStatusFragmentFragmentDoc = import_graphql_tag.default`
    fragment transactionStatusFragment on TransactionStatus {
  type: __typename
  ... on SubmittedStatus {
    time
  }
  ... on SuccessStatus {
    block {
      id
    }
    time
    programState {
      returnType
      data
    }
  }
  ... on FailureStatus {
    block {
      id
    }
    time
    reason
  }
}
    `;
var TransactionFragmentFragmentDoc = import_graphql_tag.default`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    ...transactionStatusFragment
  }
}
    ${ReceiptFragmentFragmentDoc}
${TransactionStatusFragmentFragmentDoc}`;
var InputEstimatePredicatesFragmentFragmentDoc = import_graphql_tag.default`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
var TransactionEstimatePredicatesFragmentFragmentDoc = import_graphql_tag.default`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentFragmentDoc}`;
var CoinFragmentFragmentDoc = import_graphql_tag.default`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentFragmentDoc = import_graphql_tag.default`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentFragmentDoc = import_graphql_tag.default`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
var MessageProofFragmentFragmentDoc = import_graphql_tag.default`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
var BalanceFragmentFragmentDoc = import_graphql_tag.default`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
var BlockFragmentFragmentDoc = import_graphql_tag.default`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
var TxParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment TxParametersFragment on TxParameters {
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
}
    `;
var PredicateParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment PredicateParametersFragment on PredicateParameters {
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
var ScriptParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment ScriptParametersFragment on ScriptParameters {
  maxScriptLength
  maxScriptDataLength
}
    `;
var ContractParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment ContractParametersFragment on ContractParameters {
  contractMaxSize
  maxStorageSlots
}
    `;
var FeeParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment FeeParametersFragment on FeeParameters {
  gasPriceFactor
  gasPerByte
}
    `;
var DependentCostFragmentFragmentDoc = import_graphql_tag.default`
    fragment DependentCostFragment on DependentCost {
  __typename
  ... on LightOperation {
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    base
    gasPerUnit
  }
}
    `;
var GasCostsFragmentFragmentDoc = import_graphql_tag.default`
    fragment GasCostsFragment on GasCosts {
  add
  addi
  aloc
  and
  andi
  bal
  bhei
  bhsh
  burn
  cb
  cfei
  cfsi
  croo
  div
  divi
  ecr1
  eck1
  ed19
  eq
  exp
  expi
  flag
  gm
  gt
  gtf
  ji
  jmp
  jne
  jnei
  jnzi
  jmpf
  jmpb
  jnzf
  jnzb
  jnef
  jneb
  lb
  log
  lt
  lw
  mint
  mlog
  modOp
  modi
  moveOp
  movi
  mroo
  mul
  muli
  mldv
  noop
  not
  or
  ori
  poph
  popl
  pshh
  pshl
  ret
  rvrt
  sb
  sll
  slli
  srl
  srli
  srw
  sub
  subi
  sw
  sww
  time
  tr
  tro
  wdcm
  wqcm
  wdop
  wqop
  wdml
  wqml
  wddv
  wqdv
  wdmd
  wqmd
  wdam
  wqam
  wdmm
  wqmm
  xor
  xori
  call {
    ...DependentCostFragment
  }
  ccp {
    ...DependentCostFragment
  }
  csiz {
    ...DependentCostFragment
  }
  k256 {
    ...DependentCostFragment
  }
  ldc {
    ...DependentCostFragment
  }
  logd {
    ...DependentCostFragment
  }
  mcl {
    ...DependentCostFragment
  }
  mcli {
    ...DependentCostFragment
  }
  mcp {
    ...DependentCostFragment
  }
  mcpi {
    ...DependentCostFragment
  }
  meq {
    ...DependentCostFragment
  }
  retd {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  scwq {
    ...DependentCostFragment
  }
  smo {
    ...DependentCostFragment
  }
  srwq {
    ...DependentCostFragment
  }
  swwq {
    ...DependentCostFragment
  }
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  newStoragePerByte
}
    ${DependentCostFragmentFragmentDoc}`;
var ConsensusParametersFragmentFragmentDoc = import_graphql_tag.default`
    fragment consensusParametersFragment on ConsensusParameters {
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentFragmentDoc}
${PredicateParametersFragmentFragmentDoc}
${ScriptParametersFragmentFragmentDoc}
${ContractParametersFragmentFragmentDoc}
${FeeParametersFragmentFragmentDoc}
${GasCostsFragmentFragmentDoc}`;
var ChainInfoFragmentFragmentDoc = import_graphql_tag.default`
    fragment chainInfoFragment on ChainInfo {
  name
  latestBlock {
    ...blockFragment
  }
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${BlockFragmentFragmentDoc}
${ConsensusParametersFragmentFragmentDoc}`;
var ContractBalanceFragmentFragmentDoc = import_graphql_tag.default`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentFragmentDoc = import_graphql_tag.default`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentFragmentDoc = import_graphql_tag.default`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
  peers {
    id
    addresses
    clientVersion
    blockHeight
    lastHeartbeatMs
    appScore
  }
}
    `;
var GetVersionDocument = import_graphql_tag.default`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = import_graphql_tag.default`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc}`;
var GetChainDocument = import_graphql_tag.default`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc}`;
var GetTransactionDocument = import_graphql_tag.default`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionWithReceiptsDocument = import_graphql_tag.default`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc}
${ReceiptFragmentFragmentDoc}`;
var GetTransactionsDocument = import_graphql_tag.default`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionsByOwnerDocument = import_graphql_tag.default`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var EstimatePredicatesDocument = import_graphql_tag.default`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentFragmentDoc}`;
var GetBlockDocument = import_graphql_tag.default`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetBlockWithTransactionsDocument = import_graphql_tag.default`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var GetBlocksDocument = import_graphql_tag.default`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetCoinDocument = import_graphql_tag.default`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsDocument = import_graphql_tag.default`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsToSpendDocument = import_graphql_tag.default`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc}
${MessageCoinFragmentFragmentDoc}`;
var GetContractDocument = import_graphql_tag.default`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = import_graphql_tag.default`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc}`;
var GetBalanceDocument = import_graphql_tag.default`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetBalancesDocument = import_graphql_tag.default`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetMessagesDocument = import_graphql_tag.default`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc}`;
var GetMessageProofDocument = import_graphql_tag.default`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc}`;
var GetMessageStatusDocument = import_graphql_tag.default`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var DryRunDocument = import_graphql_tag.default`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc}`;
var SubmitDocument = import_graphql_tag.default`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = import_graphql_tag.default`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var SubmitAndAwaitDocument = import_graphql_tag.default`
    subscription submitAndAwait($encodedTransaction: HexString!) {
  submitAndAwait(tx: $encodedTransaction) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
var StatusChangeDocument = import_graphql_tag.default`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
function getSdk(requester) {
  return {
    getVersion(variables, options) {
      return requester(GetVersionDocument, variables, options);
    },
    getNodeInfo(variables, options) {
      return requester(GetNodeInfoDocument, variables, options);
    },
    getChain(variables, options) {
      return requester(GetChainDocument, variables, options);
    },
    getTransaction(variables, options) {
      return requester(GetTransactionDocument, variables, options);
    },
    getTransactionWithReceipts(variables, options) {
      return requester(GetTransactionWithReceiptsDocument, variables, options);
    },
    getTransactions(variables, options) {
      return requester(GetTransactionsDocument, variables, options);
    },
    getTransactionsByOwner(variables, options) {
      return requester(GetTransactionsByOwnerDocument, variables, options);
    },
    estimatePredicates(variables, options) {
      return requester(EstimatePredicatesDocument, variables, options);
    },
    getBlock(variables, options) {
      return requester(GetBlockDocument, variables, options);
    },
    getBlockWithTransactions(variables, options) {
      return requester(GetBlockWithTransactionsDocument, variables, options);
    },
    getBlocks(variables, options) {
      return requester(GetBlocksDocument, variables, options);
    },
    getCoin(variables, options) {
      return requester(GetCoinDocument, variables, options);
    },
    getCoins(variables, options) {
      return requester(GetCoinsDocument, variables, options);
    },
    getCoinsToSpend(variables, options) {
      return requester(GetCoinsToSpendDocument, variables, options);
    },
    getContract(variables, options) {
      return requester(GetContractDocument, variables, options);
    },
    getContractBalance(variables, options) {
      return requester(GetContractBalanceDocument, variables, options);
    },
    getBalance(variables, options) {
      return requester(GetBalanceDocument, variables, options);
    },
    getBalances(variables, options) {
      return requester(GetBalancesDocument, variables, options);
    },
    getMessages(variables, options) {
      return requester(GetMessagesDocument, variables, options);
    },
    getMessageProof(variables, options) {
      return requester(GetMessageProofDocument, variables, options);
    },
    getMessageStatus(variables, options) {
      return requester(GetMessageStatusDocument, variables, options);
    },
    dryRun(variables, options) {
      return requester(DryRunDocument, variables, options);
    },
    submit(variables, options) {
      return requester(SubmitDocument, variables, options);
    },
    produceBlocks(variables, options) {
      return requester(ProduceBlocksDocument, variables, options);
    },
    submitAndAwait(variables, options) {
      return requester(SubmitAndAwaitDocument, variables, options);
    },
    statusChange(variables, options) {
      return requester(StatusChangeDocument, variables, options);
    }
  };
}

// src/providers/fuel-graphql-subscriber.ts
var import_errors = require("@fuel-ts/errors");
var import_graphql = require("graphql");
var _FuelSubscriptionStream = class {
  readable;
  writable;
  readableStreamController;
  constructor() {
    this.readable = new ReadableStream({
      start: (controller) => {
        this.readableStreamController = controller;
      }
    });
    this.writable = new WritableStream({
      write: (bytes) => {
        const text = _FuelSubscriptionStream.textDecoder.decode(bytes);
        if (text.startsWith("data:")) {
          const { data, errors } = JSON.parse(text.split("data:")[1]);
          if (Array.isArray(errors)) {
            this.readableStreamController.enqueue(
              new import_errors.FuelError(
                import_errors.FuelError.CODES.INVALID_REQUEST,
                errors.map((err) => err.message).join("\n\n")
              )
            );
          } else {
            this.readableStreamController.enqueue(data);
          }
        }
      }
    });
  }
};
var FuelSubscriptionStream = _FuelSubscriptionStream;
__publicField(FuelSubscriptionStream, "textDecoder", new TextDecoder());
async function* fuelGraphQLSubscriber({
  url,
  variables,
  query,
  fetchFn
}) {
  const response = await fetchFn(`${url}-sub`, {
    method: "POST",
    body: JSON.stringify({
      query: (0, import_graphql.print)(query),
      variables
    }),
    headers: {
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    }
  });
  const subscriptionStreamReader = response.body.pipeThrough(new FuelSubscriptionStream()).getReader();
  while (true) {
    const { value, done } = await subscriptionStreamReader.read();
    if (value instanceof import_errors.FuelError) {
      throw value;
    }
    yield value;
    if (done) {
      break;
    }
  }
}

// src/providers/memory-cache.ts
var import_errors2 = require("@fuel-ts/errors");
var import_ethers2 = require("ethers");
var cache = {};
var DEFAULT_TTL_IN_MS = 30 * 1e3;
var MemoryCache = class {
  ttl;
  constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
    this.ttl = ttlInMs;
    if (typeof ttlInMs !== "number" || this.ttl <= 0) {
      throw new import_errors2.FuelError(
        import_errors2.ErrorCode.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
    }
  }
  get(value, isAutoExpiring = true) {
    const key = (0, import_ethers2.hexlify)(value);
    if (cache[key]) {
      if (!isAutoExpiring || cache[key].expires > Date.now()) {
        return cache[key].value;
      }
      this.del(value);
    }
    return void 0;
  }
  set(value) {
    const expiresAt = Date.now() + this.ttl;
    const key = (0, import_ethers2.hexlify)(value);
    cache[key] = {
      expires: expiresAt,
      value
    };
    return expiresAt;
  }
  getAllData() {
    return Object.keys(cache).reduce((list, key) => {
      const data = this.get(key, false);
      if (data) {
        list.push(data);
      }
      return list;
    }, []);
  }
  getActiveData() {
    return Object.keys(cache).reduce((list, key) => {
      const data = this.get(key);
      if (data) {
        list.push(data);
      }
      return list;
    }, []);
  }
  del(value) {
    const key = (0, import_ethers2.hexlify)(value);
    delete cache[key];
  }
};

// src/providers/transaction-request/input.ts
var import_configs2 = require("@fuel-ts/address/configs");
var import_errors3 = require("@fuel-ts/errors");
var import_math2 = require("@fuel-ts/math");
var import_transactions = require("@fuel-ts/transactions");
var import_ethers3 = require("ethers");
var inputify = (value) => {
  const { type } = value;
  switch (value.type) {
    case import_transactions.InputType.Coin: {
      const predicate = (0, import_ethers3.getBytesCopy)(value.predicate ?? "0x");
      const predicateData = (0, import_ethers3.getBytesCopy)(value.predicateData ?? "0x");
      return {
        type: import_transactions.InputType.Coin,
        txID: (0, import_ethers3.hexlify)((0, import_ethers3.getBytesCopy)(value.id).slice(0, 32)),
        outputIndex: (0, import_ethers3.getBytesCopy)(value.id)[32],
        owner: (0, import_ethers3.hexlify)(value.owner),
        amount: (0, import_math2.bn)(value.amount),
        assetId: (0, import_ethers3.hexlify)(value.assetId),
        txPointer: {
          blockHeight: (0, import_math2.toNumber)((0, import_ethers3.getBytesCopy)(value.txPointer).slice(0, 8)),
          txIndex: (0, import_math2.toNumber)((0, import_ethers3.getBytesCopy)(value.txPointer).slice(8, 16))
        },
        witnessIndex: value.witnessIndex,
        maturity: value.maturity ?? 0,
        predicateGasUsed: (0, import_math2.bn)(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: (0, import_ethers3.hexlify)(predicate),
        predicateData: (0, import_ethers3.hexlify)(predicateData)
      };
    }
    case import_transactions.InputType.Contract: {
      return {
        type: import_transactions.InputType.Contract,
        txID: import_configs2.ZeroBytes32,
        outputIndex: 0,
        balanceRoot: import_configs2.ZeroBytes32,
        stateRoot: import_configs2.ZeroBytes32,
        txPointer: {
          blockHeight: (0, import_math2.toNumber)((0, import_ethers3.getBytesCopy)(value.txPointer).slice(0, 8)),
          txIndex: (0, import_math2.toNumber)((0, import_ethers3.getBytesCopy)(value.txPointer).slice(8, 16))
        },
        contractID: (0, import_ethers3.hexlify)(value.contractId)
      };
    }
    case import_transactions.InputType.Message: {
      const predicate = (0, import_ethers3.getBytesCopy)(value.predicate ?? "0x");
      const predicateData = (0, import_ethers3.getBytesCopy)(value.predicateData ?? "0x");
      const data = (0, import_ethers3.getBytesCopy)(value.data ?? "0x");
      return {
        type: import_transactions.InputType.Message,
        sender: (0, import_ethers3.hexlify)(value.sender),
        recipient: (0, import_ethers3.hexlify)(value.recipient),
        amount: (0, import_math2.bn)(value.amount),
        nonce: (0, import_ethers3.hexlify)(value.nonce),
        witnessIndex: value.witnessIndex,
        predicateGasUsed: (0, import_math2.bn)(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: (0, import_ethers3.hexlify)(predicate),
        predicateData: (0, import_ethers3.hexlify)(predicateData),
        data: (0, import_ethers3.hexlify)(data),
        dataLength: data.length
      };
    }
    default: {
      throw new import_errors3.FuelError(
        import_errors3.ErrorCode.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/output.ts
var import_configs3 = require("@fuel-ts/address/configs");
var import_errors4 = require("@fuel-ts/errors");
var import_math3 = require("@fuel-ts/math");
var import_transactions2 = require("@fuel-ts/transactions");
var import_ethers4 = require("ethers");
var outputify = (value) => {
  const { type } = value;
  switch (type) {
    case import_transactions2.OutputType.Coin: {
      return {
        type: import_transactions2.OutputType.Coin,
        to: (0, import_ethers4.hexlify)(value.to),
        amount: (0, import_math3.bn)(value.amount),
        assetId: (0, import_ethers4.hexlify)(value.assetId)
      };
    }
    case import_transactions2.OutputType.Contract: {
      return {
        type: import_transactions2.OutputType.Contract,
        inputIndex: value.inputIndex,
        balanceRoot: import_configs3.ZeroBytes32,
        stateRoot: import_configs3.ZeroBytes32
      };
    }
    case import_transactions2.OutputType.Change: {
      return {
        type: import_transactions2.OutputType.Change,
        to: (0, import_ethers4.hexlify)(value.to),
        amount: (0, import_math3.bn)(0),
        assetId: (0, import_ethers4.hexlify)(value.assetId)
      };
    }
    case import_transactions2.OutputType.Variable: {
      return {
        type: import_transactions2.OutputType.Variable,
        to: import_configs3.ZeroBytes32,
        amount: (0, import_math3.bn)(0),
        assetId: import_configs3.ZeroBytes32
      };
    }
    case import_transactions2.OutputType.ContractCreated: {
      return {
        type: import_transactions2.OutputType.ContractCreated,
        contractId: (0, import_ethers4.hexlify)(value.contractId),
        stateRoot: (0, import_ethers4.hexlify)(value.stateRoot)
      };
    }
    default: {
      throw new import_errors4.FuelError(
        import_errors4.ErrorCode.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/transaction-request.ts
var import_address = require("@fuel-ts/address");
var import_configs6 = require("@fuel-ts/address/configs");
var import_math6 = require("@fuel-ts/math");
var import_transactions5 = require("@fuel-ts/transactions");
var import_ethers9 = require("ethers");

// src/providers/resource.ts
var isRawCoin = (resource) => "utxoId" in resource;
var isRawMessage = (resource) => "recipient" in resource;
var isCoin = (resource) => "id" in resource;
var isMessage = (resource) => "recipient" in resource;

// src/providers/utils/receipts.ts
var import_configs4 = require("@fuel-ts/address/configs");
var import_errors5 = require("@fuel-ts/errors");
var import_math4 = require("@fuel-ts/math");
var import_transactions3 = require("@fuel-ts/transactions");
var import_configs5 = require("@fuel-ts/transactions/configs");
var import_ethers5 = require("ethers");
var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === import_transactions3.ReceiptType.Revert && receipt.val.toString("hex") === import_configs5.FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
var doesReceiptHaveMissingContractId = (receipt) => receipt.type === import_transactions3.ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var getReceiptsWithMissingData = (receipts) => receipts.reduce(
  (memo, receipt) => {
    if (doesReceiptHaveMissingOutputVariables(receipt)) {
      memo.missingOutputVariables.push(receipt);
    }
    if (doesReceiptHaveMissingContractId(receipt)) {
      memo.missingOutputContractIds.push(receipt);
    }
    return memo;
  },
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
);
var hexOrZero = (hex) => hex || import_configs4.ZeroBytes32;
function assembleReceiptByType(receipt) {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL" /* Call */: {
      const callReceipt = {
        type: import_transactions3.ReceiptType.Call,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt?.to?.id),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: (0, import_math4.bn)(receipt.gas),
        param1: (0, import_math4.bn)(receipt.param1),
        param2: (0, import_math4.bn)(receipt.param2),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN" /* Return */: {
      const returnReceipt = {
        type: import_transactions3.ReceiptType.Return,
        id: hexOrZero(receipt.contract?.id),
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA" /* ReturnData */: {
      const returnDataReceipt = {
        type: import_transactions3.ReceiptType.ReturnData,
        id: hexOrZero(receipt.contract?.id),
        ptr: (0, import_math4.bn)(receipt.ptr),
        len: (0, import_math4.bn)(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC" /* Panic */: {
      const panicReceipt = {
        type: import_transactions3.ReceiptType.Panic,
        id: hexOrZero(receipt.contract?.id),
        reason: (0, import_math4.bn)(receipt.reason),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT" /* Revert */: {
      const revertReceipt = {
        type: import_transactions3.ReceiptType.Revert,
        id: hexOrZero(receipt.contract?.id),
        val: (0, import_math4.bn)(receipt.ra),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG" /* Log */: {
      const logReceipt = {
        type: import_transactions3.ReceiptType.Log,
        id: hexOrZero(receipt.contract?.id),
        val0: (0, import_math4.bn)(receipt.ra),
        val1: (0, import_math4.bn)(receipt.rb),
        val2: (0, import_math4.bn)(receipt.rc),
        val3: (0, import_math4.bn)(receipt.rd),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA" /* LogData */: {
      const logDataReceipt = {
        type: import_transactions3.ReceiptType.LogData,
        id: hexOrZero(receipt.contract?.id),
        val0: (0, import_math4.bn)(receipt.ra),
        val1: (0, import_math4.bn)(receipt.rb),
        ptr: (0, import_math4.bn)(receipt.ptr),
        len: (0, import_math4.bn)(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER" /* Transfer */: {
      const transferReceipt = {
        type: import_transactions3.ReceiptType.Transfer,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt?.to?.id),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT" /* TransferOut */: {
      const transferOutReceipt = {
        type: import_transactions3.ReceiptType.TransferOut,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt.to?.id),
        amount: (0, import_math4.bn)(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT" /* ScriptResult */: {
      const scriptResultReceipt = {
        type: import_transactions3.ReceiptType.ScriptResult,
        result: (0, import_math4.bn)(receipt.result),
        gasUsed: (0, import_math4.bn)(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT" /* MessageOut */: {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = (0, import_math4.bn)(receipt.amount);
      const data = receipt.data ? (0, import_ethers5.getBytesCopy)(receipt.data) : Uint8Array.from([]);
      const digest = hexOrZero(receipt.digest);
      const messageId = import_transactions3.ReceiptMessageOutCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data
      });
      const receiptMessageOut = {
        type: import_transactions3.ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        data,
        digest,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT" /* Mint */: {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = import_transactions3.ReceiptMintCoder.getAssetId(contractId, subId);
      const mintReceipt = {
        type: import_transactions3.ReceiptType.Mint,
        subId,
        contractId,
        assetId,
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN" /* Burn */: {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = import_transactions3.ReceiptBurnCoder.getAssetId(contractId, subId);
      const burnReceipt = {
        type: import_transactions3.ReceiptType.Burn,
        subId,
        contractId,
        assetId,
        val: (0, import_math4.bn)(receipt.val),
        pc: (0, import_math4.bn)(receipt.pc),
        is: (0, import_math4.bn)(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new import_errors5.FuelError(import_errors5.ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
}

// src/providers/utils/block-explorer.ts
var import_errors6 = require("@fuel-ts/errors");
var DEFAULT_BLOCK_EXPLORER_URL = "https://fuellabs.github.io/block-explorer-v2";
var getPathFromInput = (key, value) => {
  const pathMap = {
    address: `address`,
    txId: `transaction`,
    blockNumber: `block`
  };
  const path = pathMap[key] || key;
  return `${path}/${value}`;
};
var buildBlockExplorerUrl = (options = {}) => {
  const { blockExplorerUrl, path, providerUrl, address, txId, blockNumber } = options;
  const explorerUrl = blockExplorerUrl || DEFAULT_BLOCK_EXPLORER_URL;
  const customInputParams = [
    {
      key: "address",
      value: address
    },
    {
      key: "txId",
      value: txId
    },
    {
      key: "blockNumber",
      value: blockNumber
    }
  ];
  const definedValues = customInputParams.filter((param) => !!param.value).map(({ key, value }) => ({
    key,
    value
  }));
  const hasAnyDefinedValues = definedValues.length > 0;
  if (definedValues.length > 1) {
    throw new import_errors6.FuelError(
      import_errors6.ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,
      `Only one of the following can be passed in to buildBlockExplorerUrl: ${customInputParams.map((param) => param.key).join(", ")}.`
    );
  }
  if (path && definedValues.length > 0) {
    const inputKeys = customInputParams.map(({ key }) => key).join(", ");
    throw new import_errors6.FuelError(
      import_errors6.ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,
      `You cannot pass in a path to 'buildBlockExplorerUrl' along with any of the following: ${inputKeys}.`
    );
  }
  const pathGeneratedFromInputParams = hasAnyDefinedValues ? getPathFromInput(
    definedValues[0].key,
    definedValues[0].value
  ) : "";
  const trimSlashes = /^\/|\/$/gm;
  const cleanPath = path ? path.replace(trimSlashes, "") : pathGeneratedFromInputParams;
  const cleanBlockExplorerUrl = explorerUrl.replace(trimSlashes, "");
  const cleanProviderUrl = providerUrl?.replace(trimSlashes, "");
  const encodedProviderUrl = cleanProviderUrl ? encodeURIComponent(cleanProviderUrl) : void 0;
  const protocol = cleanBlockExplorerUrl.match(/^https?:\/\//) ? "" : "https://";
  const providerUrlProtocol = cleanProviderUrl?.match(/^https?:\/\//) ? "" : "https://";
  const url = `${protocol}${cleanBlockExplorerUrl}/${cleanPath}${encodedProviderUrl ? `?providerUrl=${providerUrlProtocol}${encodedProviderUrl}` : ""}`;
  return url;
};

// src/providers/utils/gas.ts
var import_math5 = require("@fuel-ts/math");
var import_transactions4 = require("@fuel-ts/transactions");
var import_ethers6 = require("ethers");
var calculatePriceWithFactor = (gas, gasPrice, priceFactor) => (0, import_math5.bn)(Math.ceil(gas.mul(gasPrice).toNumber() / priceFactor.toNumber()));
var getGasUsedFromReceipts = (receipts) => {
  const scriptResult = receipts.filter(
    (receipt) => receipt.type === import_transactions4.ReceiptType.ScriptResult
  );
  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), (0, import_math5.bn)(0));
  return gasUsed;
};
function resolveGasDependentCosts(byteSize, gasDependentCost) {
  const base = (0, import_math5.bn)(gasDependentCost.base);
  let dependentValue = (0, import_math5.bn)(0);
  if (gasDependentCost.__typename === "LightOperation") {
    dependentValue = (0, import_math5.bn)(byteSize).div((0, import_math5.bn)(gasDependentCost.unitsPerGas));
  }
  if (gasDependentCost.__typename === "HeavyOperation") {
    dependentValue = (0, import_math5.bn)(byteSize).mul((0, import_math5.bn)(gasDependentCost.gasPerUnit));
  }
  return base.add(dependentValue);
}
function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
  const witnessCache = [];
  const totalGas = inputs.reduce((total, input) => {
    if ("predicate" in input && input.predicate && input.predicate !== "0x") {
      return total.add(
        resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization).add(
          resolveGasDependentCosts((0, import_ethers6.getBytesCopy)(input.predicate).length, gasCosts.contractRoot)
        ).add((0, import_math5.bn)(input.predicateGasUsed))
      );
    }
    if ("witnessIndex" in input && !witnessCache.includes(input.witnessIndex)) {
      witnessCache.push(input.witnessIndex);
      return total.add(gasCosts.ecr1);
    }
    return total;
  }, (0, import_math5.bn)());
  return totalGas;
}
function getMinGas(params) {
  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const bytesGas = (0, import_math5.bn)(txBytesSize).mul(gasPerByte);
  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
  return minGas;
}
function getMaxGas(params) {
  const { gasPerByte, witnessesLength, witnessLimit, minGas, gasLimit = (0, import_math5.bn)(0) } = params;
  let remainingAllowedWitnessGas = (0, import_math5.bn)(0);
  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
    remainingAllowedWitnessGas = (0, import_math5.bn)(witnessLimit).sub(witnessesLength).mul(gasPerByte);
  }
  return remainingAllowedWitnessGas.add(minGas).add(gasLimit);
}
function calculateMetadataGasForTxCreate({
  gasCosts,
  stateRootSize,
  txBytesSize,
  contractBytesSize
}) {
  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const contractIdInputSize = (0, import_math5.bn)(4 + 32 + 32 + 32);
  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
  return metadataGas.maxU64();
}
function calculateMetadataGasForTxScript({
  gasCosts,
  txBytesSize
}) {
  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
}

// src/providers/utils/json.ts
var import_ethers7 = require("ethers");
var import_ramda = require("ramda");
function normalize(object) {
  Object.keys(object).forEach((key) => {
    switch (object[key]?.constructor.name) {
      case "Uint8Array":
        object[key] = (0, import_ethers7.hexlify)(object[key]);
        break;
      case "Array":
        object[key] = normalize(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize(object[key]);
        break;
      default:
        break;
    }
  });
  return object;
}
function normalizeJSON(root) {
  return normalize((0, import_ramda.clone)(root));
}

// src/providers/utils/sleep.ts
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
}

// src/providers/utils/time.ts
var fromTai64ToUnix = (tai64Timestamp) => Number(BigInt(tai64Timestamp) - BigInt(2 ** 62) - BigInt(10));
var fromUnixToTai64 = (unixTimestampMs) => (BigInt(unixTimestampMs) + BigInt(2 ** 62) + BigInt(10)).toString();

// src/providers/transaction-request/errors.ts
var ChangeOutputCollisionError = class extends Error {
  name = "ChangeOutputCollisionError";
  message = 'A ChangeOutput with the same "assetId" already exists for a different "to" address';
};
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
  name = "NoWitnessAtIndexError";
};
var NoWitnessByOwnerError = class extends Error {
  constructor(owner) {
    super();
    this.owner = owner;
    this.message = `A witness for the given owner "${owner}" was not found`;
  }
  name = "NoWitnessByOwnerError";
};

// src/providers/transaction-request/witness.ts
var import_ethers8 = require("ethers");
var witnessify = (value) => {
  const data = (0, import_ethers8.getBytesCopy)(value);
  return {
    data: (0, import_ethers8.hexlify)(data),
    dataLength: data.length
  };
};

// src/providers/transaction-request/transaction-request.ts
var BaseTransactionRequest = class {
  /** Gas price for transaction */
  gasPrice;
  /** Block until which tx cannot be included */
  maturity;
  /** The maximum fee payable by this transaction using BASE_ASSET. */
  maxFee;
  /** The maximum amount of witness data allowed for the transaction */
  witnessLimit;
  /** List of inputs */
  inputs = [];
  /** List of outputs */
  outputs = [];
  /** List of witnesses */
  witnesses = [];
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    gasPrice,
    maturity,
    maxFee,
    witnessLimit,
    inputs,
    outputs,
    witnesses
  } = {}) {
    this.gasPrice = (0, import_math6.bn)(gasPrice);
    this.maturity = maturity ?? 0;
    this.witnessLimit = witnessLimit ? (0, import_math6.bn)(witnessLimit) : void 0;
    this.maxFee = maxFee ? (0, import_math6.bn)(maxFee) : void 0;
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
  }
  static getPolicyMeta(req) {
    let policyTypes = 0;
    const policies = [];
    if (req.gasPrice) {
      policyTypes += import_transactions5.PolicyType.GasPrice;
      policies.push({ data: req.gasPrice, type: import_transactions5.PolicyType.GasPrice });
    }
    if (req.witnessLimit) {
      policyTypes += import_transactions5.PolicyType.WitnessLimit;
      policies.push({ data: req.witnessLimit, type: import_transactions5.PolicyType.WitnessLimit });
    }
    if (req.maturity > 0) {
      policyTypes += import_transactions5.PolicyType.Maturity;
      policies.push({ data: req.maturity, type: import_transactions5.PolicyType.Maturity });
    }
    if (req.maxFee) {
      policyTypes += import_transactions5.PolicyType.MaxFee;
      policies.push({ data: req.maxFee, type: import_transactions5.PolicyType.MaxFee });
    }
    return {
      policyTypes,
      policies
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    const inputs = this.inputs?.map(inputify) ?? [];
    const outputs = this.outputs?.map(outputify) ?? [];
    const witnesses = this.witnesses?.map(witnessify) ?? [];
    const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
    return {
      policyTypes,
      inputs,
      outputs,
      policies,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new import_transactions5.TransactionCoder().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(output) {
    this.outputs.push(output);
    return this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   */
  createWitness() {
    this.witnesses.push((0, import_ethers9.concat)([import_configs6.ZeroBytes32, import_configs6.ZeroBytes32]));
    return this.witnesses.length - 1;
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(address, signature) {
    const ownerAddress = import_address.Address.fromAddressOrString(address);
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (input) => input.type === import_transactions5.InputType.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions5.OutputType.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions5.OutputType.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = (0, import_address.addressify)(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case import_transactions5.InputType.Coin:
          return (0, import_ethers9.hexlify)(input.owner) === ownerAddress.toB256();
        case import_transactions5.InputType.Message:
          return (0, import_ethers9.hexlify)(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found?.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   * @param predicate - Predicate bytes.
   * @param predicateData - Predicate data bytes.
   */
  addCoinInput(coin, predicate) {
    const { assetId, owner, amount } = coin;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.createWitness();
      }
    }
    const input = {
      ...coin,
      type: import_transactions5.InputType.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * baseAssetId, if one it was not added yet.
   *
   * @param message - Message resource.
   * @param predicate - Predicate bytes.
   * @param predicateData - Predicate data bytes.
   */
  addMessageInput(message, predicate) {
    const { recipient, sender, amount } = message;
    const assetId = import_configs6.BaseAssetId;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.createWitness();
      }
    }
    const input = {
      ...message,
      type: import_transactions5.InputType.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      amount,
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(recipient, assetId);
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addPredicateResource(resource, predicate) {
    if (isCoin(resource)) {
      this.addCoinInput(resource, predicate);
    } else {
      this.addMessageInput(resource, predicate);
    }
    return this;
  }
  /**
   * Adds multiple predicate coin/message inputs to the transaction and change outputs
   * from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addPredicateResources(resources, predicate) {
    resources.forEach((resource) => this.addPredicateResource(resource, predicate));
    return this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(to, amount, assetId = import_configs6.BaseAssetId) {
    this.pushOutput({
      type: import_transactions5.OutputType.Coin,
      to: (0, import_address.addressify)(to).toB256(),
      amount,
      assetId
    });
    return this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(to, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: import_transactions5.OutputType.Coin,
        to: (0, import_address.addressify)(to).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(to, assetId = import_configs6.BaseAssetId) {
    const changeOutput = this.getChangeOutputs().find(
      (output) => (0, import_ethers9.hexlify)(output.assetId) === assetId
    );
    if (!changeOutput) {
      this.pushOutput({
        type: import_transactions5.OutputType.Change,
        to: (0, import_address.addressify)(to).toB256(),
        assetId
      });
    }
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(_gasCosts) {
    throw new Error("Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(chainInfo) {
    const { gasCosts, consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    return getMinGas({
      gasPerByte,
      gasCosts,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(gasCosts)
    });
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   */
  fundWithFakeUtxos(quantities, resourcesOwner) {
    let idCounter = 0;
    const generateId = () => {
      const counterString = String(idCounter++);
      const id = import_configs6.ZeroBytes32.slice(0, -counterString.length).concat(counterString);
      return id;
    };
    const findAssetInput = (assetId) => this.inputs.find((input) => {
      if ("assetId" in input) {
        return input.assetId === assetId;
      }
      return false;
    });
    const updateAssetInput = (assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      if (assetInput && "assetId" in assetInput) {
        assetInput.id = generateId();
        assetInput.amount = quantity;
      } else {
        this.addResources([
          {
            id: generateId(),
            amount: quantity,
            assetId,
            owner: resourcesOwner || import_address.Address.fromRandom(),
            maturity: 0,
            blockCreated: (0, import_math6.bn)(1),
            txCreatedIdx: (0, import_math6.bn)(1)
          }
        ]);
      }
    };
    updateAssetInput(import_configs6.BaseAssetId, (0, import_math6.bn)(1e11));
    quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: (0, import_math6.bn)(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return normalizeJSON(this);
  }
  /**
   * @hidden
   *
   * Determines whether the transaction has a predicate input.
   *
   * @returns Whether the transaction has a predicate input.
   */
  hasPredicateInput() {
    return Boolean(
      this.inputs.find(
        (input) => "predicate" in input && input.predicate && input.predicate !== (0, import_ethers9.getBytesCopy)("0x")
      )
    );
  }
};

// src/providers/transaction-request/create-transaction-request.ts
var import_configs8 = require("@fuel-ts/address/configs");
var import_math8 = require("@fuel-ts/math");
var import_transactions7 = require("@fuel-ts/transactions");
var import_ethers12 = require("ethers");

// src/providers/transaction-request/hash-transaction.ts
var import_configs7 = require("@fuel-ts/address/configs");
var import_hasher = require("@fuel-ts/hasher");
var import_math7 = require("@fuel-ts/math");
var import_transactions6 = require("@fuel-ts/transactions");
var import_ethers10 = require("ethers");
var import_ramda2 = require("ramda");
function hashTransaction(transactionRequest, chainId) {
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === import_transactions6.TransactionType.Script) {
    transaction.receiptsRoot = import_configs7.ZeroBytes32;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = (0, import_ramda2.clone)(input);
    switch (inputClone.type) {
      case import_transactions6.InputType.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = (0, import_math7.bn)(0);
        return inputClone;
      }
      case import_transactions6.InputType.Message: {
        inputClone.predicateGasUsed = (0, import_math7.bn)(0);
        return inputClone;
      }
      case import_transactions6.InputType.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.txID = import_configs7.ZeroBytes32;
        inputClone.outputIndex = 0;
        inputClone.balanceRoot = import_configs7.ZeroBytes32;
        inputClone.stateRoot = import_configs7.ZeroBytes32;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output) => {
    const outputClone = (0, import_ramda2.clone)(output);
    switch (outputClone.type) {
      case import_transactions6.OutputType.Contract: {
        outputClone.balanceRoot = import_configs7.ZeroBytes32;
        outputClone.stateRoot = import_configs7.ZeroBytes32;
        return outputClone;
      }
      case import_transactions6.OutputType.Change: {
        outputClone.amount = (0, import_math7.bn)(0);
        return outputClone;
      }
      case import_transactions6.OutputType.Variable: {
        outputClone.to = import_configs7.ZeroBytes32;
        outputClone.amount = (0, import_math7.bn)(0);
        outputClone.assetId = import_configs7.ZeroBytes32;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = (0, import_hasher.uint64ToBytesBE)(chainId);
  const concatenatedData = (0, import_ethers10.concat)([chainIdBytes, new import_transactions6.TransactionCoder().encode(transaction)]);
  return (0, import_ethers10.sha256)(concatenatedData);
}

// src/providers/transaction-request/storage-slot.ts
var import_ethers11 = require("ethers");
var getStorageValue = (value) => {
  const v = new Uint8Array(32);
  v.set((0, import_ethers11.getBytesCopy)(value));
  return v;
};
var storageSlotify = (storageSlot) => {
  let key;
  let value;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value = storageSlot[1];
  } else {
    key = storageSlot.key;
    value = storageSlot.value;
  }
  return {
    key: (0, import_ethers11.hexlify)(key),
    value: (0, import_ethers11.hexlify)(getStorageValue(value))
  };
};

// src/providers/transaction-request/create-transaction-request.ts
var CreateTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /** Type of the transaction */
  type = import_transactions7.TransactionType.Create;
  /** Witness index of contract bytecode to create */
  bytecodeWitnessIndex;
  /** Salt */
  salt;
  /** List of storage slots to initialize */
  storageSlots;
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({
    bytecodeWitnessIndex,
    salt,
    storageSlots,
    ...rest
  } = {}) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = (0, import_ethers12.hexlify)(salt ?? import_configs8.ZeroBytes32);
    this.storageSlots = [...storageSlots ?? []];
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
    return {
      type: import_transactions7.TransactionType.Create,
      ...baseTransaction,
      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
      bytecodeWitnessIndex,
      storageSlotsCount: storageSlots.length,
      salt: this.salt ? (0, import_ethers12.hexlify)(this.salt) : import_configs8.ZeroBytes32,
      storageSlots
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions7.OutputType.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(contractId, stateRoot) {
    this.pushOutput({
      type: import_transactions7.OutputType.ContractCreated,
      contractId,
      stateRoot
    });
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxCreate({
      contractBytesSize: (0, import_math8.bn)((0, import_ethers12.getBytesCopy)(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/script-transaction-request.ts
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_address2 = require("@fuel-ts/address");
var import_configs9 = require("@fuel-ts/address/configs");
var import_math9 = require("@fuel-ts/math");
var import_transactions8 = require("@fuel-ts/transactions");
var import_ethers14 = require("ethers");

// src/providers/transaction-request/scripts.ts
var import_ethers13 = require("ethers");
var returnZeroScript = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: (0, import_ethers13.getBytesCopy)("0x24000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var withdrawScript = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: (0, import_ethers13.getBytesCopy)("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: () => new Uint8Array(0)
};

// src/providers/transaction-request/script-transaction-request.ts
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /** Type of the transaction */
  type = import_transactions8.TransactionType.Script;
  /** Gas limit for transaction */
  gasLimit;
  /** Script to execute */
  script;
  /** Script input data (parameters) */
  scriptData;
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script, scriptData, gasLimit, ...rest } = {}) {
    super(rest);
    this.gasLimit = (0, import_math9.bn)(gasLimit);
    this.script = (0, import_ethers14.getBytesCopy)(script ?? returnZeroScript.bytes);
    this.scriptData = (0, import_ethers14.getBytesCopy)(scriptData ?? returnZeroScript.encodeScriptData());
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const script = (0, import_ethers14.getBytesCopy)(this.script ?? "0x");
    const scriptData = (0, import_ethers14.getBytesCopy)(this.scriptData ?? "0x");
    return {
      type: import_transactions8.TransactionType.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: script.length,
      scriptDataLength: scriptData.length,
      receiptsRoot: import_configs9.ZeroBytes32,
      script: (0, import_ethers14.hexlify)(script),
      scriptData: (0, import_ethers14.hexlify)(scriptData)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (input) => input.type === import_transactions8.InputType.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions8.OutputType.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (output) => output.type === import_transactions8.OutputType.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(script, data) {
    this.scriptData = script.encodeScriptData(data);
    this.script = script.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: import_transactions8.OutputType.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(contract) {
    const contractAddress = (0, import_address2.addressify)(contract);
    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: import_transactions8.InputType.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: import_transactions8.OutputType.Contract,
      inputIndex
    });
    return this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(abi, args) {
    const abiInterface = new import_abi_coder.Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/utils.ts
var import_errors8 = require("@fuel-ts/errors");
var import_transactions9 = require("@fuel-ts/transactions");
var transactionRequestify = (obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
    return obj;
  }
  const { type } = obj;
  switch (obj.type) {
    case import_transactions9.TransactionType.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case import_transactions9.TransactionType.Create: {
      return CreateTransactionRequest.from(obj);
    }
    default: {
      throw new import_errors8.FuelError(import_errors8.ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}.`);
    }
  }
};

// src/providers/transaction-response/transaction-response.ts
var import_errors12 = require("@fuel-ts/errors");
var import_math13 = require("@fuel-ts/math");
var import_transactions15 = require("@fuel-ts/transactions");
var import_ethers17 = require("ethers");

// src/providers/transaction-summary/assemble-transaction-summary.ts
var import_ethers16 = require("ethers");

// src/providers/transaction-summary/calculate-transaction-fee.ts
var import_math10 = require("@fuel-ts/math");
var import_transactions10 = require("@fuel-ts/transactions");
var import_ethers15 = require("ethers");
var calculateTransactionFee = (params) => {
  const {
    gasUsed,
    rawPayload,
    consensusParameters: { gasCosts, feeParams }
  } = params;
  const gasPerByte = (0, import_math10.bn)(feeParams.gasPerByte);
  const gasPriceFactor = (0, import_math10.bn)(feeParams.gasPriceFactor);
  const transactionBytes = (0, import_ethers15.getBytesCopy)(rawPayload);
  const [transaction] = new import_transactions10.TransactionCoder().decode(transactionBytes, 0);
  if (transaction.type === import_transactions10.TransactionType.Mint) {
    return {
      fee: (0, import_math10.bn)(0),
      minFee: (0, import_math10.bn)(0),
      maxFee: (0, import_math10.bn)(0),
      feeFromGasUsed: (0, import_math10.bn)(0)
    };
  }
  const { type, witnesses, inputs, policies } = transaction;
  let metadataGas = (0, import_math10.bn)(0);
  let gasLimit = (0, import_math10.bn)(0);
  if (type === import_transactions10.TransactionType.Create) {
    const { bytecodeWitnessIndex, storageSlots } = transaction;
    const contractBytesSize = (0, import_math10.bn)((0, import_ethers15.getBytesCopy)(witnesses[bytecodeWitnessIndex].data).length);
    metadataGas = calculateMetadataGasForTxCreate({
      contractBytesSize,
      gasCosts,
      stateRootSize: storageSlots.length || 0,
      txBytesSize: transactionBytes.length
    });
  } else {
    const { scriptGasLimit } = transaction;
    if (scriptGasLimit) {
      gasLimit = scriptGasLimit;
    }
    metadataGas = calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: transactionBytes.length
    });
  }
  const minGas = getMinGas({
    gasCosts,
    gasPerByte: (0, import_math10.bn)(gasPerByte),
    inputs,
    metadataGas,
    txBytesSize: transactionBytes.length
  });
  const gasPrice = (0, import_math10.bn)(policies.find((policy) => policy.type === import_transactions10.PolicyType.GasPrice)?.data);
  const witnessLimit = policies.find((policy) => policy.type === import_transactions10.PolicyType.WitnessLimit)?.data;
  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
  const maxGas = getMaxGas({
    gasPerByte,
    minGas,
    witnessesLength,
    gasLimit,
    witnessLimit
  });
  const feeFromGasUsed = calculatePriceWithFactor(gasUsed, gasPrice, gasPriceFactor);
  const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor);
  const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor);
  const fee = minFee.add(feeFromGasUsed);
  return {
    fee,
    minFee,
    maxFee,
    feeFromGasUsed
  };
};

// src/providers/transaction-summary/date.ts
var import_tai64 = require("tai64");
var fromTai64ToDate = (tai64Timestamp) => {
  const timestamp = import_tai64.TAI64.fromString(tai64Timestamp, 10).toUnix();
  return new Date(timestamp * 1e3);
};
var fromDateToTai64 = (date) => import_tai64.TAI64.fromUnix(Math.floor(date.getTime() / 1e3)).toString(10);

// src/providers/transaction-summary/operations.ts
var import_errors10 = require("@fuel-ts/errors");
var import_math12 = require("@fuel-ts/math");
var import_transactions13 = require("@fuel-ts/transactions");

// src/providers/transaction-summary/call.ts
var import_abi_coder2 = require("@fuel-ts/abi-coder");
var import_math11 = require("@fuel-ts/math");
var getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }) => {
  const abiInterface = new import_abi_coder2.Interface(abi);
  const callFunctionSelector = receipt.param1.toHex(8);
  const functionFragment = abiInterface.getFunction(callFunctionSelector);
  const inputs = functionFragment.jsonFn.inputs;
  let encodedArgs;
  if (functionFragment.isInputDataPointer) {
    if (rawPayload) {
      const argsOffset = (0, import_math11.bn)(receipt.param2).sub((0, import_abi_coder2.calculateVmTxMemory)({ maxInputs: maxInputs.toNumber() })).toNumber();
      encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
    }
  } else {
    encodedArgs = receipt.param2.toHex();
  }
  let argumentsProvided;
  if (encodedArgs) {
    const data = functionFragment.decodeArguments(encodedArgs);
    if (data) {
      argumentsProvided = inputs.reduce((prev, input, index) => {
        const value = data[index];
        const name = input.name;
        if (name) {
          return {
            ...prev,
            // reparse to remove bn
            [name]: JSON.parse(JSON.stringify(value))
          };
        }
        return prev;
      }, {});
    }
  }
  const call = {
    functionSignature: functionFragment.signature,
    functionName: functionFragment.name,
    argumentsProvided,
    ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
  };
  return call;
};

// src/providers/transaction-summary/input.ts
var import_errors9 = require("@fuel-ts/errors");
var import_transactions11 = require("@fuel-ts/transactions");
function getInputsByTypes(inputs, types) {
  return inputs.filter((i) => types.includes(i.type));
}
function getInputsByType(inputs, type) {
  return inputs.filter((i) => i.type === type);
}
function getInputsCoin(inputs) {
  return getInputsByType(inputs, import_transactions11.InputType.Coin);
}
function getInputsMessage(inputs) {
  return getInputsByType(inputs, import_transactions11.InputType.Message);
}
function getInputsCoinAndMessage(inputs) {
  return getInputsByTypes(inputs, [import_transactions11.InputType.Coin, import_transactions11.InputType.Message]);
}
function getInputsContract(inputs) {
  return getInputsByType(inputs, import_transactions11.InputType.Contract);
}
function getInputFromAssetId(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  const messageInputs = getInputsMessage(inputs);
  const coinInput = coinInputs.find((i) => i.assetId === assetId);
  const messageInput = messageInputs.find(
    (_) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
  );
  return coinInput || messageInput;
}
function getInputContractFromIndex(inputs, inputIndex) {
  if (inputIndex == null) {
    return void 0;
  }
  const contractInput = inputs?.[inputIndex];
  if (!contractInput) {
    return void 0;
  }
  if (contractInput.type !== import_transactions11.InputType.Contract) {
    throw new import_errors9.FuelError(
      import_errors9.ErrorCode.INVALID_TRANSACTION_INPUT,
      `Contract input should be of type 'contract'.`
    );
  }
  return contractInput;
}
function getInputAccountAddress(input) {
  if (input.type === import_transactions11.InputType.Coin) {
    return input.owner.toString();
  }
  if (input.type === import_transactions11.InputType.Message) {
    return input.recipient.toString();
  }
  return "";
}

// src/providers/transaction-summary/output.ts
var import_transactions12 = require("@fuel-ts/transactions");
function getOutputsByType(outputs, type) {
  return outputs.filter((o) => o.type === type);
}
function getOutputsContractCreated(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.ContractCreated);
}
function getOutputsCoin(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Coin);
}
function getOutputsChange(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Change);
}
function getOutputsContract(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Contract);
}
function getOutputsVariable(outputs) {
  return getOutputsByType(outputs, import_transactions12.OutputType.Variable);
}

// src/providers/transaction-summary/types.ts
var TransactionTypeName = /* @__PURE__ */ ((TransactionTypeName2) => {
  TransactionTypeName2["Create"] = "Create";
  TransactionTypeName2["Mint"] = "Mint";
  TransactionTypeName2["Script"] = "Script";
  return TransactionTypeName2;
})(TransactionTypeName || {});
var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
  TransactionStatus2["submitted"] = "submitted";
  TransactionStatus2["success"] = "success";
  TransactionStatus2["squeezedout"] = "squeezedout";
  TransactionStatus2["failure"] = "failure";
  return TransactionStatus2;
})(TransactionStatus || {});
var OperationName = /* @__PURE__ */ ((OperationName2) => {
  OperationName2["payBlockProducer"] = "Pay network fee to block producer";
  OperationName2["contractCreated"] = "Contract created";
  OperationName2["transfer"] = "Transfer asset";
  OperationName2["contractCall"] = "Contract call";
  OperationName2["contractTransfer"] = "Contract transfer";
  OperationName2["receive"] = "Receive asset";
  OperationName2["mint"] = "Mint asset";
  OperationName2["predicatecall"] = "Predicate call";
  OperationName2["script"] = "Script";
  OperationName2["sent"] = "Sent asset";
  OperationName2["withdrawFromFuel"] = "Withdraw from Fuel";
  return OperationName2;
})(OperationName || {});
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2[AddressType2["contract"] = 0] = "contract";
  AddressType2[AddressType2["account"] = 1] = "account";
  return AddressType2;
})(AddressType || {});
var ChainName = /* @__PURE__ */ ((ChainName2) => {
  ChainName2["ethereum"] = "ethereum";
  ChainName2["fuel"] = "fuel";
  return ChainName2;
})(ChainName || {});

// src/providers/transaction-summary/operations.ts
function getReceiptsByType(receipts, type) {
  return (receipts ?? []).filter((r) => r.type === type);
}
function getTransactionTypeName(transactionType) {
  switch (transactionType) {
    case import_transactions13.TransactionType.Mint:
      return "Mint" /* Mint */;
    case import_transactions13.TransactionType.Create:
      return "Create" /* Create */;
    case import_transactions13.TransactionType.Script:
      return "Script" /* Script */;
    default:
      throw new import_errors10.FuelError(
        import_errors10.ErrorCode.INVALID_TRANSACTION_TYPE,
        `Invalid transaction type: ${transactionType}.`
      );
  }
}
function isType(transactionType, type) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type;
}
function isTypeMint(transactionType) {
  return isType(transactionType, "Mint" /* Mint */);
}
function isTypeCreate(transactionType) {
  return isType(transactionType, "Create" /* Create */);
}
function isTypeScript(transactionType) {
  return isType(transactionType, "Script" /* Script */);
}
function hasSameAssetId(a) {
  return (b) => a.assetId === b.assetId;
}
function getReceiptsCall(receipts) {
  return getReceiptsByType(receipts, import_transactions13.ReceiptType.Call);
}
function getReceiptsMessageOut(receipts) {
  return getReceiptsByType(receipts, import_transactions13.ReceiptType.MessageOut);
}
var mergeAssets = (op1, op2) => {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const filteredAssets = assets2.filter(
    (asset2) => !assets1.some((asset1) => asset1.assetId === asset2.assetId)
  );
  const mergedAssets = assets1.map((asset1) => {
    const matchingAsset = assets2.find((asset2) => asset2.assetId === asset1.assetId);
    if (!matchingAsset) {
      return asset1;
    }
    const mergedAmount = (0, import_math12.bn)(asset1.amount).add(matchingAsset.amount);
    return { ...asset1, amount: mergedAmount };
  });
  return mergedAssets.concat(filteredAssets);
};
function isSameOperation(a, b) {
  return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
}
function addOperation(operations, toAdd) {
  const allOperations = [...operations];
  const index = allOperations.findIndex((op) => isSameOperation(op, toAdd));
  if (allOperations[index]) {
    const existentOperation = { ...allOperations[index] };
    if (toAdd.assetsSent?.length) {
      existentOperation.assetsSent = existentOperation.assetsSent?.length ? mergeAssets(existentOperation, toAdd) : toAdd.assetsSent;
    }
    if (toAdd.calls?.length) {
      existentOperation.calls = [...existentOperation.calls || [], ...toAdd.calls];
    }
    allOperations[index] = existentOperation;
  } else {
    allOperations.push(toAdd);
  }
  return allOperations;
}
function getReceiptsTransferOut(receipts) {
  return getReceiptsByType(receipts, import_transactions13.ReceiptType.TransferOut);
}
function getContractTransferOperations({ receipts }) {
  const transferOutReceipts = getReceiptsTransferOut(receipts);
  const contractTransferOperations = transferOutReceipts.reduce(
    (prevContractTransferOps, receipt) => {
      const newContractTransferOps = addOperation(prevContractTransferOps, {
        name: "Contract transfer" /* contractTransfer */,
        from: {
          type: 0 /* contract */,
          address: receipt.from
        },
        to: {
          type: 1 /* account */,
          address: receipt.to
        },
        assetsSent: [
          {
            amount: receipt.amount,
            assetId: receipt.assetId
          }
        ]
      });
      return newContractTransferOps;
    },
    []
  );
  return contractTransferOperations;
}
function getWithdrawFromFuelOperations({
  inputs,
  receipts
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce(
    (prevWithdrawFromFuelOps, receipt) => {
      const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
      const input = getInputFromAssetId(inputs, assetId);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
          name: "Withdraw from Fuel" /* withdrawFromFuel */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 1 /* account */,
            address: receipt.recipient.toString(),
            chain: "ethereum" /* ethereum */
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId
            }
          ]
        });
        return newWithdrawFromFuelOps;
      }
      return prevWithdrawFromFuelOps;
    },
    []
  );
  return withdrawFromFuelOperations;
}
function getContractCallOperations({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output) => {
    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);
    if (contractInput) {
      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
        if (receipt.to === contractInput.contractID) {
          const input = getInputFromAssetId(inputs, receipt.assetId);
          if (input) {
            const inputAddress = getInputAccountAddress(input);
            const calls = [];
            const abi = abiMap?.[contractInput.contractID];
            if (abi) {
              calls.push(
                getFunctionCall({
                  abi,
                  receipt,
                  rawPayload,
                  maxInputs
                })
              );
            }
            const newContractCallOps = addOperation(prevContractCallOps, {
              name: "Contract call" /* contractCall */,
              from: {
                type: 1 /* account */,
                address: inputAddress
              },
              to: {
                type: 0 /* contract */,
                address: receipt.to
              },
              // if no amount is forwarded to the contract, skip showing assetsSent
              assetsSent: receipt.amount?.isZero() ? void 0 : [
                {
                  amount: receipt.amount,
                  assetId: receipt.assetId
                }
              ],
              calls
            });
            return newContractCallOps;
          }
        }
        return prevContractCallOps;
      }, prevOutputCallOps);
      return newCallOps;
    }
    return prevOutputCallOps;
  }, []);
  return contractCallOperations;
}
function getTransferOperations({
  inputs,
  outputs,
  receipts
}) {
  const coinOutputs = getOutputsCoin(outputs);
  const [transferReceipt] = getReceiptsByType(
    receipts,
    import_transactions13.ReceiptType.Transfer
  );
  let operations = [];
  if (transferReceipt) {
    const changeOutputs = getOutputsChange(outputs);
    changeOutputs.forEach((output) => {
      const { assetId } = output;
      const [contractInput] = getInputsContract(inputs);
      const utxo = getInputFromAssetId(inputs, assetId);
      if (utxo && contractInput) {
        const inputAddress = getInputAccountAddress(utxo);
        operations = addOperation(operations, {
          name: "Transfer asset" /* transfer */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 0 /* contract */,
            address: contractInput.contractID
          },
          assetsSent: [
            {
              assetId: assetId.toString(),
              amount: transferReceipt.amount
            }
          ]
        });
      }
    });
  } else {
    coinOutputs.forEach((output) => {
      const input = getInputFromAssetId(inputs, output.assetId);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const operationToAdd = {
          name: "Transfer asset" /* transfer */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 1 /* account */,
            address: output.to.toString()
          },
          assetsSent: [
            {
              assetId: output.assetId.toString(),
              amount: output.amount
            }
          ]
        };
        operations = addOperation(operations, operationToAdd);
      }
    });
  }
  return operations;
}
function getPayProducerOperations(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev, output) => {
    const operations = addOperation(prev, {
      name: "Pay network fee to block producer" /* payBlockProducer */,
      from: {
        type: 1 /* account */,
        address: "Network"
      },
      to: {
        type: 1 /* account */,
        address: output.to.toString()
      },
      assetsSent: [
        {
          assetId: output.assetId.toString(),
          amount: output.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
}
function getContractCreatedOperations({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoinAndMessage(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
    const operations = addOperation(prev, {
      name: "Contract created" /* contractCreated */,
      from: {
        type: 1 /* account */,
        address: fromAddress
      },
      to: {
        type: 0 /* contract */,
        address: contractCreatedOutput?.contractId || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
}
function getOperations({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  if (isTypeCreate(transactionType)) {
    return [
      ...getContractCreatedOperations({ inputs, outputs }),
      ...getTransferOperations({ inputs, outputs, receipts })
    ];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs
      }),
      ...getContractTransferOperations({ receipts }),
      ...getWithdrawFromFuelOperations({ inputs, receipts })
    ];
  }
  return [...getPayProducerOperations(outputs)];
}

// src/providers/transaction-summary/receipt.ts
var import_transactions14 = require("@fuel-ts/transactions");
var processGqlReceipt = (gqlReceipt) => {
  const receipt = assembleReceiptByType(gqlReceipt);
  switch (receipt.type) {
    case import_transactions14.ReceiptType.ReturnData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    case import_transactions14.ReceiptType.LogData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    default:
      return receipt;
  }
};
var extractMintedAssetsFromReceipts = (receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions14.ReceiptType.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
};
var extractBurnedAssetsFromReceipts = (receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === import_transactions14.ReceiptType.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
};

// src/providers/transaction-summary/status.ts
var import_errors11 = require("@fuel-ts/errors");
var getTransactionStatusName = (gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure" /* failure */;
    case "SuccessStatus":
      return "success" /* success */;
    case "SubmittedStatus":
      return "submitted" /* submitted */;
    case "SqueezedOutStatus":
      return "squeezedout" /* squeezedout */;
    default:
      throw new import_errors11.FuelError(
        import_errors11.ErrorCode.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${gqlStatus}.`
      );
  }
};
var processGraphqlStatus = (gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  if (gqlTransactionStatus?.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusSuccess = true;
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusFailure = true;
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
      default:
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending
  };
  return processedGraphqlStatus;
};

// src/providers/transaction-summary/assemble-transaction-summary.ts
function assembleTransactionSummary(params) {
  const {
    id,
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction,
    transactionBytes,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs,
    gasCosts
  } = params;
  const gasUsed = getGasUsedFromReceipts(receipts);
  const rawPayload = (0, import_ethers16.hexlify)(transactionBytes);
  const operations = getOperations({
    transactionType: transaction.type,
    inputs: transaction.inputs || [],
    outputs: transaction.outputs || [],
    receipts,
    rawPayload,
    abiMap,
    maxInputs
  });
  const typeName = getTransactionTypeName(transaction.type);
  const { fee } = calculateTransactionFee({
    gasUsed,
    rawPayload,
    consensusParameters: {
      gasCosts,
      feeParams: {
        gasPerByte,
        gasPriceFactor
      }
    }
  });
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus(gqlTransactionStatus);
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = fromTai64ToDate(time);
  }
  const transactionSummary = {
    id,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction.type),
    isTypeCreate: isTypeCreate(transaction.type),
    isTypeScript: isTypeScript(transaction.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction
  };
  return transactionSummary;
}

// src/providers/transaction-response/transaction-response.ts
var TransactionResponse = class {
  /** Transaction ID */
  id;
  /** Current provider */
  provider;
  /** Gas used on the transaction */
  gasUsed = (0, import_math13.bn)(0);
  /** The graphql Transaction with receipts object. */
  gqlTransaction;
  /**
   * Constructor for `TransactionResponse`.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  constructor(id, provider) {
    this.id = id;
    this.provider = provider;
  }
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(id, provider) {
    const response = new TransactionResponse(id, provider);
    await response.fetch();
    return response;
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      const subscription = this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange) {
          break;
        }
      }
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  /**
   * Decode the raw payload of the transaction.
   *
   * @param transactionWithReceipts - The transaction with receipts object.
   * @returns The decoded transaction.
   */
  decodeTransaction(transactionWithReceipts) {
    return new import_transactions15.TransactionCoder().decode(
      (0, import_ethers17.getBytesCopy)(transactionWithReceipts.rawPayload),
      0
    )?.[0];
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(contractsAbiMap) {
    let transaction = this.gqlTransaction;
    if (!transaction) {
      transaction = await this.fetch();
    }
    const decodedTransaction = this.decodeTransaction(
      transaction
    );
    const receipts = transaction.receipts?.map(processGqlReceipt) || [];
    const { gasPerByte, gasPriceFactor, gasCosts } = this.provider.getGasConfig();
    const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: (0, import_ethers17.getBytesCopy)(transaction.rawPayload),
      gqlTransactionStatus: transaction.status,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs,
      gasCosts
    });
    return transactionSummary;
  }
  async waitForStatusChange() {
    const status = this.gqlTransaction?.status?.type;
    if (status && status !== "SubmittedStatus") {
      return;
    }
    const subscription = this.provider.operations.statusChange({
      transactionId: this.id
    });
    for await (const { statusChange } of subscription) {
      if (statusChange.type !== "SubmittedStatus") {
        break;
      }
    }
    await this.fetch();
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(contractsAbiMap) {
    await this.waitForStatusChange();
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      gqlTransaction: this.gqlTransaction,
      ...transactionSummary
    };
    return transactionResult;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(contractsAbiMap) {
    const result = await this.waitForResult(contractsAbiMap);
    if (result.isStatusFailure) {
      throw new import_errors12.FuelError(
        import_errors12.ErrorCode.TRANSACTION_FAILED,
        `Transaction failed: ${result.gqlTransaction.status.reason}`
      );
    }
    return result;
  }
};

// src/providers/transaction-response/getDecodedLogs.ts
var import_abi_coder3 = require("@fuel-ts/abi-coder");
var import_transactions16 = require("@fuel-ts/transactions");
function getDecodedLogs(receipts, abiInterface) {
  return receipts.reduce((logs, r) => {
    if (r.type === import_transactions16.ReceiptType.LogData) {
      logs.push(abiInterface.decodeLog(r.data, r.val1.toNumber(), r.id)[0]);
    }
    if (r.type === import_transactions16.ReceiptType.Log) {
      logs.push(abiInterface.decodeLog(new import_abi_coder3.U64Coder().encode(r.val0), r.val1.toNumber(), r.id)[0]);
    }
    return logs;
  }, []);
}

// src/providers/utils/auto-retry-fetch.ts
function getWaitDelay(options, retryAttemptNum) {
  const duration = options.baseDelay ?? 150;
  switch (options.backoff) {
    case "linear":
      return duration * retryAttemptNum;
    case "fixed":
      return duration;
    case "exponential":
    default:
      return 2 ** (retryAttemptNum - 1) * duration;
  }
}
function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
  if (options === void 0) {
    return fetchFn;
  }
  return async (...args) => {
    try {
      return await fetchFn(...args);
    } catch (_error) {
      const error = _error;
      if (error.cause?.code !== "ECONNREFUSED") {
        throw error;
      }
      const retryNum = retryAttemptNum + 1;
      if (retryNum > options.maxRetries) {
        throw error;
      }
      const delay = getWaitDelay(options, retryNum);
      await sleep(delay);
      return autoRetryFetch(fetchFn, options, retryNum)(...args);
    }
  };
}

// src/providers/utils/merge-quantities.ts
var mergeQuantities = (arr1, arr2) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  arr1.forEach(addToMap);
  arr2.forEach(addToMap);
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
};

// src/providers/provider.ts
var MAX_RETRIES = 10;
var processGqlChain = (chain) => {
  const { name, daHeight, consensusParameters, latestBlock } = chain;
  const { contractParams, feeParams, predicateParams, scriptParams, txParams, gasCosts } = consensusParameters;
  return {
    name,
    baseChainHeight: (0, import_math14.bn)(daHeight),
    consensusParameters: {
      contractMaxSize: (0, import_math14.bn)(contractParams.contractMaxSize),
      maxInputs: (0, import_math14.bn)(txParams.maxInputs),
      maxOutputs: (0, import_math14.bn)(txParams.maxOutputs),
      maxWitnesses: (0, import_math14.bn)(txParams.maxWitnesses),
      maxGasPerTx: (0, import_math14.bn)(txParams.maxGasPerTx),
      maxScriptLength: (0, import_math14.bn)(scriptParams.maxScriptLength),
      maxScriptDataLength: (0, import_math14.bn)(scriptParams.maxScriptDataLength),
      maxStorageSlots: (0, import_math14.bn)(contractParams.maxStorageSlots),
      maxPredicateLength: (0, import_math14.bn)(predicateParams.maxPredicateLength),
      maxPredicateDataLength: (0, import_math14.bn)(predicateParams.maxPredicateDataLength),
      maxGasPerPredicate: (0, import_math14.bn)(predicateParams.maxGasPerPredicate),
      gasPriceFactor: (0, import_math14.bn)(feeParams.gasPriceFactor),
      gasPerByte: (0, import_math14.bn)(feeParams.gasPerByte),
      maxMessageDataLength: (0, import_math14.bn)(predicateParams.maxMessageDataLength),
      chainId: (0, import_math14.bn)(consensusParameters.chainId),
      gasCosts
    },
    gasCosts,
    latestBlock: {
      id: latestBlock.id,
      height: (0, import_math14.bn)(latestBlock.header.height),
      time: latestBlock.header.time,
      transactions: latestBlock.transactions.map((i) => ({
        id: i.id
      }))
    }
  };
};
var _cacheInputs, cacheInputs_fn;
var _Provider = class {
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param chainInfo - Chain info of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(url, options = {}) {
    this.url = url;
    /**
     * @hidden
     */
    __privateAdd(this, _cacheInputs);
    __publicField(this, "operations");
    __publicField(this, "cache");
    __publicField(this, "options", {
      timeout: void 0,
      cacheUtxo: void 0,
      fetch: void 0,
      retryOptions: void 0
    });
    this.options = { ...this.options, ...options };
    this.url = url;
    this.operations = this.createOperations();
    this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : void 0;
  }
  static clearChainAndNodeCaches() {
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
  }
  static getFetchFn(options) {
    const { retryOptions, timeout } = options;
    return autoRetryFetch((...args) => {
      if (options.fetch) {
        return options.fetch(...args);
      }
      const url = args[0];
      const request = args[1];
      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
      return fetch(url, { ...request, signal });
    }, retryOptions);
  }
  /**
   * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   */
  static async create(url, options = {}) {
    const provider = new _Provider(url, options);
    await provider.fetchChainAndNodeInfo();
    return provider;
  }
  /**
   * Returns the cached chainInfo for the current URL.
   */
  getChain() {
    const chain = _Provider.chainInfoCache[this.url];
    if (!chain) {
      throw new import_errors13.FuelError(
        import_errors13.ErrorCode.CHAIN_INFO_CACHE_EMPTY,
        "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return chain;
  }
  /**
   * Returns the cached nodeInfo for the current URL.
   */
  getNode() {
    const node = _Provider.nodeInfoCache[this.url];
    if (!node) {
      throw new import_errors13.FuelError(
        import_errors13.ErrorCode.NODE_INFO_CACHE_EMPTY,
        "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return node;
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  getGasConfig() {
    const { minGasPrice } = this.getNode();
    const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte, gasCosts } = this.getChain().consensusParameters;
    return {
      minGasPrice,
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte,
      gasCosts
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   */
  async connect(url, options) {
    this.url = url;
    this.options = options ?? this.options;
    this.operations = this.createOperations();
    await this.fetchChainAndNodeInfo();
  }
  /**
   * Fetches both the chain and node information, saves it to the cache, and return it.
   *
   * @returns NodeInfo and Chain
   */
  async fetchChainAndNodeInfo() {
    const chain = await this.fetchChain();
    const nodeInfo = await this.fetchNode();
    _Provider.ensureClientVersionIsSupported(nodeInfo);
    return {
      chain,
      nodeInfo
    };
  }
  static ensureClientVersionIsSupported(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = (0, import_versions.checkFuelCoreVersionCompatibility)(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      throw new import_errors13.FuelError(
        import_errors13.FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,
        `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`
      );
    }
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   */
  createOperations() {
    const fetchFn = _Provider.getFetchFn(this.options);
    const gqlClient = new import_graphql_request.GraphQLClient(this.url, {
      fetch: (url, requestInit) => fetchFn(url, requestInit, this.options)
    });
    const executeQuery = (query, vars) => {
      const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
      const isSubscription = opDefinition?.operation === "subscription";
      if (isSubscription) {
        return fuelGraphQLSubscriber({
          url: this.url,
          query,
          fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
          variables: vars
        });
      }
      return gqlClient.request(query, vars);
    };
    return getSdk(executeQuery);
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  /**
   * @hidden
   *
   * Returns the network configuration of the connected Fuel node.
   *
   * @returns A promise that resolves to the network configuration object
   */
  async getNetwork() {
    const {
      name,
      consensusParameters: { chainId }
    } = await this.getChain();
    const network = new import_ethers18.Network(name, chainId.toNumber());
    return Promise.resolve(network);
  }
  /**
   * Returns the block number.
   *
   * @returns A promise that resolves to the block number
   */
  async getBlockNumber() {
    const { chain } = await this.operations.getChain();
    return (0, import_math14.bn)(chain.latestBlock.header.height, 10);
  }
  /**
   * Returns the chain information.
   * @param url - The URL of the Fuel node
   * @returns NodeInfo object
   */
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = {
      maxDepth: (0, import_math14.bn)(nodeInfo.maxDepth),
      maxTx: (0, import_math14.bn)(nodeInfo.maxTx),
      minGasPrice: (0, import_math14.bn)(nodeInfo.minGasPrice),
      nodeVersion: nodeInfo.nodeVersion,
      utxoValidation: nodeInfo.utxoValidation,
      vmBacktrace: nodeInfo.vmBacktrace,
      peers: nodeInfo.peers
    };
    _Provider.nodeInfoCache[this.url] = processedNodeInfo;
    return processedNodeInfo;
  }
  /**
   * Fetches the `chainInfo` for the given node URL.
   * @param url - The URL of the Fuel node
   * @returns ChainInfo object
   */
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = processGqlChain(chain);
    _Provider.chainInfoCache[this.url] = processedChain;
    return processedChain;
  }
  /**
   * Returns the chain ID
   * @returns A promise that resolves to the chain ID number
   */
  getChainId() {
    const {
      consensusParameters: { chainId }
    } = this.getChain();
    return chainId.toNumber();
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @returns A promise that resolves to the transaction response object.
   */
  // #region Provider-sendTransaction
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution = false } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    __privateMethod(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_ethers18.hexlify)(transactionRequest.toTransactionBytes());
    if (awaitExecution) {
      const subscription = this.operations.submitAndAwait({ encodedTransaction });
      for await (const { submitAndAwait } of subscription) {
        if (submitAndAwait.type !== "SubmittedStatus") {
          break;
        }
      }
      const transactionId2 = transactionRequest.getTransactionId(this.getChainId());
      const response = new TransactionResponse(transactionId2, this);
      await response.fetch();
      return response;
    }
    const {
      submit: { id: transactionId }
    } = await this.operations.submit({ encodedTransaction });
    return new TransactionResponse(transactionId, this);
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param utxoValidation - Additional provider call parameters.
   * @returns A promise that resolves to the call result object.
   */
  async call(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_ethers18.hexlify)(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  /**
   * Verifies whether enough gas is available to complete transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimated transaction request object.
   */
  async estimatePredicates(transactionRequest) {
    const encodedTransaction = (0, import_ethers18.hexlify)(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const {
      estimatePredicates: { inputs }
    } = response;
    if (inputs) {
      inputs.forEach((input, index) => {
        if ("predicateGasUsed" in input && (0, import_math14.bn)(input.predicateGasUsed).gt(0)) {
          transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return transactionRequest;
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @privateRemarks
   * TODO: Investigate support for missing contract IDs
   * TODO: Add support for missing output messages
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise.
   */
  async estimateTxDependencies(transactionRequest) {
    let missingOutputVariableCount = 0;
    let missingOutputContractIdsCount = 0;
    let tries = 0;
    if (transactionRequest.type === import_transactions17.TransactionType.Create) {
      return;
    }
    let txRequest = transactionRequest;
    if (txRequest.hasPredicateInput()) {
      txRequest = await this.estimatePredicates(txRequest);
    }
    while (tries < MAX_RETRIES) {
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction: (0, import_ethers18.hexlify)(txRequest.toTransactionBytes()),
        utxoValidation: false
      });
      const receipts = gqlReceipts.map(processGqlReceipt);
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      missingOutputVariableCount = missingOutputVariables.length;
      missingOutputContractIdsCount = missingOutputContractIds.length;
      if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {
        return;
      }
      txRequest.addVariableOutputs(missingOutputVariableCount);
      missingOutputContractIds.forEach(
        ({ contractId }) => txRequest.addContractInputAndOutput(import_address3.Address.fromString(contractId))
      );
      tries += 1;
    }
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @returns A promise that resolves to the call result object.
   */
  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = (0, import_ethers18.hexlify)(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: true
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the the transaction.
   *
   * @privateRemarks
   * The tolerance is add on top of the gasUsed calculated
   * from the node, this create a safe margin costs like
   * change states on transfer that don't occur on the dryRun
   * transaction. The default value is 0.2 or 20%
   *
   * @param transactionRequestLike - The transaction request object.
   * @param tolerance - The tolerance to add on top of the gasUsed.
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, forwardingQuantities = [], {
    estimateTxDependencies = true,
    estimatePredicates = true,
    resourcesOwner
  } = {}) {
    const transactionRequest = transactionRequestify((0, import_ramda3.clone)(transactionRequestLike));
    const chainInfo = this.getChain();
    const { gasPriceFactor, minGasPrice, maxGasPerTx } = this.getGasConfig();
    const gasPrice = (0, import_math14.max)(transactionRequest.gasPrice, minGasPrice);
    const isScriptTransaction = transactionRequest.type === import_transactions17.TransactionType.Script;
    if (transactionRequest.hasPredicateInput() && estimatePredicates) {
      if (isScriptTransaction) {
        transactionRequest.gasLimit = (0, import_math14.bn)(0);
      }
      await this.estimatePredicates(transactionRequest);
    }
    const minGas = transactionRequest.calculateMinGas(chainInfo);
    const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);
    const coinOutputsQuantities = transactionRequest.getCoinOutputsQuantities();
    const allQuantities = mergeQuantities(coinOutputsQuantities, forwardingQuantities);
    transactionRequest.fundWithFakeUtxos(allQuantities, resourcesOwner);
    let gasUsed = minGas;
    let receipts = [];
    if (isScriptTransaction) {
      transactionRequest.gasPrice = (0, import_math14.bn)(0);
      transactionRequest.gasLimit = (0, import_math14.bn)(maxGasPerTx.sub(maxGas).toNumber() * 0.9);
      const result = await this.call(transactionRequest, {
        estimateTxDependencies
      });
      receipts = result.receipts;
      gasUsed = getGasUsedFromReceipts(receipts);
    } else {
      gasUsed = minGas;
    }
    const usedFee = calculatePriceWithFactor(
      gasUsed,
      gasPrice,
      gasPriceFactor
    ).normalizeZeroToOne();
    const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
    const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
    return {
      requiredQuantities: allQuantities,
      receipts,
      gasUsed,
      minGasPrice,
      gasPrice,
      minGas,
      maxGas,
      usedFee,
      minFee,
      maxFee
    };
  }
  async getResourcesForTransaction(owner, transactionRequestLike, forwardingQuantities = []) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const transactionRequest = transactionRequestify((0, import_ramda3.clone)(transactionRequestLike));
    const transactionCost = await this.getTransactionCost(transactionRequest, forwardingQuantities);
    transactionRequest.addResources(
      await this.getResourcesToSpend(ownerAddress, transactionCost.requiredQuantities)
    );
    const { requiredQuantities, ...txCost } = await this.getTransactionCost(
      transactionRequest,
      forwardingQuantities
    );
    const resources = await this.getResourcesToSpend(ownerAddress, requiredQuantities);
    return {
      resources,
      requiredQuantities,
      ...txCost
    };
  }
  /**
   * Returns coins for the given owner.
   */
  async getCoins(owner, assetId, paginationArgs) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const result = await this.operations.getCoins({
      first: 10,
      ...paginationArgs,
      filter: { owner: ownerAddress.toB256(), assetId: assetId && (0, import_ethers18.hexlify)(assetId) }
    });
    const coins = result.coins.edges.map((edge) => edge.node);
    return coins.map((coin) => ({
      id: coin.utxoId,
      assetId: coin.assetId,
      amount: (0, import_math14.bn)(coin.amount),
      owner: import_address3.Address.fromAddressOrString(coin.owner),
      maturity: (0, import_math14.bn)(coin.maturity).toNumber(),
      blockCreated: (0, import_math14.bn)(coin.blockCreated),
      txCreatedIdx: (0, import_math14.bn)(coin.txCreatedIdx)
    }));
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The quantities to get.
   * @param excludedIds - IDs of excluded resources from the selection.
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(owner, quantities, excludedIds) {
    const ownerAddress = import_address3.Address.fromAddressOrString(owner);
    const excludeInput = {
      messages: excludedIds?.messages?.map((nonce) => (0, import_ethers18.hexlify)(nonce)) || [],
      utxos: excludedIds?.utxos?.map((id) => (0, import_ethers18.hexlify)(id)) || []
    };
    if (this.cache) {
      const uniqueUtxos = new Set(
        excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => (0, import_ethers18.hexlify)(id)))
      );
      excludeInput.utxos = Array.from(uniqueUtxos);
    }
    const coinsQuery = {
      owner: ownerAddress.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: (0, import_ethers18.hexlify)(assetId),
        amount: amount.toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : void 0
      })),
      excludedIds: excludeInput
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.__typename) {
        case "MessageCoin":
          return {
            amount: (0, import_math14.bn)(coin.amount),
            assetId: coin.assetId,
            daHeight: (0, import_math14.bn)(coin.daHeight),
            sender: import_address3.Address.fromAddressOrString(coin.sender),
            recipient: import_address3.Address.fromAddressOrString(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: (0, import_math14.bn)(coin.amount),
            assetId: coin.assetId,
            owner: import_address3.Address.fromAddressOrString(coin.owner),
            maturity: (0, import_math14.bn)(coin.maturity).toNumber(),
            blockCreated: (0, import_math14.bn)(coin.blockCreated),
            txCreatedIdx: (0, import_math14.bn)(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v) => !!v);
    return coins;
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlock(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { height: (0, import_math14.bn)(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { height: (await this.getBlockNumber()).toString(10) };
    } else if (idOrHeight.length === 66) {
      variables = { blockId: idOrHeight };
    } else {
      variables = { blockId: (0, import_math14.bn)(idOrHeight).toString(10) };
    }
    const { block } = await this.operations.getBlock(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: (0, import_math14.bn)(block.header.height),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(params) {
    const { blocks: fetchedData } = await this.operations.getBlocks(params);
    const blocks = fetchedData.edges.map(({ node: block }) => ({
      id: block.id,
      height: (0, import_math14.bn)(block.header.height),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id)
    }));
    return blocks;
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: (0, import_math14.bn)(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else {
      variables = { blockId: idOrHeight };
    }
    const { block } = await this.operations.getBlockWithTransactions(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: (0, import_math14.bn)(block.header.height, 10),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id),
      transactions: block.transactions.map(
        (tx) => new import_transactions17.TransactionCoder().decode((0, import_ethers18.getBytesCopy)(tx.rawPayload), 0)?.[0]
      )
    };
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(transactionId) {
    const { transaction } = await this.operations.getTransaction({ transactionId });
    if (!transaction) {
      return null;
    }
    return new import_transactions17.TransactionCoder().decode(
      (0, import_ethers18.getBytesCopy)(transaction.rawPayload),
      0
    )?.[0];
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(contractId) {
    const { contract } = await this.operations.getContract({ contractId });
    if (!contract) {
      return null;
    }
    return contract;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(contractId, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: import_address3.Address.fromAddressOrString(contractId).toB256(),
      asset: (0, import_ethers18.hexlify)(assetId)
    });
    return (0, import_math14.bn)(contractBalance.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalance({
      owner: import_address3.Address.fromAddressOrString(owner).toB256(),
      assetId: (0, import_ethers18.hexlify)(assetId)
    });
    return (0, import_math14.bn)(balance.amount, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments.
   * @returns A promise that resolves to the balances.
   */
  async getBalances(owner, paginationArgs) {
    const result = await this.operations.getBalances({
      first: 10,
      ...paginationArgs,
      filter: { owner: import_address3.Address.fromAddressOrString(owner).toB256() }
    });
    const balances = result.balances.edges.map((edge) => edge.node);
    return balances.map((balance) => ({
      assetId: balance.assetId,
      amount: (0, import_math14.bn)(balance.amount)
    }));
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments.
   * @returns A promise that resolves to the messages.
   */
  async getMessages(address, paginationArgs) {
    const result = await this.operations.getMessages({
      first: 10,
      ...paginationArgs,
      owner: import_address3.Address.fromAddressOrString(address).toB256()
    });
    const messages = result.messages.edges.map((edge) => edge.node);
    return messages.map((message) => ({
      messageId: import_transactions17.InputMessageCoder.getMessageId({
        sender: message.sender,
        recipient: message.recipient,
        nonce: message.nonce,
        amount: (0, import_math14.bn)(message.amount),
        data: message.data
      }),
      sender: import_address3.Address.fromAddressOrString(message.sender),
      recipient: import_address3.Address.fromAddressOrString(message.recipient),
      nonce: message.nonce,
      amount: (0, import_math14.bn)(message.amount),
      data: import_transactions17.InputMessageCoder.decodeData(message.data),
      daHeight: (0, import_math14.bn)(message.daHeight)
    }));
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id.
   * @param commitBlockHeight - The commit block height.
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      nonce
    };
    if (commitBlockId && commitBlockHeight) {
      throw new import_errors13.FuelError(
        import_errors13.ErrorCode.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        // Conver BN into a number string required on the query
        // This should problably be fixed on the fuel client side
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    if (!result.messageProof) {
      return null;
    }
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      sender,
      recipient,
      amount,
      data
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: (0, import_math14.bn)(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: (0, import_math14.bn)(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: (0, import_math14.bn)(messageBlockHeader.daHeight),
        transactionsCount: (0, import_math14.bn)(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: (0, import_math14.bn)(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
        messageReceiptCount: (0, import_math14.bn)(messageBlockHeader.messageReceiptCount)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: (0, import_math14.bn)(commitBlockHeader.daHeight),
        transactionsCount: (0, import_math14.bn)(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: (0, import_math14.bn)(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
        messageReceiptCount: (0, import_math14.bn)(commitBlockHeader.messageReceiptCount)
      },
      sender: import_address3.Address.fromAddressOrString(sender),
      recipient: import_address3.Address.fromAddressOrString(recipient),
      nonce,
      amount: (0, import_math14.bn)(amount),
      data
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce
   * @param startTime - The UNIX timestamp to set for the first produced block
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: (0, import_math14.bn)(amount).toString(10),
      startTimestamp: startTime ? fromUnixToTai64(startTime) : void 0
    });
    return (0, import_math14.bn)(latestBlockHeight);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getTransactionResponse(transactionId) {
    return new TransactionResponse(transactionId, this);
  }
};
var Provider = _Provider;
_cacheInputs = new WeakSet();
cacheInputs_fn = function(inputs) {
  if (!this.cache) {
    return;
  }
  inputs.forEach((input) => {
    if (input.type === import_transactions17.InputType.Coin) {
      this.cache?.set(input.id);
    }
  });
};
__publicField(Provider, "chainInfoCache", {});
__publicField(Provider, "nodeInfoCache", {});

// src/providers/transaction-summary/get-transaction-summary.ts
var import_errors14 = require("@fuel-ts/errors");
var import_math15 = require("@fuel-ts/math");
var import_transactions18 = require("@fuel-ts/transactions");
var import_ethers19 = require("ethers");
async function getTransactionSummary(params) {
  const { id, provider, abiMap } = params;
  const { transaction: gqlTransaction } = await provider.operations.getTransactionWithReceipts({
    transactionId: id
  });
  if (!gqlTransaction) {
    throw new import_errors14.FuelError(
      import_errors14.ErrorCode.TRANSACTION_NOT_FOUND,
      `Transaction not found for given id: ${id}.`
    );
  }
  const [decodedTransaction] = new import_transactions18.TransactionCoder().decode(
    (0, import_ethers19.getBytesCopy)(gqlTransaction.rawPayload),
    0
  );
  const receipts = gqlTransaction.receipts?.map(processGqlReceipt) || [];
  const {
    consensusParameters: { gasPerByte, gasPriceFactor, maxInputs, gasCosts }
  } = provider.getChain();
  const transactionInfo = assembleTransactionSummary({
    id: gqlTransaction.id,
    receipts,
    transaction: decodedTransaction,
    transactionBytes: (0, import_ethers19.getBytesCopy)(gqlTransaction.rawPayload),
    gqlTransactionStatus: gqlTransaction.status,
    gasPerByte: (0, import_math15.bn)(gasPerByte),
    gasPriceFactor: (0, import_math15.bn)(gasPriceFactor),
    abiMap,
    maxInputs,
    gasCosts
  });
  return {
    gqlTransaction,
    ...transactionInfo
  };
}
async function getTransactionSummaryFromRequest(params) {
  const { provider, transactionRequest, abiMap } = params;
  const { receipts } = await provider.call(transactionRequest);
  const { gasPerByte, gasPriceFactor, gasCosts } = provider.getGasConfig();
  const maxInputs = provider.getChain().consensusParameters.maxInputs;
  const transaction = transactionRequest.toTransaction();
  const transactionBytes = transactionRequest.toTransactionBytes();
  const transactionSummary = assembleTransactionSummary({
    receipts,
    transaction,
    transactionBytes,
    abiMap,
    gasPerByte,
    gasPriceFactor,
    maxInputs,
    gasCosts
  });
  return transactionSummary;
}
async function getTransactionsSummaries(params) {
  const { filters, provider, abiMap } = params;
  const { transactionsByOwner } = await provider.operations.getTransactionsByOwner(filters);
  const { edges, pageInfo } = transactionsByOwner;
  const {
    consensusParameters: { gasPerByte, gasPriceFactor, maxInputs, gasCosts }
  } = provider.getChain();
  const transactions = edges.map((edge) => {
    const { node: gqlTransaction } = edge;
    const { id, rawPayload, receipts: gqlReceipts, status } = gqlTransaction;
    const [decodedTransaction] = new import_transactions18.TransactionCoder().decode((0, import_ethers19.getBytesCopy)(rawPayload), 0);
    const receipts = gqlReceipts?.map(processGqlReceipt) || [];
    const transactionSummary = assembleTransactionSummary({
      id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: (0, import_ethers19.getBytesCopy)(rawPayload),
      gqlTransactionStatus: status,
      abiMap,
      gasPerByte,
      gasPriceFactor,
      maxInputs,
      gasCosts
    });
    const output = {
      gqlTransaction,
      ...transactionSummary
    };
    return output;
  });
  return {
    transactions,
    pageInfo
  };
}

// src/utils/formatTransferToContractScriptData.ts
var import_abi_coder4 = require("@fuel-ts/abi-coder");
var import_math16 = require("@fuel-ts/math");
var asm = __toESM(require("@fuels/vm-asm"));
var import_ethers20 = require("ethers");
var formatTransferToContractScriptData = (params) => {
  const { assetId, amountToTransfer, hexlifiedContractId } = params;
  const numberCoder = new import_abi_coder4.U64Coder();
  const encoded = numberCoder.encode(new import_math16.BN(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...(0, import_ethers20.getBytesCopy)(hexlifiedContractId),
    ...encoded,
    ...(0, import_ethers20.getBytesCopy)(assetId)
  ]);
  return scriptData;
};
var assembleTransferToContractScript = async (params) => {
  const scriptData = formatTransferToContractScriptData(params);
  await asm.initWasm();
  const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
  const addi2 = asm.addi(17, 16, 32);
  const lw2 = asm.lw(18, 17, 0);
  const addi22 = asm.addi(19, 17, 8);
  const tr2 = asm.tr(16, 18, 19);
  const ret2 = asm.ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return { script, scriptData };
};

// src/account.ts
var Account = class extends import_interfaces.AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  _provider;
  _connector;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   */
  constructor(address, provider, connector) {
    super();
    this._provider = provider;
    this._connector = connector;
    this.address = import_address4.Address.fromDynamicInput(address);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider) {
      throw new import_errors15.FuelError(import_errors15.ErrorCode.MISSING_PROVIDER, "Provider not set");
    }
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(provider) {
    this._provider = provider;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this._provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve.
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
      );
    }
    return coins;
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
      );
    }
    return messages;
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for.
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId = import_configs10.BaseAssetId) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
      );
    }
    return balances;
  }
  /**
   * Adds resources to the transaction enough to fund it.
   *
   * @param request - The transaction request.
   * @param coinQuantities - The coin quantities required to execute the transaction.
   * @param fee - The estimated transaction fee.
   * @returns A promise that resolves when the resources are added to the transaction.
   */
  async fund(request, coinQuantities, fee) {
    const updatedQuantities = addAmountToAsset({
      amount: (0, import_math17.bn)(fee),
      assetId: import_configs10.BaseAssetId,
      coinQuantities
    });
    const quantitiesDict = {};
    updatedQuantities.forEach(({ amount, assetId }) => {
      quantitiesDict[assetId] = {
        required: amount,
        owned: (0, import_math17.bn)(0)
      };
    });
    const cachedUtxos = [];
    const cachedMessages = [];
    const owner = this.address.toB256();
    request.inputs.forEach((input) => {
      const isResource = "amount" in input;
      if (isResource) {
        const isCoin2 = "owner" in input;
        if (isCoin2) {
          const assetId = String(input.assetId);
          if (input.owner === owner && quantitiesDict[assetId]) {
            const amount = (0, import_math17.bn)(input.amount);
            quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(amount);
            cachedUtxos.push(input.id);
          }
        } else if (input.recipient === owner && input.amount && quantitiesDict[import_configs10.BaseAssetId]) {
          quantitiesDict[import_configs10.BaseAssetId].owned = quantitiesDict[import_configs10.BaseAssetId].owned.add(input.amount);
          cachedMessages.push(input.nonce);
        }
      }
    });
    const missingQuantities = [];
    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
      if (owned.lt(required)) {
        missingQuantities.push({
          assetId,
          amount: required.sub(owned)
        });
      }
    });
    const needsToBeFunded = missingQuantities.length;
    if (needsToBeFunded) {
      const resources = await this.getResourcesToSpend(missingQuantities, {
        messages: cachedMessages,
        utxos: cachedUtxos
      });
      request.addResources(resources);
    }
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId = import_configs10.BaseAssetId, txParams = {}) {
    const { minGasPrice } = this.provider.getGasConfig();
    const params = { gasPrice: minGasPrice, ...txParams };
    const request = new ScriptTransactionRequest(params);
    request.addCoinOutput(import_address4.Address.fromAddressOrString(destination), amount, assetId);
    const { maxFee, requiredQuantities, gasUsed } = await this.provider.getTransactionCost(request);
    request.gasPrice = (0, import_math17.bn)(txParams.gasPrice ?? minGasPrice);
    request.gasLimit = (0, import_math17.bn)(txParams.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return request;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId = import_configs10.BaseAssetId, txParams = {}) {
    const request = await this.createTransfer(destination, amount, assetId, txParams);
    return this.sendTransaction(request);
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId = import_configs10.BaseAssetId, txParams = {}) {
    const contractAddress = import_address4.Address.fromAddressOrString(contractId);
    const { minGasPrice } = this.provider.getGasConfig();
    const params = { gasPrice: minGasPrice, ...txParams };
    const { script, scriptData } = await assembleTransferToContractScript({
      hexlifiedContractId: contractAddress.toB256(),
      amountToTransfer: (0, import_math17.bn)(amount),
      assetId
    });
    const request = new ScriptTransactionRequest({
      ...params,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractAddress);
    const { maxFee, requiredQuantities, gasUsed } = await this.provider.getTransactionCost(
      request,
      [{ amount: (0, import_math17.bn)(amount), assetId: String(assetId) }]
    );
    request.gasLimit = (0, import_math17.bn)(params.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const { minGasPrice } = this.provider.getGasConfig();
    const recipientAddress = import_address4.Address.fromAddressOrString(recipient);
    const recipientDataArray = (0, import_ethers21.getBytesCopy)(
      "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = (0, import_ethers21.getBytesCopy)(
      "0x".concat((0, import_math17.bn)(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...(0, import_ethers21.getBytesCopy)(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const params = { script, gasPrice: minGasPrice, ...txParams };
    const request = new ScriptTransactionRequest(params);
    const forwardingQuantities = [{ amount: (0, import_math17.bn)(amount), assetId: import_configs10.BaseAssetId }];
    const { requiredQuantities, maxFee, gasUsed } = await this.provider.getTransactionCost(
      request,
      forwardingQuantities
    );
    request.gasLimit = (0, import_math17.bn)(params.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  async signMessage(message) {
    if (!this._connector) {
      throw new import_errors15.FuelError(import_errors15.ErrorCode.MISSING_CONNECTOR, "A connector is required to sign messages.");
    }
    return this._connector.signMessage(this.address.toString(), message);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike, options) {
    if (this._connector) {
      return this.provider.getTransactionResponse(
        await this._connector.sendTransaction(this.address.toString(), transactionRequestLike)
      );
    }
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(transactionRequest, {
      ...options,
      estimateTxDependencies: false
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
  }
  validateGas({
    gasUsed,
    gasPrice,
    gasLimit,
    minGasPrice
  }) {
    if (minGasPrice.gt(gasPrice)) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.GAS_PRICE_TOO_LOW,
        `Gas price '${gasPrice}' is lower than the required: '${minGasPrice}'.`
      );
    }
    if (gasUsed.gt(gasLimit)) {
      throw new import_errors15.FuelError(
        import_errors15.ErrorCode.GAS_LIMIT_TOO_LOW,
        `Gas limit '${gasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
  }
};

// src/wallet/base-wallet-unlocked.ts
var import_hasher3 = require("@fuel-ts/hasher");

// src/signer/signer.ts
var import_address5 = require("@fuel-ts/address");
var import_crypto = require("@fuel-ts/crypto");
var import_hasher2 = require("@fuel-ts/hasher");
var import_math18 = require("@fuel-ts/math");
var import_secp256k1 = require("@noble/curves/secp256k1");
var import_ethers22 = require("ethers");
var Signer = class {
  address;
  publicKey;
  compressedPublicKey;
  privateKey;
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(privateKey) {
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = (0, import_math18.toBytes)(privateKey, 32);
    this.privateKey = (0, import_ethers22.hexlify)(privateKeyBytes);
    this.publicKey = (0, import_ethers22.hexlify)(import_secp256k1.secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
    this.compressedPublicKey = (0, import_ethers22.hexlify)(import_secp256k1.secp256k1.getPublicKey(privateKeyBytes, true));
    this.address = import_address5.Address.fromPublicKey(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(data) {
    const signature = import_secp256k1.secp256k1.sign((0, import_ethers22.getBytesCopy)(data), (0, import_ethers22.getBytesCopy)(this.privateKey));
    const r = (0, import_math18.toBytes)(`0x${signature.r.toString(16)}`, 32);
    const s = (0, import_math18.toBytes)(`0x${signature.s.toString(16)}`, 32);
    s[0] |= (signature.recovery || 0) << 7;
    return (0, import_ethers22.concat)([r, s]);
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(point) {
    const p0 = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_ethers22.getBytesCopy)(this.compressedPublicKey));
    const p1 = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_ethers22.getBytesCopy)(point));
    const result = p0.add(p1);
    return `0x${result.toHex(true)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(data, signature) {
    const signedMessageBytes = (0, import_ethers22.getBytesCopy)(signature);
    const r = signedMessageBytes.slice(0, 32);
    const s = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s[0] & 128) >> 7;
    s[0] &= 127;
    const sig = new import_secp256k1.secp256k1.Signature(BigInt((0, import_ethers22.hexlify)(r)), BigInt((0, import_ethers22.hexlify)(s))).addRecoveryBit(
      recoveryParam
    );
    const publicKey = sig.recoverPublicKey((0, import_ethers22.getBytesCopy)(data)).toRawBytes(false).slice(1);
    return (0, import_ethers22.hexlify)(publicKey);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(data, signature) {
    return import_address5.Address.fromPublicKey(Signer.recoverPublicKey(data, signature));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(entropy) {
    return entropy ? (0, import_hasher2.hash)((0, import_ethers22.concat)([(0, import_crypto.randomBytes)(32), (0, import_ethers22.getBytesCopy)(entropy)])) : (0, import_crypto.randomBytes)(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(publicKey) {
    const point = import_secp256k1.secp256k1.ProjectivePoint.fromHex((0, import_ethers22.getBytesCopy)(publicKey));
    return (0, import_ethers22.hexlify)(point.toRawBytes(false).slice(1));
  }
};

// src/wallet/keystore-wallet.ts
var import_address6 = require("@fuel-ts/address");
var import_crypto2 = require("@fuel-ts/crypto");
var import_errors16 = require("@fuel-ts/errors");
var import_ethers23 = require("ethers");
var import_uuid = require("uuid");
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = (0, import_crypto2.bufferFromString)(removeHexPrefix(privateKey), "hex");
  const ownerAddress = import_address6.Address.fromAddressOrString(address);
  const salt = (0, import_crypto2.randomBytes)(DEFAULT_KEY_SIZE);
  const key = (0, import_crypto2.scrypt)({
    password: (0, import_crypto2.bufferFromString)(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = (0, import_crypto2.randomBytes)(DEFAULT_IV_SIZE);
  const ciphertext = await (0, import_crypto2.encryptJsonWalletData)(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = (0, import_crypto2.keccak256)(data);
  const mac = (0, import_crypto2.stringFromBuffer)(macHashUint8Array, "hex");
  const keystore = {
    id: (0, import_uuid.v4)(),
    version: 3,
    address: removeHexPrefix(ownerAddress.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: (0, import_crypto2.stringFromBuffer)(iv, "hex") },
      ciphertext: (0, import_crypto2.stringFromBuffer)(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: (0, import_crypto2.stringFromBuffer)(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = (0, import_crypto2.bufferFromString)(ciphertext, "hex");
  const ivBuffer = (0, import_crypto2.bufferFromString)(iv, "hex");
  const saltBuffer = (0, import_crypto2.bufferFromString)(salt, "hex");
  const passwordBuffer = (0, import_crypto2.bufferFromString)(password);
  const key = (0, import_crypto2.scrypt)({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = (0, import_crypto2.keccak256)(data);
  const macHash = (0, import_crypto2.stringFromBuffer)(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new import_errors16.FuelError(
      import_errors16.ErrorCode.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await (0, import_crypto2.decryptJsonWalletData)(ciphertextBuffer, key, ivBuffer);
  const privateKey = (0, import_ethers23.hexlify)(buffer);
  return privateKey;
}

// src/wallet/base-wallet-unlocked.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign((0, import_hasher3.hashMessage)(message));
    return signedMessage;
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = this.provider.getChain().consensusParameters.chainId.toNumber();
    const hashedTransaction = transactionRequest.getTransactionId(chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return signature;
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike, options) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      { ...options, estimateTxDependencies: false }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    await this.provider.estimateTxDependencies(transactionRequest);
    return this.provider.call(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true,
        estimateTxDependencies: false
      }
    );
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/hdwallet/hdwallet.ts
var import_errors19 = require("@fuel-ts/errors");
var import_math19 = require("@fuel-ts/math");
var import_ethers26 = require("ethers");

// src/mnemonic/mnemonic.ts
var import_crypto3 = require("@fuel-ts/crypto");
var import_errors18 = require("@fuel-ts/errors");
var import_ethers25 = require("ethers");

// src/wordlists/words/english.ts
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// src/wordlists/index.ts
var Language = /* @__PURE__ */ ((Language2) => {
  Language2["english"] = "english";
  return Language2;
})(Language || {});

// src/mnemonic/utils.ts
var import_errors17 = require("@fuel-ts/errors");
var import_ethers24 = require("ethers");
function toUtf8Bytes(stri) {
  const str = stri.normalize("NFKD");
  const result = [];
  for (let i = 0; i < str.length; i += 1) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) === 55296) {
      i += 1;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new import_errors17.FuelError(
          import_errors17.ErrorCode.INVALID_INPUT_PARAMETERS,
          "Invalid UTF-8 in the input string."
        );
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return Uint8Array.from(result);
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getWords(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
}
function getPhrase(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
}
function entropyToMnemonicIndices(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = (0, import_ethers24.getBytesCopy)((0, import_ethers24.sha256)(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
}
function mnemonicWordsToEntropy(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = (0, import_ethers24.getBytesCopy)(new Uint8Array(size));
  let offset = 0;
  for (let i = 0; i < words.length; i += 1) {
    const index = wordlist.indexOf(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new import_errors17.FuelError(
        import_errors17.ErrorCode.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
      );
    }
    for (let bit = 0; bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = (0, import_ethers24.getBytesCopy)((0, import_ethers24.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new import_errors17.FuelError(
      import_errors17.ErrorCode.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  }
  return entropy.slice(0, entropyBits / 8);
}

// src/mnemonic/mnemonic.ts
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
function assertWordList(wordlist) {
  if (wordlist.length !== 2048) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${wordlist.length}.`
    );
  }
}
function assertEntropy(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new import_errors18.FuelError(
      import_errors18.ErrorCode.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
    );
  }
}
function assertMnemonic(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
      ", "
    )}] words, but got ${words.length}.`;
    throw new import_errors18.FuelError(import_errors18.ErrorCode.INVALID_MNEMONIC, errorMsg);
  }
}
var Mnemonic = class {
  wordlist;
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(wordlist = english) {
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(phrase) {
    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(entropy) {
    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return (0, import_ethers25.hexlify)(mnemonicWordsToEntropy(words, wordlist));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = (0, import_ethers25.getBytesCopy)(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = toUtf8Bytes(getPhrase(phrase));
    const salt = toUtf8Bytes(`mnemonic${passphrase}`);
    return (0, import_ethers25.pbkdf2)(phraseBytes, salt, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
    return Mnemonic.masterKeysFromSeed(seed);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i < words.length) {
      if (Mnemonic.binarySearch(words[i]) === false) {
        return false;
      }
      i += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target) {
        return true;
      }
      if (target < words[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(seed) {
    const seedArray = (0, import_ethers25.getBytesCopy)(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new import_errors18.FuelError(
        import_errors18.ErrorCode.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
      );
    }
    return (0, import_ethers25.getBytesCopy)((0, import_ethers25.computeHmac)("sha512", MasterSecret, seedArray));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(seed, testnet = false) {
    const masterKey = Mnemonic.masterKeysFromSeed(seed);
    const prefix = (0, import_ethers25.getBytesCopy)(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = (0, import_ethers25.concat)([
      prefix,
      depth,
      fingerprint,
      index,
      chainCode,
      (0, import_ethers25.concat)(["0x00", privateKey])
    ]);
    const checksum = (0, import_ethers25.dataSlice)((0, import_ethers25.sha256)((0, import_ethers25.sha256)(extendedKey)), 0, 4);
    return (0, import_ethers25.encodeBase58)((0, import_ethers25.concat)([extendedKey, checksum]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? (0, import_ethers25.sha256)((0, import_ethers25.concat)([(0, import_crypto3.randomBytes)(size), (0, import_ethers25.getBytesCopy)(extraEntropy)])) : (0, import_crypto3.randomBytes)(size);
    return Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;

// src/hdwallet/hdwallet.ts
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = (0, import_ethers26.hexlify)("0x0488ade4");
var MainnetPUB = (0, import_ethers26.hexlify)("0x0488b21e");
var TestnetPRV2 = (0, import_ethers26.hexlify)("0x04358394");
var TestnetPUB = (0, import_ethers26.hexlify)("0x043587cf");
function base58check(data) {
  return (0, import_ethers26.encodeBase58)((0, import_ethers26.concat)([data, (0, import_ethers26.dataSlice)((0, import_ethers26.sha256)((0, import_ethers26.sha256)(data)), 0, 4)]));
}
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
}
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes((0, import_ethers26.hexlify)(extendedKey.slice(0, 4)));
}
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
    (0, import_ethers26.hexlify)(extendedKey.slice(0, 4))
  );
}
function parsePath(path, depth = 0) {
  const components = path.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, `invalid path - ${path}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
  );
}
var HDWallet = class {
  depth = 0;
  index = 0;
  fingerprint = (0, import_ethers26.hexlify)("0x00000000");
  parentFingerprint = (0, import_ethers26.hexlify)("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config) {
    if (config.privateKey) {
      const signer = new Signer(config.privateKey);
      this.publicKey = (0, import_ethers26.hexlify)(signer.compressedPublicKey);
      this.privateKey = (0, import_ethers26.hexlify)(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new import_errors19.FuelError(
          import_errors19.ErrorCode.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = (0, import_ethers26.hexlify)(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = (0, import_ethers26.dataSlice)((0, import_ethers26.ripemd160)((0, import_ethers26.sha256)(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && (0, import_ethers26.getBytesCopy)(this.privateKey);
    const publicKey = (0, import_ethers26.getBytesCopy)(this.publicKey);
    const chainCode = (0, import_ethers26.getBytesCopy)(this.chainCode);
    const data = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new import_errors19.FuelError(
          import_errors19.ErrorCode.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data.set(privateKey, 1);
    } else {
      data.set((0, import_ethers26.getBytesCopy)(this.publicKey));
    }
    data.set((0, import_math19.toBytes)(index, 4), 33);
    const bytes = (0, import_ethers26.getBytesCopy)((0, import_ethers26.computeHmac)("sha512", chainCode, data));
    const IL = bytes.slice(0, 32);
    const IR = bytes.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = (0, import_math19.bn)(IL).add(privateKey).mod(N).toBytes(32);
      return new HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new Signer((0, import_ethers26.hexlify)(IL));
    const Ki = signer.addPoint(publicKey);
    return new HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path) {
    const paths = parsePath(path, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = (0, import_ethers26.hexlify)(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = (0, import_math19.toHex)(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? (0, import_ethers26.concat)(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = (0, import_ethers26.getBytesCopy)(
      (0, import_ethers26.concat)([prefix, depth, parentFingerprint, index, chainCode, key])
    );
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed);
    return new HDWallet({
      chainCode: (0, import_ethers26.getBytesCopy)(masterKey.slice(32)),
      privateKey: (0, import_ethers26.getBytesCopy)(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = (0, import_ethers26.toBeHex)((0, import_ethers26.decodeBase58)(extendedKey));
    const bytes = (0, import_ethers26.getBytesCopy)(decoded);
    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;
    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {
      throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum) {
      throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    }
    const depth = bytes[4];
    const parentFingerprint = (0, import_ethers26.hexlify)(bytes.slice(5, 9));
    const index = parseInt((0, import_ethers26.hexlify)(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = (0, import_ethers26.hexlify)(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new import_errors19.FuelError(
        import_errors19.ErrorCode.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes)) {
      if (key[0] !== 3) {
        throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new import_errors19.FuelError(import_errors19.ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;

// src/wallet/wallets.ts
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this._provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer("0x00");
    return new WalletLocked(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, path, provider) {
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, path, passphrase, provider) {
    const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
/**
 * Create a Wallet Unlocked from an encrypted JSON.
 *
 * @param jsonWallet - The encrypted JSON keystore.
 * @param password - The password to decrypt the JSON.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

// src/wallet-manager/wallet-manager.ts
var import_address9 = require("@fuel-ts/address");
var import_crypto4 = require("@fuel-ts/crypto");
var import_errors22 = require("@fuel-ts/errors");
var import_events = require("events");

// src/wallet-manager/storages/memory-storage.ts
var MemoryStorage = class {
  storage = /* @__PURE__ */ new Map();
  async getItem(key) {
    const item = await this.storage.get(key);
    return item;
  }
  async setItem(key, value) {
    await this.storage.set(key, value);
  }
  async removeItem(key) {
    await this.storage.delete(key);
  }
  async clear() {
    await this.storage.clear();
  }
};

// src/wallet-manager/vaults/mnemonic-vault.ts
var import_address7 = require("@fuel-ts/address");
var import_errors20 = require("@fuel-ts/errors");
var _secret;
var MnemonicVault = class {
  constructor(options) {
    __privateAdd(this, _secret, void 0);
    __publicField(this, "pathKey", "{}");
    __publicField(this, "rootPath", `m/44'/1179993420'/${this.pathKey}'/0/0`);
    __publicField(this, "numberOfAccounts", 0);
    __privateSet(this, _secret, options.secret || mnemonic_default.generate());
    this.rootPath = options.rootPath || this.rootPath;
    this.numberOfAccounts = options.numberOfAccounts || 1;
  }
  getDerivePath(index) {
    if (this.rootPath.includes(this.pathKey)) {
      return this.rootPath.replace(this.pathKey, String(index));
    }
    return `${this.rootPath}/${index}`;
  }
  serialize() {
    return {
      secret: __privateGet(this, _secret),
      rootPath: this.rootPath,
      numberOfAccounts: this.numberOfAccounts
    };
  }
  getAccounts() {
    const accounts = [];
    let numberOfAccounts = 0;
    do {
      const wallet = Wallet.fromMnemonic(__privateGet(this, _secret), this.getDerivePath(numberOfAccounts));
      accounts.push({
        publicKey: wallet.publicKey,
        address: wallet.address
      });
      numberOfAccounts += 1;
    } while (numberOfAccounts < this.numberOfAccounts);
    return accounts;
  }
  addAccount() {
    this.numberOfAccounts += 1;
    const wallet = Wallet.fromMnemonic(__privateGet(this, _secret), this.getDerivePath(this.numberOfAccounts - 1));
    return {
      publicKey: wallet.publicKey,
      address: wallet.address
    };
  }
  exportAccount(address) {
    let numberOfAccounts = 0;
    const ownerAddress = import_address7.Address.fromAddressOrString(address);
    do {
      const wallet = Wallet.fromMnemonic(__privateGet(this, _secret), this.getDerivePath(numberOfAccounts));
      if (wallet.address.equals(ownerAddress)) {
        return wallet.privateKey;
      }
      numberOfAccounts += 1;
    } while (numberOfAccounts < this.numberOfAccounts);
    throw new import_errors20.FuelError(
      import_errors20.ErrorCode.WALLET_MANAGER_ERROR,
      `Account with address '${address}' not found in derived wallets.`
    );
  }
  getWallet(address) {
    const privateKey = this.exportAccount(address);
    return Wallet.fromPrivateKey(privateKey);
  }
};
_secret = new WeakMap();
__publicField(MnemonicVault, "type", "mnemonic");

// src/wallet-manager/vaults/privatekey-vault.ts
var import_address8 = require("@fuel-ts/address");
var import_errors21 = require("@fuel-ts/errors");
var _privateKeys;
var PrivateKeyVault = class {
  /**
   * If privateKey vault is initialized with a secretKey, it creates
   * one account with the fallowing secret
   */
  constructor(options = {}) {
    __privateAdd(this, _privateKeys, []);
    if (options.secret) {
      __privateSet(this, _privateKeys, [options.secret]);
    } else {
      __privateSet(this, _privateKeys, options.accounts || [Wallet.generate().privateKey]);
    }
  }
  serialize() {
    return {
      accounts: __privateGet(this, _privateKeys)
    };
  }
  getPublicAccount(privateKey) {
    const wallet = Wallet.fromPrivateKey(privateKey);
    return {
      address: wallet.address,
      publicKey: wallet.publicKey
    };
  }
  getAccounts() {
    return __privateGet(this, _privateKeys).map((pk) => this.getPublicAccount(pk));
  }
  addAccount() {
    const wallet = Wallet.generate();
    __privateGet(this, _privateKeys).push(wallet.privateKey);
    return this.getPublicAccount(wallet.privateKey);
  }
  exportAccount(address) {
    const ownerAddress = import_address8.Address.fromAddressOrString(address);
    const privateKey = __privateGet(this, _privateKeys).find(
      (pk) => Wallet.fromPrivateKey(pk).address.equals(ownerAddress)
    );
    if (!privateKey) {
      throw new import_errors21.FuelError(
        import_errors21.ErrorCode.WALLET_MANAGER_ERROR,
        `No private key found for address '${address}'.`
      );
    }
    return privateKey;
  }
  getWallet(address) {
    const privateKey = this.exportAccount(address);
    return Wallet.fromPrivateKey(privateKey);
  }
};
_privateKeys = new WeakMap();
__publicField(PrivateKeyVault, "type", "privateKey");

// src/wallet-manager/wallet-manager.ts
var ERROR_MESSAGES = {
  invalid_vault_type: "The provided Vault type is invalid.",
  address_not_found: "No private key found for address the specified wallet address.",
  vault_not_found: "The specified vault was not found.",
  wallet_not_unlocked: "The wallet is currently locked.",
  passphrase_not_match: "The provided passphrase did not match the expected value."
};
function assert(condition, message) {
  if (!condition) {
    throw new import_errors22.FuelError(import_errors22.ErrorCode.WALLET_MANAGER_ERROR, message);
  }
}
var _vaults, _passphrase, _isLocked, _serializeVaults, serializeVaults_fn, _deserializeVaults, deserializeVaults_fn;
var _WalletManager = class extends import_events.EventEmitter {
  constructor(options) {
    super();
    /**
     * Serialize all vaults to store
     *
     * `This is only accessible from inside the class`
     */
    __privateAdd(this, _serializeVaults);
    /**
     * Deserialize all vaults to state
     *
     * `This is only accessible from inside the class`
     */
    __privateAdd(this, _deserializeVaults);
    /**
     * Storage
     *
     * Persistent encrypted data. `The default storage works only on memory`.
     */
    __publicField(this, "storage", new MemoryStorage());
    /* Key name passed to the storage */
    __publicField(this, "STORAGE_KEY", "WalletManager");
    // `This variables are only accessible from inside the class`
    __privateAdd(this, _vaults, []);
    __privateAdd(this, _passphrase, "");
    __privateAdd(this, _isLocked, true);
    this.storage = options?.storage || this.storage;
  }
  get isLocked() {
    return __privateGet(this, _isLocked);
  }
  /**
   * Return the vault serialized object containing all the privateKeys,
   * the format of the return depends on the Vault type.
   */
  exportVault(vaultId) {
    assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const vaultState = __privateGet(this, _vaults).find((_, idx) => idx === vaultId);
    assert(vaultState, ERROR_MESSAGES.vault_not_found);
    return vaultState.vault.serialize();
  }
  /**
   * List all vaults on the Wallet Manager, this function not return secret's
   */
  getVaults() {
    return __privateGet(this, _vaults).map((v, idx) => ({
      title: v.title,
      type: v.type,
      vaultId: idx
    }));
  }
  /**
   * List all accounts on the Wallet Manager not vault information is revealed
   */
  getAccounts() {
    return __privateGet(this, _vaults).flatMap(
      (vaultState, vaultId) => vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))
    );
  }
  /**
   * Create a Wallet instance for the specific account
   */
  getWallet(address) {
    const ownerAddress = import_address9.Address.fromAddressOrString(address);
    const vaultState = __privateGet(this, _vaults).find(
      (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
    );
    assert(vaultState, ERROR_MESSAGES.address_not_found);
    return vaultState.vault.getWallet(ownerAddress);
  }
  /**
   * Export specific account privateKey
   */
  exportPrivateKey(address) {
    const ownerAddress = import_address9.Address.fromAddressOrString(address);
    assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const vaultState = __privateGet(this, _vaults).find(
      (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))
    );
    assert(vaultState, ERROR_MESSAGES.address_not_found);
    return vaultState.vault.exportAccount(ownerAddress);
  }
  /**
   * Add account to a selected vault or on the first vault as default.
   * If not vaults are adds it will return error
   */
  async addAccount(options) {
    await this.loadState();
    const vaultState = __privateGet(this, _vaults)[options?.vaultId || 0];
    await assert(vaultState, ERROR_MESSAGES.vault_not_found);
    const account = vaultState.vault.addAccount();
    await this.saveState();
    return account;
  }
  /**
   * Remove vault by index, by remove the vault you also remove all accounts
   * created by the vault.
   */
  async removeVault(index) {
    __privateGet(this, _vaults).splice(index, 1);
    await this.saveState();
  }
  /**
   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if
   * didn't found it will throw.
   */
  async addVault(vaultConfig) {
    await this.loadState();
    const Vault2 = this.getVaultClass(vaultConfig.type);
    const vault = new Vault2(vaultConfig);
    __privateSet(this, _vaults, __privateGet(this, _vaults).concat({
      title: vaultConfig.title,
      type: vaultConfig.type,
      vault
    }));
    await this.saveState();
  }
  /**
   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and
   * secrets.
   */
  lock() {
    __privateSet(this, _isLocked, true);
    __privateSet(this, _vaults, []);
    __privateSet(this, _passphrase, "");
    this.emit("lock");
  }
  /**
   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.
   * Vaults with secrets are not unlocked or instantiated on this moment.
   */
  async unlock(passphrase) {
    __privateSet(this, _passphrase, passphrase);
    __privateSet(this, _isLocked, false);
    try {
      await this.loadState();
      this.emit("unlock");
    } catch (err) {
      await this.lock();
      throw err;
    }
  }
  /**
   * Update WalletManager encryption passphrase
   */
  async updatePassphrase(oldpass, newpass) {
    const isLocked = __privateGet(this, _isLocked);
    await this.unlock(oldpass);
    __privateSet(this, _passphrase, newpass);
    await this.saveState();
    await this.loadState();
    if (isLocked) {
      await this.lock();
    }
  }
  /**
   * Retrieve and decrypt WalletManager state from storage
   */
  async loadState() {
    await assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const data = await this.storage.getItem(this.STORAGE_KEY);
    if (data) {
      const state = await (0, import_crypto4.decrypt)(__privateGet(this, _passphrase), JSON.parse(data));
      __privateSet(this, _vaults, __privateMethod(this, _deserializeVaults, deserializeVaults_fn).call(this, state.vaults));
    }
  }
  /**
   * Store encrypted WalletManager state on storage
   */
  async saveState() {
    await assert(!__privateGet(this, _isLocked), ERROR_MESSAGES.wallet_not_unlocked);
    const encryptedData = await (0, import_crypto4.encrypt)(__privateGet(this, _passphrase), {
      vaults: __privateMethod(this, _serializeVaults, serializeVaults_fn).call(this, __privateGet(this, _vaults))
    });
    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));
    this.emit("update");
  }
  /**
   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.
   */
  getVaultClass(type) {
    const VaultClass = _WalletManager.Vaults.find((v) => v.type === type);
    assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);
    return VaultClass;
  }
};
var WalletManager = _WalletManager;
_vaults = new WeakMap();
_passphrase = new WeakMap();
_isLocked = new WeakMap();
_serializeVaults = new WeakSet();
serializeVaults_fn = function(vaults) {
  return vaults.map(({ title, type, vault }) => ({
    title,
    type,
    data: vault.serialize()
  }));
};
_deserializeVaults = new WeakSet();
deserializeVaults_fn = function(vaults) {
  return vaults.map(({ title, type, data: vaultConfig }) => {
    const VaultClass = this.getVaultClass(type);
    return {
      title,
      type,
      vault: new VaultClass(vaultConfig)
    };
  });
};
/**
 * Vaults
 *
 * Vaults are responsible to store secret keys and return an `Wallet` instance,
 * to interact with the network.
 *
 * Each vault has access to its own state
 *
 */
__publicField(WalletManager, "Vaults", [MnemonicVault, PrivateKeyVault]);

// src/wallet-manager/types.ts
var import_errors23 = require("@fuel-ts/errors");
var Vault = class {
  constructor(_options) {
    throw new import_errors23.FuelError(import_errors23.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  serialize() {
    throw new import_errors23.FuelError(import_errors23.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  getAccounts() {
    throw new import_errors23.FuelError(import_errors23.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  addAccount() {
    throw new import_errors23.FuelError(import_errors23.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  exportAccount(_address) {
    throw new import_errors23.FuelError(import_errors23.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
  getWallet(_address) {
    throw new import_errors23.FuelError(import_errors23.ErrorCode.NOT_IMPLEMENTED, "Not implemented.");
  }
};
__publicField(Vault, "type");
var StorageAbstract = class {
};

// src/predicate/predicate.ts
var import_abi_coder5 = require("@fuel-ts/abi-coder");
var import_address10 = require("@fuel-ts/address");
var import_configs11 = require("@fuel-ts/address/configs");
var import_errors24 = require("@fuel-ts/errors");
var import_transactions19 = require("@fuel-ts/transactions");
var import_ethers28 = require("ethers");

// src/predicate/utils/getPredicateRoot.ts
var import_hasher4 = require("@fuel-ts/hasher");
var import_merkle = require("@fuel-ts/merkle");
var import_utils7 = require("@fuel-ts/utils");
var import_ethers27 = require("ethers");
var getPredicateRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes = (0, import_ethers27.getBytesCopy)(bytecode);
  const chunks = (0, import_utils7.chunkAndPadBytes)(bytes, chunkSize);
  const codeRoot = (0, import_merkle.calcRoot)(chunks.map((c) => (0, import_ethers27.hexlify)(c)));
  const predicateRoot = (0, import_hasher4.hash)((0, import_ethers27.concat)(["0x4655454C", codeRoot]));
  return predicateRoot;
};

// src/predicate/predicate.ts
var Predicate = class extends Account {
  bytes;
  predicateData = Uint8Array.from([]);
  predicateArgs = [];
  interface;
  /**
   * Creates an instance of the Predicate class.
   *
   * @param bytes - The bytes of the predicate.
   * @param provider - The provider used to interact with the blockchain.
   * @param jsonAbi - The JSON ABI of the predicate.
   * @param configurableConstants - Optional configurable constants for the predicate.
   */
  constructor(bytes, provider, jsonAbi, configurableConstants) {
    const { predicateBytes, predicateInterface } = Predicate.processPredicateData(
      bytes,
      jsonAbi,
      configurableConstants
    );
    const address = import_address10.Address.fromB256(getPredicateRoot(predicateBytes));
    super(address, provider);
    this.bytes = predicateBytes;
    this.interface = predicateInterface;
  }
  /**
   * Populates the transaction data with predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns The transaction request with predicate data.
   */
  populateTransactionPredicateData(transactionRequestLike) {
    const request = transactionRequestify(transactionRequestLike);
    const { policies } = BaseTransactionRequest.getPolicyMeta(request);
    request.inputs?.forEach((input) => {
      if (input.type === import_transactions19.InputType.Coin && (0, import_ethers28.hexlify)(input.owner) === this.address.toB256()) {
        input.predicate = this.bytes;
        input.predicateData = this.getPredicateData(policies.length);
      }
    });
    return request;
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId = import_configs11.BaseAssetId, txParams = {}) {
    const request = await super.createTransfer(destination, amount, assetId, txParams);
    return this.populateTransactionPredicateData(request);
  }
  /**
   * Sends a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the transaction response.
   */
  sendTransaction(transactionRequestLike, options) {
    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);
    return super.sendTransaction(transactionRequest, options);
  }
  /**
   * Simulates a transaction with the populated predicate data.
   *
   * @param transactionRequestLike - The transaction request-like object.
   * @returns A promise that resolves to the call result.
   */
  simulateTransaction(transactionRequestLike) {
    const transactionRequest = this.populateTransactionPredicateData(transactionRequestLike);
    return super.simulateTransaction(transactionRequest);
  }
  /**
   * Sets data for the predicate.
   *
   * @param args - Arguments for the predicate function.
   * @returns The Predicate instance with updated predicate data.
   */
  setData(...args) {
    this.predicateArgs = args;
    return this;
  }
  getPredicateData(policiesLength) {
    if (!this.predicateArgs.length) {
      return new Uint8Array();
    }
    const mainFn = this.interface?.functions.main;
    const paddedCode = new import_transactions19.ByteArrayCoder(this.bytes.length).encode(this.bytes);
    const VM_TX_MEMORY = (0, import_abi_coder5.calculateVmTxMemory)({
      maxInputs: this.provider.getChain().consensusParameters.maxInputs.toNumber()
    });
    const OFFSET = VM_TX_MEMORY + import_abi_coder5.SCRIPT_FIXED_SIZE + import_abi_coder5.INPUT_COIN_FIXED_SIZE + import_abi_coder5.WORD_SIZE + paddedCode.byteLength + policiesLength * import_abi_coder5.WORD_SIZE;
    return mainFn?.encodeArguments(this.predicateArgs, OFFSET) || new Uint8Array();
  }
  /**
   * Processes the predicate data and returns the altered bytecode and interface.
   *
   * @param bytes - The bytes of the predicate.
   * @param jsonAbi - The JSON ABI of the predicate.
   * @param configurableConstants - Optional configurable constants for the predicate.
   * @returns An object containing the new predicate bytes and interface.
   */
  static processPredicateData(bytes, jsonAbi, configurableConstants) {
    let predicateBytes = (0, import_ethers28.getBytesCopy)(bytes);
    let abiInterface;
    if (jsonAbi) {
      abiInterface = new import_abi_coder5.Interface(jsonAbi);
      if (abiInterface.functions.main === void 0) {
        throw new import_errors24.FuelError(
          import_errors24.ErrorCode.ABI_MAIN_METHOD_MISSING,
          'Cannot use ABI without "main" function.'
        );
      }
    }
    if (configurableConstants && Object.keys(configurableConstants).length) {
      predicateBytes = Predicate.setConfigurableConstants(
        predicateBytes,
        configurableConstants,
        abiInterface
      );
    }
    return {
      predicateBytes,
      predicateInterface: abiInterface
    };
  }
  /**
   * Sets the configurable constants for the predicate.
   *
   * @param bytes - The bytes of the predicate.
   * @param configurableConstants - Configurable constants to be set.
   * @param abiInterface - The ABI interface of the predicate.
   * @returns The mutated bytes with the configurable constants set.
   */
  static setConfigurableConstants(bytes, configurableConstants, abiInterface) {
    const mutatedBytes = bytes;
    try {
      if (!abiInterface) {
        throw new Error(
          "Cannot validate configurable constants because the Predicate was instantiated without a JSON ABI"
        );
      }
      if (Object.keys(abiInterface.configurables).length === 0) {
        throw new Error("Predicate has no configurable constants to be set");
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!abiInterface?.configurables[key]) {
          throw new Error(`No configurable constant named '${key}' found in the Predicate`);
        }
        const { offset } = abiInterface.configurables[key];
        const encoded = abiInterface.encodeConfigurable(key, value);
        mutatedBytes.set(encoded, offset);
      });
    } catch (err) {
      throw new import_errors24.FuelError(
        import_errors24.ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants: ${err.message}.`
      );
    }
    return mutatedBytes;
  }
};

// src/connectors/fuel-connector.ts
var import_events2 = require("events");

// src/connectors/types/connector-types.ts
var FuelConnectorMethods = /* @__PURE__ */ ((FuelConnectorMethods2) => {
  FuelConnectorMethods2["ping"] = "ping";
  FuelConnectorMethods2["version"] = "version";
  FuelConnectorMethods2["connect"] = "connect";
  FuelConnectorMethods2["disconnect"] = "disconnect";
  FuelConnectorMethods2["isConnected"] = "isConnected";
  FuelConnectorMethods2["accounts"] = "accounts";
  FuelConnectorMethods2["currentAccount"] = "currentAccount";
  FuelConnectorMethods2["signMessage"] = "signMessage";
  FuelConnectorMethods2["sendTransaction"] = "sendTransaction";
  FuelConnectorMethods2["assets"] = "assets";
  FuelConnectorMethods2["addAsset"] = "addAsset";
  FuelConnectorMethods2["addAssets"] = "addAssets";
  FuelConnectorMethods2["networks"] = "networks";
  FuelConnectorMethods2["currentNetwork"] = "currentNetwork";
  FuelConnectorMethods2["addNetwork"] = "addNetwork";
  FuelConnectorMethods2["selectNetwork"] = "selectNetwork";
  FuelConnectorMethods2["addABI"] = "addABI";
  FuelConnectorMethods2["getABI"] = "getABI";
  FuelConnectorMethods2["hasABI"] = "hasABI";
  return FuelConnectorMethods2;
})(FuelConnectorMethods || {});
var FuelConnectorEventTypes = /* @__PURE__ */ ((FuelConnectorEventTypes2) => {
  FuelConnectorEventTypes2["connectors"] = "connectors";
  FuelConnectorEventTypes2["currentConnector"] = "currentConnector";
  FuelConnectorEventTypes2["connection"] = "connection";
  FuelConnectorEventTypes2["accounts"] = "accounts";
  FuelConnectorEventTypes2["currentAccount"] = "currentAccount";
  FuelConnectorEventTypes2["networks"] = "networks";
  FuelConnectorEventTypes2["currentNetwork"] = "currentNetwork";
  FuelConnectorEventTypes2["assets"] = "assets";
  FuelConnectorEventTypes2["abis"] = "abis";
  return FuelConnectorEventTypes2;
})(FuelConnectorEventTypes || {});
var FuelConnectorEventType = "FuelConnector";

// src/connectors/types/data-type.ts
var MessageTypes = /* @__PURE__ */ ((MessageTypes2) => {
  MessageTypes2["ping"] = "ping";
  MessageTypes2["uiEvent"] = "uiEvent";
  MessageTypes2["event"] = "event";
  MessageTypes2["request"] = "request";
  MessageTypes2["response"] = "response";
  MessageTypes2["removeConnection"] = "removeConnection";
  return MessageTypes2;
})(MessageTypes || {});

// src/connectors/types/local-storage.ts
var LocalStorage = class {
  storage;
  constructor(localStorage) {
    this.storage = localStorage;
  }
  async setItem(key, value) {
    this.storage.setItem(key, value);
  }
  async getItem(key) {
    return this.storage.getItem(key);
  }
  async removeItem(key) {
    this.storage.removeItem(key);
  }
  async clear() {
    this.storage.clear();
  }
};

// src/connectors/fuel-connector.ts
var FuelConnector = class extends import_events2.EventEmitter {
  name = "";
  metadata = {};
  connected = false;
  installed = false;
  events = FuelConnectorEventTypes;
  /**
   * Should return true if the connector is loaded
   * in less then one second.
   *
   * @returns Always true.
   */
  async ping() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the current version of the connector
   * and the network version that is compatible.
   *
   * @returns boolean - connection status.
   */
  async version() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return true if the connector is connected
   * to any of the accounts available.
   *
   * @returns The connection status.
   */
  async isConnected() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return all the accounts authorized for the
   * current connection.
   *
   * @returns The accounts addresses strings
   */
  async accounts() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the connection process and return
   * true if the account authorize the connection.
   *
   * and return false if the user reject the connection.
   *
   * @emits accounts
   * @returns boolean - connection status.
   */
  async connect() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should disconnect the current connection and
   * return false if the disconnection was successful.
   *
   * @emits assets connection
   * @returns The connection status.
   */
  async disconnect() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the sign message process and return
   * the signed message.
   *
   * @param address - The address to sign the message
   * @param message - The message to sign all text will be treated as text utf-8
   *
   * @returns Message signature
   */
  async signMessage(_address, _message) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the send transaction process and return
   * the transaction id submitted to the network.
   *
   * If the network is not available for the connection
   * it should throw an error to avoid the transaction
   * to be sent to the wrong network and lost.
   *
   * @param address - The address to sign the transaction
   * @param transaction - The transaction to send
   *
   * @returns The transaction id
   */
  async sendTransaction(_address, _transaction) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the current account selected inside the connector, if the account
   * is authorized for the connection.
   *
   * If the account is not authorized it should return null.
   *
   * @returns The current account selected otherwise null.
   */
  async currentAccount() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should add the the assets metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param assets - The assets to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAssets(_assets) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should add the the asset metadata to the connector and return true if the asset
   * was added successfully.
   *
   * If the asset already exists it should throw an error.
   *
   * @emits assets
   * @param asset - The asset to add the metadata to the connection.
   * @throws Error if the asset already exists
   * @returns True if the asset was added successfully
   */
  async addAsset(_asset) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return all the assets added to the connector. If a connection is already established.
   *
   * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.
   */
  async assets() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the add network process and return true if the network was added successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param networkUrl - The URL of the network to be added.
   * @returns Return true if the network was added successfully
   */
  async addNetwork(_networkUrl) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should start the select network process and return true if the network has change successfully.
   *
   * @emits networks
   * @throws Error if the network already exists
   * @param network - The network to be selected.
   * @returns Return true if the network was added successfully
   */
  async selectNetwork(_network) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return all the networks available from the connector. If the connection is already established.
   *
   * @returns Return all the networks added to the connector.
   */
  async networks() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the current network selected inside the connector. Even if the connection is not established.
   *
   * @returns Return the current network selected inside the connector.
   */
  async currentNetwork() {
    throw new Error("Method not implemented.");
  }
  /**
   * Should add the ABI to the connector and return true if the ABI was added successfully.
   *
   * @param contractId - The contract id to add the ABI.
   * @param abi - The JSON ABI that represents a contract.
   * @returns Return true if the ABI was added successfully.
   */
  async addABI(_contractId, _abi) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the ABI.
   * @returns The ABI if it exists, otherwise return null.
   */
  async getABI(_id) {
    throw new Error("Method not implemented.");
  }
  /**
   * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.
   *
   * @param id - The contract id to get the abi
   * @returns Returns true if the abi exists or false if not.
   */
  async hasABI(_id) {
    throw new Error("Method not implemented.");
  }
  /**
   * Event listener for the connector.
   *
   * @param eventName - The event name to listen
   * @param listener - The listener function
   */
  on(eventName, listener) {
    super.on(eventName, listener);
    return this;
  }
};

// src/connectors/utils/cache.ts
function cacheFor(fn, { cache: cache2, cacheTime, key }) {
  return async (...args) => {
    if (cache2[key] && cache2[key]?.value) {
      return cache2[key]?.value;
    }
    clearTimeout(cache2[key]?.timeout);
    const result = await fn(...args);
    cache2[key] = {
      timeout: Number(
        setTimeout(() => {
          cache2[key] = null;
        }, cacheTime)
      ),
      value: result
    };
    return result;
  };
}

// src/connectors/utils/dispatch-fuel-connector-event.ts
function dispatchFuelConnectorEvent(connector) {
  window.dispatchEvent(
    new CustomEvent(FuelConnectorEventType, {
      detail: connector
    })
  );
}

// src/connectors/utils/promises.ts
function deferPromise() {
  const defer = {};
  defer.promise = new Promise((resolve, reject) => {
    defer.reject = reject;
    defer.resolve = resolve;
  });
  return defer;
}
async function withTimeout(promise, timeout = 1050) {
  const timeoutPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error("Promise timed out"));
    }, timeout);
  });
  return Promise.race([timeoutPromise, promise]);
}

// src/connectors/fuel.ts
var HAS_CONNECTOR_TIMEOUT = 2e3;
var PING_CACHE_TIME = 5e3;
var _Fuel = class extends FuelConnector {
  _storage = null;
  _connectors = [];
  _targetObject = null;
  _unsubscribes = [];
  _targetUnsubscribe;
  _pingCache = {};
  _currentConnector;
  constructor(config = _Fuel.defaultConfig) {
    super();
    this.setMaxListeners(1e3);
    this._connectors = config.connectors ?? [];
    this._targetObject = this.getTargetObject(config.targetObject);
    this._storage = config.storage === void 0 ? this.getStorage() : config.storage;
    this.setupMethods();
    this.setDefaultConnector();
    this._targetUnsubscribe = this.setupConnectorListener();
  }
  /**
   * Return the target object to listen for global events.
   */
  getTargetObject(targetObject) {
    if (targetObject) {
      return targetObject;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof document !== "undefined") {
      return document;
    }
    return null;
  }
  /**
   * Return the storage used.
   */
  getStorage() {
    if (typeof window !== "undefined") {
      return new LocalStorage(window.localStorage);
    }
    return void 0;
  }
  /**
   * Setup the default connector from the storage.
   */
  async setDefaultConnector() {
    const connectorName = await this._storage?.getItem(_Fuel.STORAGE_KEY) || this._connectors[0]?.name;
    if (connectorName) {
      return this.selectConnector(connectorName, {
        emitEvents: false
      });
    }
    return void 0;
  }
  /**
   * Start listener for all the events of the current
   * connector and emit them to the Fuel instance
   */
  setupConnectorEvents(events) {
    if (!this._currentConnector) {
      return;
    }
    const currentConnector = this._currentConnector;
    this._unsubscribes.map((unSub) => unSub());
    this._unsubscribes = events.map((event) => {
      const handler = (...args) => this.emit(event, ...args);
      currentConnector.on(event, handler);
      return () => currentConnector.off(event, handler);
    });
  }
  /**
   * Call method from the current connector.
   */
  async callMethod(method, ...args) {
    const hasConnector = await this.hasConnector();
    await this.pingConnector();
    if (!this._currentConnector || !hasConnector) {
      throw new Error(
        `No connector selected for calling ${method}. Use hasConnector before executing other methods.`
      );
    }
    if (typeof this._currentConnector[method] === "function") {
      return this._currentConnector[method](...args);
    }
    return void 0;
  }
  /**
   * Create a method for each method proxy that is available on the Common interface
   * and call the method from the current connector.
   */
  setupMethods() {
    Object.values(FuelConnectorMethods).forEach((method) => {
      this[method] = async (...args) => this.callMethod(method, ...args);
    });
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status.
   */
  async fetchConnectorStatus(connector) {
    const requestTimestamp = Date.now();
    const [isConnected, ping] = await Promise.allSettled([
      withTimeout(connector.isConnected()),
      withTimeout(this.pingConnector(connector))
    ]);
    const isStale = requestTimestamp < (connector._latestUpdate || 0);
    if (!isStale) {
      connector._latestUpdate = Date.now();
      connector.installed = ping.status === "fulfilled" && ping.value;
      connector.connected = isConnected.status === "fulfilled" && isConnected.value;
    }
    return {
      installed: connector.installed,
      connected: connector.connected
    };
  }
  /**
   * Fetch the status of all connectors and set the installed and connected
   * status.
   */
  async fetchConnectorsStatus() {
    return Promise.all(
      this._connectors.map(async (connector) => this.fetchConnectorStatus(connector))
    );
  }
  /**
   * Fetch the status of a connector and set the installed and connected
   * status. If no connector is provided it will ping the current connector.
   */
  async pingConnector(connector) {
    const curConnector = connector || this._currentConnector;
    if (!curConnector) {
      return false;
    }
    try {
      return await cacheFor(async () => withTimeout(curConnector.ping()), {
        key: curConnector.name,
        cache: this._pingCache,
        cacheTime: PING_CACHE_TIME
      })();
    } catch {
      throw new Error("Current connector is not available.");
    }
  }
  /**
   * Setup a listener for the FuelConnector event and add the connector
   * to the list of new connectors.
   */
  setupConnectorListener = () => {
    const { _targetObject: targetObject } = this;
    const eventName = FuelConnectorEventType;
    if (targetObject?.on) {
      targetObject.on(eventName, this.addConnector);
      return () => {
        targetObject.off?.(eventName, this.addConnector);
      };
    }
    if (targetObject?.addEventListener) {
      const handler = (e) => {
        this.addConnector(e.detail);
      };
      targetObject.addEventListener(eventName, handler);
      return () => {
        targetObject.removeEventListener?.(eventName, handler);
      };
    }
    return () => {
    };
  };
  /**
   * Add a new connector to the list of connectors.
   */
  addConnector = async (connector) => {
    if (!this.getConnector(connector)) {
      this._connectors.push(connector);
    }
    await this.fetchConnectorStatus(connector);
    this.emit(this.events.connectors, this._connectors);
    if (!this._currentConnector) {
      await this.selectConnector(connector.name, {
        emitEvents: false
      });
    }
  };
  triggerConnectorEvents = async () => {
    const [isConnected, networks, currentNetwork] = await Promise.all([
      this.isConnected(),
      this.networks(),
      this.currentNetwork()
    ]);
    this.emit(this.events.connection, isConnected);
    this.emit(this.events.networks, networks);
    this.emit(this.events.currentNetwork, currentNetwork);
    if (isConnected) {
      const [accounts, currentAccount] = await Promise.all([
        this.accounts(),
        this.currentAccount()
      ]);
      this.emit(this.events.accounts, accounts);
      this.emit(this.events.currentAccount, currentAccount);
    }
  };
  /**
   * Get a connector from the list of connectors.
   */
  getConnector = (connector) => this._connectors.find((c) => {
    const connectorName = typeof connector === "string" ? connector : connector.name;
    return c.name === connectorName || c === connector;
  }) || null;
  /**
   * Return the list of connectors with the status of installed and connected.
   */
  async connectors() {
    await this.fetchConnectorsStatus();
    return this._connectors;
  }
  /**
   * Set the current connector to be used.
   */
  async selectConnector(connectorName, options = {
    emitEvents: true
  }) {
    const connector = this.getConnector(connectorName);
    if (!connector) {
      return false;
    }
    if (this._currentConnector?.name === connectorName) {
      return true;
    }
    const { installed } = await this.fetchConnectorStatus(connector);
    if (installed) {
      this._currentConnector = connector;
      this.emit(this.events.currentConnector, connector);
      this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));
      await this._storage?.setItem(_Fuel.STORAGE_KEY, connector.name);
      if (options.emitEvents) {
        this.triggerConnectorEvents();
      }
      return true;
    }
    return false;
  }
  /**
   * Return the current selected connector.
   */
  currentConnector() {
    return this._currentConnector;
  }
  /**
   * Return true if any connector is available.
   */
  async hasConnector() {
    if (this._currentConnector) {
      return true;
    }
    const defer = deferPromise();
    this.once(this.events.currentConnector, () => {
      defer.resolve(true);
    });
    return withTimeout(defer.promise, HAS_CONNECTOR_TIMEOUT).then(() => true).catch(() => false);
  }
  async hasWallet() {
    return this.hasConnector();
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   *
   * @deprecated Provider is going to be deprecated in the future.
   */
  async getProvider(providerOrNetwork) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(
        "Get provider is deprecated, use getWallet instead. Provider is going to be removed in the future."
      );
    }
    return this._getProvider(providerOrNetwork);
  }
  /**
   * Return a Fuel Provider instance with extends features to work with
   * connectors.
   */
  async _getProvider(providerOrNetwork) {
    let provider;
    if (providerOrNetwork && "getTransactionResponse" in providerOrNetwork) {
      provider = providerOrNetwork;
    } else if (providerOrNetwork && "chainId" in providerOrNetwork && "url" in providerOrNetwork) {
      provider = await Provider.create(providerOrNetwork.url);
    } else if (!providerOrNetwork) {
      const currentNetwork = await this.currentNetwork();
      provider = await Provider.create(currentNetwork.url);
    } else {
      throw new Error("Provider is not valid.");
    }
    return provider;
  }
  /**
   * Return a Fuel Wallet Locked instance with extends features to work with
   * connectors.
   */
  async getWallet(address, providerOrNetwork) {
    const provider = await this._getProvider(providerOrNetwork);
    return new Account(address, provider, this);
  }
  /**
   * Remove all open listeners this is useful when you want to
   * remove the Fuel instance and avoid memory leaks.
   */
  unsubscribe() {
    this._unsubscribes.map((unSub) => unSub());
    this._targetUnsubscribe();
    this.removeAllListeners();
  }
  /**
   * Clean all the data from the storage.
   */
  async clean() {
    await this._storage?.removeItem(_Fuel.STORAGE_KEY);
  }
  /**
   * Removes all listeners and cleans the storage.
   */
  async destroy() {
    this.unsubscribe();
    await this.clean();
  }
};
var Fuel = _Fuel;
__publicField(Fuel, "STORAGE_KEY", "fuel-current-connector");
__publicField(Fuel, "defaultConfig", {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  AddressType,
  BaseTransactionRequest,
  BaseWalletUnlocked,
  ChainName,
  ChangeOutputCollisionError,
  CreateTransactionRequest,
  Fuel,
  FuelConnector,
  FuelConnectorEventType,
  FuelConnectorEventTypes,
  FuelConnectorMethods,
  HDWallet,
  Language,
  LocalStorage,
  MNEMONIC_SIZES,
  MemoryStorage,
  MessageTypes,
  Mnemonic,
  MnemonicVault,
  NoWitnessAtIndexError,
  NoWitnessByOwnerError,
  OperationName,
  Predicate,
  PrivateKeyVault,
  Provider,
  ScriptTransactionRequest,
  Signer,
  StorageAbstract,
  TransactionResponse,
  TransactionStatus,
  TransactionType,
  TransactionTypeName,
  Vault,
  Wallet,
  WalletLocked,
  WalletManager,
  WalletUnlocked,
  addAmountToAsset,
  addOperation,
  assembleReceiptByType,
  assembleTransactionSummary,
  buildBlockExplorerUrl,
  cacheFor,
  calculateMetadataGasForTxCreate,
  calculateMetadataGasForTxScript,
  calculatePriceWithFactor,
  calculateTransactionFee,
  coinQuantityfy,
  deferPromise,
  dispatchFuelConnectorEvent,
  english,
  extractBurnedAssetsFromReceipts,
  extractMintedAssetsFromReceipts,
  fromDateToTai64,
  fromTai64ToDate,
  fromTai64ToUnix,
  fromUnixToTai64,
  gasUsedByInputs,
  getContractCallOperations,
  getContractCreatedOperations,
  getContractTransferOperations,
  getDecodedLogs,
  getGasUsedFromReceipts,
  getInputAccountAddress,
  getInputContractFromIndex,
  getInputFromAssetId,
  getInputsByType,
  getInputsByTypes,
  getInputsCoin,
  getInputsCoinAndMessage,
  getInputsContract,
  getInputsMessage,
  getMaxGas,
  getMinGas,
  getOperations,
  getOutputsByType,
  getOutputsChange,
  getOutputsCoin,
  getOutputsContract,
  getOutputsContractCreated,
  getOutputsVariable,
  getPayProducerOperations,
  getPredicateRoot,
  getReceiptsByType,
  getReceiptsCall,
  getReceiptsMessageOut,
  getReceiptsTransferOut,
  getReceiptsWithMissingData,
  getTransactionStatusName,
  getTransactionSummary,
  getTransactionSummaryFromRequest,
  getTransactionTypeName,
  getTransactionsSummaries,
  getTransferOperations,
  getWithdrawFromFuelOperations,
  hasSameAssetId,
  inputify,
  isCoin,
  isMessage,
  isRawCoin,
  isRawMessage,
  isType,
  isTypeCreate,
  isTypeMint,
  isTypeScript,
  normalizeJSON,
  outputify,
  processGqlReceipt,
  processGraphqlStatus,
  resolveGasDependentCosts,
  returnZeroScript,
  sleep,
  transactionRequestify,
  withTimeout,
  withdrawScript
});
//# sourceMappingURL=index.js.map