var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/wallet/base-wallet-unlocked.ts
import { hashMessage } from "@fuel-ts/hasher";
import { hexlify as hexlify15 } from "@fuel-ts/utils";

// src/account.ts
import { Address as Address3 } from "@fuel-ts/address";
import { BaseAssetId as BaseAssetId3 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode13, FuelError as FuelError14 } from "@fuel-ts/errors";
import { AbstractAccount } from "@fuel-ts/interfaces";
import { bn as bn16 } from "@fuel-ts/math";
import { arrayify as arrayify14 } from "@fuel-ts/utils";

// src/providers/coin-quantity.ts
import { BaseAssetId } from "@fuel-ts/address/configs";
import { bn } from "@fuel-ts/math";
import { hexlify } from "@fuel-ts/utils";
var coinQuantityfy = (coinQuantityLike) => {
  let assetId;
  let amount;
  let max2;
  if (Array.isArray(coinQuantityLike)) {
    amount = coinQuantityLike[0];
    assetId = coinQuantityLike[1] ?? BaseAssetId;
    max2 = coinQuantityLike[2] ?? void 0;
  } else {
    amount = coinQuantityLike.amount;
    assetId = coinQuantityLike.assetId ?? BaseAssetId;
    max2 = coinQuantityLike.max ?? void 0;
  }
  const bnAmount = bn(amount);
  return {
    assetId: hexlify(assetId),
    amount: bnAmount.lt(1) ? bn(1) : bnAmount,
    max: max2 ? bn(max2) : void 0
  };
};
var addAmountToAsset = (params) => {
  const { amount, assetId } = params;
  const coinQuantities = [...params.coinQuantities];
  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
  if (assetIdx !== -1) {
    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
  } else {
    coinQuantities.push({ assetId, amount });
  }
  return coinQuantities;
};

// src/providers/provider.ts
import { Address as Address2 } from "@fuel-ts/address";
import { ErrorCode as ErrorCode11, FuelError as FuelError12 } from "@fuel-ts/errors";
import { BN, bn as bn14, max } from "@fuel-ts/math";
import {
  InputType as InputType6,
  TransactionType as TransactionType8,
  InputMessageCoder,
  TransactionCoder as TransactionCoder5
} from "@fuel-ts/transactions";
import { arrayify as arrayify11, hexlify as hexlify12, DateTime as DateTime2 } from "@fuel-ts/utils";
import { checkFuelCoreVersionCompatibility } from "@fuel-ts/versions";
import { equalBytes } from "@noble/curves/abstract/utils";
import { Network } from "ethers";
import { GraphQLClient } from "graphql-request";
import { clone as clone3 } from "ramda";

// src/providers/__generated__/operations.ts
import gql from "graphql-tag";
var ReceiptFragmentFragmentDoc = gql`
    fragment receiptFragment on Receipt {
  contract {
    id
  }
  pc
  is
  to {
    id
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
var TransactionStatusFragmentFragmentDoc = gql`
    fragment transactionStatusFragment on TransactionStatus {
  type: __typename
  ... on SubmittedStatus {
    time
  }
  ... on SuccessStatus {
    block {
      id
    }
    time
    programState {
      returnType
      data
    }
  }
  ... on FailureStatus {
    block {
      id
    }
    time
    reason
  }
}
    `;
var TransactionFragmentFragmentDoc = gql`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    ...transactionStatusFragment
  }
}
    ${ReceiptFragmentFragmentDoc}
${TransactionStatusFragmentFragmentDoc}`;
var InputEstimatePredicatesFragmentFragmentDoc = gql`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `;
var TransactionEstimatePredicatesFragmentFragmentDoc = gql`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${InputEstimatePredicatesFragmentFragmentDoc}`;
var CoinFragmentFragmentDoc = gql`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
var MessageCoinFragmentFragmentDoc = gql`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
var MessageFragmentFragmentDoc = gql`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
var MessageProofFragmentFragmentDoc = gql`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
var BalanceFragmentFragmentDoc = gql`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
var BlockFragmentFragmentDoc = gql`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
var TxParametersFragmentFragmentDoc = gql`
    fragment TxParametersFragment on TxParameters {
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
}
    `;
var PredicateParametersFragmentFragmentDoc = gql`
    fragment PredicateParametersFragment on PredicateParameters {
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `;
var ScriptParametersFragmentFragmentDoc = gql`
    fragment ScriptParametersFragment on ScriptParameters {
  maxScriptLength
  maxScriptDataLength
}
    `;
var ContractParametersFragmentFragmentDoc = gql`
    fragment ContractParametersFragment on ContractParameters {
  contractMaxSize
  maxStorageSlots
}
    `;
var FeeParametersFragmentFragmentDoc = gql`
    fragment FeeParametersFragment on FeeParameters {
  gasPriceFactor
  gasPerByte
}
    `;
var DependentCostFragmentFragmentDoc = gql`
    fragment DependentCostFragment on DependentCost {
  __typename
  ... on LightOperation {
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    base
    gasPerUnit
  }
}
    `;
var GasCostsFragmentFragmentDoc = gql`
    fragment GasCostsFragment on GasCosts {
  add
  addi
  aloc
  and
  andi
  bal
  bhei
  bhsh
  burn
  cb
  cfei
  cfsi
  croo
  div
  divi
  ecr1
  eck1
  ed19
  eq
  exp
  expi
  flag
  gm
  gt
  gtf
  ji
  jmp
  jne
  jnei
  jnzi
  jmpf
  jmpb
  jnzf
  jnzb
  jnef
  jneb
  lb
  log
  lt
  lw
  mint
  mlog
  modOp
  modi
  moveOp
  movi
  mroo
  mul
  muli
  mldv
  noop
  not
  or
  ori
  poph
  popl
  pshh
  pshl
  ret
  rvrt
  sb
  sll
  slli
  srl
  srli
  srw
  sub
  subi
  sw
  sww
  time
  tr
  tro
  wdcm
  wqcm
  wdop
  wqop
  wdml
  wqml
  wddv
  wqdv
  wdmd
  wqmd
  wdam
  wqam
  wdmm
  wqmm
  xor
  xori
  call {
    ...DependentCostFragment
  }
  ccp {
    ...DependentCostFragment
  }
  csiz {
    ...DependentCostFragment
  }
  k256 {
    ...DependentCostFragment
  }
  ldc {
    ...DependentCostFragment
  }
  logd {
    ...DependentCostFragment
  }
  mcl {
    ...DependentCostFragment
  }
  mcli {
    ...DependentCostFragment
  }
  mcp {
    ...DependentCostFragment
  }
  mcpi {
    ...DependentCostFragment
  }
  meq {
    ...DependentCostFragment
  }
  retd {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  scwq {
    ...DependentCostFragment
  }
  smo {
    ...DependentCostFragment
  }
  srwq {
    ...DependentCostFragment
  }
  swwq {
    ...DependentCostFragment
  }
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  newStoragePerByte
}
    ${DependentCostFragmentFragmentDoc}`;
var ConsensusParametersFragmentFragmentDoc = gql`
    fragment consensusParametersFragment on ConsensusParameters {
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${TxParametersFragmentFragmentDoc}
${PredicateParametersFragmentFragmentDoc}
${ScriptParametersFragmentFragmentDoc}
${ContractParametersFragmentFragmentDoc}
${FeeParametersFragmentFragmentDoc}
${GasCostsFragmentFragmentDoc}`;
var ChainInfoFragmentFragmentDoc = gql`
    fragment chainInfoFragment on ChainInfo {
  name
  latestBlock {
    ...blockFragment
  }
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
}
    ${BlockFragmentFragmentDoc}
${ConsensusParametersFragmentFragmentDoc}`;
var ContractBalanceFragmentFragmentDoc = gql`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
var PageInfoFragmentFragmentDoc = gql`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
var NodeInfoFragmentFragmentDoc = gql`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
  peers {
    id
    addresses
    clientVersion
    blockHeight
    lastHeartbeatMs
    appScore
  }
}
    `;
var GetVersionDocument = gql`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
var GetNodeInfoDocument = gql`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc}`;
var GetChainDocument = gql`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc}`;
var GetTransactionDocument = gql`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionWithReceiptsDocument = gql`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc}
${ReceiptFragmentFragmentDoc}`;
var GetTransactionsDocument = gql`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc}`;
var GetTransactionsByOwnerDocument = gql`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var EstimatePredicatesDocument = gql`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${TransactionEstimatePredicatesFragmentFragmentDoc}`;
var GetBlockDocument = gql`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetBlockWithTransactionsDocument = gql`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
var GetBlocksDocument = gql`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc}`;
var GetCoinDocument = gql`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsDocument = gql`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc}`;
var GetCoinsToSpendDocument = gql`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc}
${MessageCoinFragmentFragmentDoc}`;
var GetContractDocument = gql`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
var GetContractBalanceDocument = gql`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc}`;
var GetBalanceDocument = gql`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetBalancesDocument = gql`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc}`;
var GetMessagesDocument = gql`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc}`;
var GetMessageProofDocument = gql`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc}`;
var GetMessageStatusDocument = gql`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
var DryRunDocument = gql`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc}`;
var SubmitDocument = gql`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
var ProduceBlocksDocument = gql`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
var SubmitAndAwaitDocument = gql`
    subscription submitAndAwait($encodedTransaction: HexString!) {
  submitAndAwait(tx: $encodedTransaction) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
var StatusChangeDocument = gql`
    subscription statusChange($transactionId: TransactionId!) {
  statusChange(id: $transactionId) {
    ...transactionStatusFragment
  }
}
    ${TransactionStatusFragmentFragmentDoc}`;
function getSdk(requester) {
  return {
    getVersion(variables, options) {
      return requester(GetVersionDocument, variables, options);
    },
    getNodeInfo(variables, options) {
      return requester(GetNodeInfoDocument, variables, options);
    },
    getChain(variables, options) {
      return requester(GetChainDocument, variables, options);
    },
    getTransaction(variables, options) {
      return requester(GetTransactionDocument, variables, options);
    },
    getTransactionWithReceipts(variables, options) {
      return requester(GetTransactionWithReceiptsDocument, variables, options);
    },
    getTransactions(variables, options) {
      return requester(GetTransactionsDocument, variables, options);
    },
    getTransactionsByOwner(variables, options) {
      return requester(GetTransactionsByOwnerDocument, variables, options);
    },
    estimatePredicates(variables, options) {
      return requester(EstimatePredicatesDocument, variables, options);
    },
    getBlock(variables, options) {
      return requester(GetBlockDocument, variables, options);
    },
    getBlockWithTransactions(variables, options) {
      return requester(GetBlockWithTransactionsDocument, variables, options);
    },
    getBlocks(variables, options) {
      return requester(GetBlocksDocument, variables, options);
    },
    getCoin(variables, options) {
      return requester(GetCoinDocument, variables, options);
    },
    getCoins(variables, options) {
      return requester(GetCoinsDocument, variables, options);
    },
    getCoinsToSpend(variables, options) {
      return requester(GetCoinsToSpendDocument, variables, options);
    },
    getContract(variables, options) {
      return requester(GetContractDocument, variables, options);
    },
    getContractBalance(variables, options) {
      return requester(GetContractBalanceDocument, variables, options);
    },
    getBalance(variables, options) {
      return requester(GetBalanceDocument, variables, options);
    },
    getBalances(variables, options) {
      return requester(GetBalancesDocument, variables, options);
    },
    getMessages(variables, options) {
      return requester(GetMessagesDocument, variables, options);
    },
    getMessageProof(variables, options) {
      return requester(GetMessageProofDocument, variables, options);
    },
    getMessageStatus(variables, options) {
      return requester(GetMessageStatusDocument, variables, options);
    },
    dryRun(variables, options) {
      return requester(DryRunDocument, variables, options);
    },
    submit(variables, options) {
      return requester(SubmitDocument, variables, options);
    },
    produceBlocks(variables, options) {
      return requester(ProduceBlocksDocument, variables, options);
    },
    submitAndAwait(variables, options) {
      return requester(SubmitAndAwaitDocument, variables, options);
    },
    statusChange(variables, options) {
      return requester(StatusChangeDocument, variables, options);
    }
  };
}

// src/providers/fuel-graphql-subscriber.ts
import { FuelError } from "@fuel-ts/errors";
import { print } from "graphql";
var _FuelGraphqlSubscriber = class {
  constructor(options) {
    this.options = options;
  }
  stream;
  async setStream() {
    const { url, query, variables, fetchFn } = this.options;
    const response = await fetchFn(`${url}-sub`, {
      method: "POST",
      body: JSON.stringify({
        query: print(query),
        variables
      }),
      headers: {
        "Content-Type": "application/json",
        Accept: "text/event-stream"
      }
    });
    this.stream = response.body.getReader();
  }
  async next() {
    if (!this.stream) {
      await this.setStream();
    }
    while (true) {
      const { value, done } = await this.stream.read();
      if (done) {
        return { value, done };
      }
      const text = _FuelGraphqlSubscriber.textDecoder.decode(value);
      if (!text.startsWith("data:")) {
        continue;
      }
      const { data, errors } = JSON.parse(text.split("data:")[1]);
      if (Array.isArray(errors)) {
        throw new FuelError(
          FuelError.CODES.INVALID_REQUEST,
          errors.map((err) => err.message).join("\n\n")
        );
      }
      return { value: data, done: false };
    }
  }
  /**
   * Gets called when `break` is called in a `for-await-of` loop.
   */
  async return() {
    await this.stream.cancel();
    this.stream.releaseLock();
    return { done: true, value: void 0 };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
var FuelGraphqlSubscriber = _FuelGraphqlSubscriber;
__publicField(FuelGraphqlSubscriber, "textDecoder", new TextDecoder());

// src/providers/memory-cache.ts
import { ErrorCode, FuelError as FuelError2 } from "@fuel-ts/errors";
import { hexlify as hexlify2 } from "@fuel-ts/utils";
var cache = {};
var DEFAULT_TTL_IN_MS = 30 * 1e3;
var MemoryCache = class {
  ttl;
  constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
    this.ttl = ttlInMs;
    if (typeof ttlInMs !== "number" || this.ttl <= 0) {
      throw new FuelError2(
        ErrorCode.INVALID_TTL,
        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
      );
    }
  }
  get(value, isAutoExpiring = true) {
    const key = hexlify2(value);
    if (cache[key]) {
      if (!isAutoExpiring || cache[key].expires > Date.now()) {
        return cache[key].value;
      }
      this.del(value);
    }
    return void 0;
  }
  set(value) {
    const expiresAt = Date.now() + this.ttl;
    const key = hexlify2(value);
    cache[key] = {
      expires: expiresAt,
      value
    };
    return expiresAt;
  }
  getAllData() {
    return Object.keys(cache).reduce((list, key) => {
      const data = this.get(key, false);
      if (data) {
        list.push(data);
      }
      return list;
    }, []);
  }
  getActiveData() {
    return Object.keys(cache).reduce((list, key) => {
      const data = this.get(key);
      if (data) {
        list.push(data);
      }
      return list;
    }, []);
  }
  del(value) {
    const key = hexlify2(value);
    delete cache[key];
  }
};

// src/providers/transaction-request/input.ts
import { ZeroBytes32 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode2, FuelError as FuelError3 } from "@fuel-ts/errors";
import { bn as bn2, toNumber } from "@fuel-ts/math";
import { InputType } from "@fuel-ts/transactions";
import { arrayify, hexlify as hexlify3 } from "@fuel-ts/utils";
var inputify = (value) => {
  const { type } = value;
  switch (value.type) {
    case InputType.Coin: {
      const predicate = arrayify(value.predicate ?? "0x");
      const predicateData = arrayify(value.predicateData ?? "0x");
      return {
        type: InputType.Coin,
        txID: hexlify3(arrayify(value.id).slice(0, 32)),
        outputIndex: arrayify(value.id)[32],
        owner: hexlify3(value.owner),
        amount: bn2(value.amount),
        assetId: hexlify3(value.assetId),
        txPointer: {
          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),
          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))
        },
        witnessIndex: value.witnessIndex,
        maturity: value.maturity ?? 0,
        predicateGasUsed: bn2(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: hexlify3(predicate),
        predicateData: hexlify3(predicateData)
      };
    }
    case InputType.Contract: {
      return {
        type: InputType.Contract,
        txID: ZeroBytes32,
        outputIndex: 0,
        balanceRoot: ZeroBytes32,
        stateRoot: ZeroBytes32,
        txPointer: {
          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),
          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))
        },
        contractID: hexlify3(value.contractId)
      };
    }
    case InputType.Message: {
      const predicate = arrayify(value.predicate ?? "0x");
      const predicateData = arrayify(value.predicateData ?? "0x");
      const data = arrayify(value.data ?? "0x");
      return {
        type: InputType.Message,
        sender: hexlify3(value.sender),
        recipient: hexlify3(value.recipient),
        amount: bn2(value.amount),
        nonce: hexlify3(value.nonce),
        witnessIndex: value.witnessIndex,
        predicateGasUsed: bn2(value.predicateGasUsed),
        predicateLength: predicate.length,
        predicateDataLength: predicateData.length,
        predicate: hexlify3(predicate),
        predicateData: hexlify3(predicateData),
        data: hexlify3(data),
        dataLength: data.length
      };
    }
    default: {
      throw new FuelError3(
        ErrorCode2.INVALID_TRANSACTION_INPUT,
        `Invalid transaction input type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/output.ts
import { ZeroBytes32 as ZeroBytes322 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode3, FuelError as FuelError4 } from "@fuel-ts/errors";
import { bn as bn3 } from "@fuel-ts/math";
import { OutputType } from "@fuel-ts/transactions";
import { hexlify as hexlify4 } from "@fuel-ts/utils";
var outputify = (value) => {
  const { type } = value;
  switch (type) {
    case OutputType.Coin: {
      return {
        type: OutputType.Coin,
        to: hexlify4(value.to),
        amount: bn3(value.amount),
        assetId: hexlify4(value.assetId)
      };
    }
    case OutputType.Contract: {
      return {
        type: OutputType.Contract,
        inputIndex: value.inputIndex,
        balanceRoot: ZeroBytes322,
        stateRoot: ZeroBytes322
      };
    }
    case OutputType.Change: {
      return {
        type: OutputType.Change,
        to: hexlify4(value.to),
        amount: bn3(0),
        assetId: hexlify4(value.assetId)
      };
    }
    case OutputType.Variable: {
      return {
        type: OutputType.Variable,
        to: ZeroBytes322,
        amount: bn3(0),
        assetId: ZeroBytes322
      };
    }
    case OutputType.ContractCreated: {
      return {
        type: OutputType.ContractCreated,
        contractId: hexlify4(value.contractId),
        stateRoot: hexlify4(value.stateRoot)
      };
    }
    default: {
      throw new FuelError4(
        ErrorCode3.INVALID_TRANSACTION_INPUT,
        `Invalid transaction output type: ${type}.`
      );
    }
  }
};

// src/providers/transaction-request/transaction-request.ts
import { Address, addressify } from "@fuel-ts/address";
import { BaseAssetId as BaseAssetId2, ZeroBytes32 as ZeroBytes324 } from "@fuel-ts/address/configs";
import { bn as bn6 } from "@fuel-ts/math";
import {
  PolicyType,
  TransactionCoder,
  InputType as InputType2,
  OutputType as OutputType2,
  TransactionType
} from "@fuel-ts/transactions";
import { concat, hexlify as hexlify7 } from "@fuel-ts/utils";

// src/providers/resource.ts
var isCoin = (resource) => "id" in resource;

// src/providers/utils/receipts.ts
import { ZeroBytes32 as ZeroBytes323 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode4, FuelError as FuelError5 } from "@fuel-ts/errors";
import { bn as bn4 } from "@fuel-ts/math";
import {
  ReceiptBurnCoder,
  ReceiptMessageOutCoder,
  ReceiptMintCoder,
  ReceiptType
} from "@fuel-ts/transactions";
import { FAILED_TRANSFER_TO_ADDRESS_SIGNAL } from "@fuel-ts/transactions/configs";
import { arrayify as arrayify2 } from "@fuel-ts/utils";
var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
var doesReceiptHaveMissingContractId = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
var getReceiptsWithMissingData = (receipts) => receipts.reduce(
  (memo, receipt) => {
    if (doesReceiptHaveMissingOutputVariables(receipt)) {
      memo.missingOutputVariables.push(receipt);
    }
    if (doesReceiptHaveMissingContractId(receipt)) {
      memo.missingOutputContractIds.push(receipt);
    }
    return memo;
  },
  {
    missingOutputVariables: [],
    missingOutputContractIds: []
  }
);
var hexOrZero = (hex) => hex || ZeroBytes323;
function assembleReceiptByType(receipt) {
  const { receiptType } = receipt;
  switch (receiptType) {
    case "CALL" /* Call */: {
      const callReceipt = {
        type: ReceiptType.Call,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt?.to?.id),
        amount: bn4(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        gas: bn4(receipt.gas),
        param1: bn4(receipt.param1),
        param2: bn4(receipt.param2),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return callReceipt;
    }
    case "RETURN" /* Return */: {
      const returnReceipt = {
        type: ReceiptType.Return,
        id: hexOrZero(receipt.contract?.id),
        val: bn4(receipt.val),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return returnReceipt;
    }
    case "RETURN_DATA" /* ReturnData */: {
      const returnDataReceipt = {
        type: ReceiptType.ReturnData,
        id: hexOrZero(receipt.contract?.id),
        ptr: bn4(receipt.ptr),
        len: bn4(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return returnDataReceipt;
    }
    case "PANIC" /* Panic */: {
      const panicReceipt = {
        type: ReceiptType.Panic,
        id: hexOrZero(receipt.contract?.id),
        reason: bn4(receipt.reason),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is),
        contractId: hexOrZero(receipt.contractId)
      };
      return panicReceipt;
    }
    case "REVERT" /* Revert */: {
      const revertReceipt = {
        type: ReceiptType.Revert,
        id: hexOrZero(receipt.contract?.id),
        val: bn4(receipt.ra),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return revertReceipt;
    }
    case "LOG" /* Log */: {
      const logReceipt = {
        type: ReceiptType.Log,
        id: hexOrZero(receipt.contract?.id),
        val0: bn4(receipt.ra),
        val1: bn4(receipt.rb),
        val2: bn4(receipt.rc),
        val3: bn4(receipt.rd),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return logReceipt;
    }
    case "LOG_DATA" /* LogData */: {
      const logDataReceipt = {
        type: ReceiptType.LogData,
        id: hexOrZero(receipt.contract?.id),
        val0: bn4(receipt.ra),
        val1: bn4(receipt.rb),
        ptr: bn4(receipt.ptr),
        len: bn4(receipt.len),
        digest: hexOrZero(receipt.digest),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return logDataReceipt;
    }
    case "TRANSFER" /* Transfer */: {
      const transferReceipt = {
        type: ReceiptType.Transfer,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt?.to?.id),
        amount: bn4(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return transferReceipt;
    }
    case "TRANSFER_OUT" /* TransferOut */: {
      const transferOutReceipt = {
        type: ReceiptType.TransferOut,
        from: hexOrZero(receipt.contract?.id),
        to: hexOrZero(receipt.toAddress || receipt.to?.id),
        amount: bn4(receipt.amount),
        assetId: hexOrZero(receipt.assetId),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return transferOutReceipt;
    }
    case "SCRIPT_RESULT" /* ScriptResult */: {
      const scriptResultReceipt = {
        type: ReceiptType.ScriptResult,
        result: bn4(receipt.result),
        gasUsed: bn4(receipt.gasUsed)
      };
      return scriptResultReceipt;
    }
    case "MESSAGE_OUT" /* MessageOut */: {
      const sender = hexOrZero(receipt.sender);
      const recipient = hexOrZero(receipt.recipient);
      const nonce = hexOrZero(receipt.nonce);
      const amount = bn4(receipt.amount);
      const data = receipt.data ? arrayify2(receipt.data) : Uint8Array.from([]);
      const digest = hexOrZero(receipt.digest);
      const messageId = ReceiptMessageOutCoder.getMessageId({
        sender,
        recipient,
        nonce,
        amount,
        data
      });
      const receiptMessageOut = {
        type: ReceiptType.MessageOut,
        sender,
        recipient,
        amount,
        nonce,
        data,
        digest,
        messageId
      };
      return receiptMessageOut;
    }
    case "MINT" /* Mint */: {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
      const mintReceipt = {
        type: ReceiptType.Mint,
        subId,
        contractId,
        assetId,
        val: bn4(receipt.val),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return mintReceipt;
    }
    case "BURN" /* Burn */: {
      const contractId = hexOrZero(receipt.contract?.id);
      const subId = hexOrZero(receipt.subId);
      const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);
      const burnReceipt = {
        type: ReceiptType.Burn,
        subId,
        contractId,
        assetId,
        val: bn4(receipt.val),
        pc: bn4(receipt.pc),
        is: bn4(receipt.is)
      };
      return burnReceipt;
    }
    default:
      throw new FuelError5(ErrorCode4.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
  }
}

// src/providers/utils/block-explorer.ts
import { ErrorCode as ErrorCode5, FuelError as FuelError6 } from "@fuel-ts/errors";

// src/providers/utils/gas.ts
import { bn as bn5 } from "@fuel-ts/math";
import { ReceiptType as ReceiptType2 } from "@fuel-ts/transactions";
import { arrayify as arrayify3 } from "@fuel-ts/utils";
var calculatePriceWithFactor = (gas, gasPrice, priceFactor) => bn5(Math.ceil(gas.mul(gasPrice).toNumber() / priceFactor.toNumber()));
var getGasUsedFromReceipts = (receipts) => {
  const scriptResult = receipts.filter(
    (receipt) => receipt.type === ReceiptType2.ScriptResult
  );
  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn5(0));
  return gasUsed;
};
function resolveGasDependentCosts(byteSize, gasDependentCost) {
  const base = bn5(gasDependentCost.base);
  let dependentValue = bn5(0);
  if (gasDependentCost.__typename === "LightOperation") {
    dependentValue = bn5(byteSize).div(bn5(gasDependentCost.unitsPerGas));
  }
  if (gasDependentCost.__typename === "HeavyOperation") {
    dependentValue = bn5(byteSize).mul(bn5(gasDependentCost.gasPerUnit));
  }
  return base.add(dependentValue);
}
function gasUsedByInputs(inputs, txBytesSize, gasCosts) {
  const witnessCache = [];
  const totalGas = inputs.reduce((total, input) => {
    if ("predicate" in input && input.predicate && input.predicate !== "0x") {
      return total.add(
        resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization).add(resolveGasDependentCosts(arrayify3(input.predicate).length, gasCosts.contractRoot)).add(bn5(input.predicateGasUsed))
      );
    }
    if ("witnessIndex" in input && !witnessCache.includes(input.witnessIndex)) {
      witnessCache.push(input.witnessIndex);
      return total.add(gasCosts.ecr1);
    }
    return total;
  }, bn5());
  return totalGas;
}
function getMinGas(params) {
  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;
  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);
  const bytesGas = bn5(txBytesSize).mul(gasPerByte);
  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);
  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();
  return minGas;
}
function getMaxGas(params) {
  const { gasPerByte, witnessesLength, witnessLimit, minGas, gasLimit = bn5(0) } = params;
  let remainingAllowedWitnessGas = bn5(0);
  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {
    remainingAllowedWitnessGas = bn5(witnessLimit).sub(witnessesLength).mul(gasPerByte);
  }
  return remainingAllowedWitnessGas.add(minGas).add(gasLimit);
}
function calculateMetadataGasForTxCreate({
  gasCosts,
  stateRootSize,
  txBytesSize,
  contractBytesSize
}) {
  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);
  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);
  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);
  const contractIdInputSize = bn5(4 + 32 + 32 + 32);
  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);
  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);
  return metadataGas.maxU64();
}
function calculateMetadataGasForTxScript({
  gasCosts,
  txBytesSize
}) {
  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);
}

// src/providers/utils/json.ts
import { hexlify as hexlify5 } from "@fuel-ts/utils";
import { clone } from "ramda";
function normalize(object) {
  Object.keys(object).forEach((key) => {
    switch (object[key]?.constructor.name) {
      case "Uint8Array":
        object[key] = hexlify5(object[key]);
        break;
      case "Array":
        object[key] = normalize(object[key]);
        break;
      case "BN":
        object[key] = object[key].toHex();
        break;
      case "Address":
        object[key] = object[key].toB256();
        break;
      case "Object":
        object[key] = normalize(object[key]);
        break;
      default:
        break;
    }
  });
  return object;
}
function normalizeJSON(root) {
  return normalize(clone(root));
}

// src/providers/utils/sleep.ts
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
}

// src/providers/transaction-request/errors.ts
var NoWitnessAtIndexError = class extends Error {
  constructor(index) {
    super();
    this.index = index;
    this.message = `Witness at index "${index}" was not found`;
  }
  name = "NoWitnessAtIndexError";
};

// src/providers/transaction-request/witness.ts
import { arrayify as arrayify4, hexlify as hexlify6 } from "@fuel-ts/utils";
var witnessify = (value) => {
  const data = arrayify4(value);
  return {
    data: hexlify6(data),
    dataLength: data.length
  };
};

// src/providers/transaction-request/transaction-request.ts
var BaseTransactionRequest = class {
  /** Gas price for transaction */
  gasPrice;
  /** Block until which tx cannot be included */
  maturity;
  /** The maximum fee payable by this transaction using BASE_ASSET. */
  maxFee;
  /** The maximum amount of witness data allowed for the transaction */
  witnessLimit;
  /** List of inputs */
  inputs = [];
  /** List of outputs */
  outputs = [];
  /** List of witnesses */
  witnesses = [];
  /**
   * Constructor for initializing a base transaction request.
   *
   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
   */
  constructor({
    gasPrice,
    maturity,
    maxFee,
    witnessLimit,
    inputs,
    outputs,
    witnesses
  } = {}) {
    this.gasPrice = bn6(gasPrice);
    this.maturity = maturity ?? 0;
    this.witnessLimit = witnessLimit ? bn6(witnessLimit) : void 0;
    this.maxFee = maxFee ? bn6(maxFee) : void 0;
    this.inputs = inputs ?? [];
    this.outputs = outputs ?? [];
    this.witnesses = witnesses ?? [];
  }
  static getPolicyMeta(req) {
    let policyTypes = 0;
    const policies = [];
    if (req.gasPrice) {
      policyTypes += PolicyType.GasPrice;
      policies.push({ data: req.gasPrice, type: PolicyType.GasPrice });
    }
    if (req.witnessLimit) {
      policyTypes += PolicyType.WitnessLimit;
      policies.push({ data: req.witnessLimit, type: PolicyType.WitnessLimit });
    }
    if (req.maturity > 0) {
      policyTypes += PolicyType.Maturity;
      policies.push({ data: req.maturity, type: PolicyType.Maturity });
    }
    if (req.maxFee) {
      policyTypes += PolicyType.MaxFee;
      policies.push({ data: req.maxFee, type: PolicyType.MaxFee });
    }
    return {
      policyTypes,
      policies
    };
  }
  /**
   * Method to obtain the base transaction details.
   *
   * @returns The base transaction details.
   */
  getBaseTransaction() {
    const inputs = this.inputs?.map(inputify) ?? [];
    const outputs = this.outputs?.map(outputify) ?? [];
    const witnesses = this.witnesses?.map(witnessify) ?? [];
    const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);
    return {
      policyTypes,
      inputs,
      outputs,
      policies,
      witnesses,
      inputsCount: inputs.length,
      outputsCount: outputs.length,
      witnessesCount: witnesses.length
    };
  }
  /**
   * Converts the transaction request to a byte array.
   *
   * @returns The transaction bytes.
   */
  toTransactionBytes() {
    return new TransactionCoder().encode(this.toTransaction());
  }
  /**
   * @hidden
   *
   * Pushes an input to the list without any side effects and returns the index
   */
  pushInput(input) {
    this.inputs.push(input);
    return this.inputs.length - 1;
  }
  /**
   * @hidden
   *
   * Pushes an output to the list without any side effects and returns the index
   */
  pushOutput(output) {
    this.outputs.push(output);
    return this.outputs.length - 1;
  }
  /**
   * @hidden
   *
   * Creates an empty witness without any side effects and returns the index
   */
  createWitness() {
    this.witnesses.push(concat([ZeroBytes324, ZeroBytes324]));
    return this.witnesses.length - 1;
  }
  /**
   * Updates the witness for a given owner and signature.
   *
   * @param address - The address to get the coin input witness index for.
   * @param signature - The signature to update the witness with.
   */
  updateWitnessByOwner(address, signature) {
    const ownerAddress = Address.fromAddressOrString(address);
    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);
    if (typeof witnessIndex === "number") {
      this.updateWitness(witnessIndex, signature);
    }
  }
  /**
   * Updates an existing witness without any side effects.
   *
   * @param index - The index of the witness to update.
   * @param witness - The new witness.
   * @throws If the witness does not exist.
   */
  updateWitness(index, witness) {
    if (!this.witnesses[index]) {
      throw new NoWitnessAtIndexError(index);
    }
    this.witnesses[index] = witness;
  }
  /**
   * Gets the coin inputs for a transaction.
   *
   * @returns The coin inputs.
   */
  getCoinInputs() {
    return this.inputs.filter(
      (input) => input.type === InputType2.Coin
    );
  }
  /**
   * Gets the coin outputs for a transaction.
   *
   * @returns The coin outputs.
   */
  getCoinOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType2.Coin
    );
  }
  /**
   * Gets the change outputs for a transaction.
   *
   * @returns The change outputs.
   */
  getChangeOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType2.Change
    );
  }
  /**
   * @hidden
   *
   * Returns the witnessIndex of the found CoinInput.
   */
  getCoinInputWitnessIndexByOwner(owner) {
    const ownerAddress = addressify(owner);
    const found = this.inputs.find((input) => {
      switch (input.type) {
        case InputType2.Coin:
          return hexlify7(input.owner) === ownerAddress.toB256();
        case InputType2.Message:
          return hexlify7(input.recipient) === ownerAddress.toB256();
        default:
          return false;
      }
    });
    return found?.witnessIndex;
  }
  /**
   * Adds a single coin input to the transaction and a change output for the related
   * assetId, if one it was not added yet.
   *
   * @param coin - Coin resource.
   * @param predicate - Predicate bytes.
   * @param predicateData - Predicate data bytes.
   */
  addCoinInput(coin, predicate) {
    const { assetId, owner, amount } = coin;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.createWitness();
      }
    }
    const input = {
      ...coin,
      type: InputType2.Coin,
      owner: owner.toB256(),
      amount,
      assetId,
      txPointer: "0x00000000000000000000000000000000",
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(owner, assetId);
  }
  /**
   * Adds a single message input to the transaction and a change output for the
   * baseAssetId, if one it was not added yet.
   *
   * @param message - Message resource.
   * @param predicate - Predicate bytes.
   * @param predicateData - Predicate data bytes.
   */
  addMessageInput(message, predicate) {
    const { recipient, sender, amount } = message;
    const assetId = BaseAssetId2;
    let witnessIndex;
    if (predicate) {
      witnessIndex = 0;
    } else {
      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
      if (typeof witnessIndex !== "number") {
        witnessIndex = this.createWitness();
      }
    }
    const input = {
      ...message,
      type: InputType2.Message,
      sender: sender.toB256(),
      recipient: recipient.toB256(),
      amount,
      witnessIndex,
      predicate: predicate?.bytes,
      predicateData: predicate?.predicateData
    };
    this.pushInput(input);
    this.addChangeOutput(recipient, assetId);
  }
  /**
   * Adds a single resource to the transaction by adding a coin/message input and a
   * change output for the related assetId, if one it was not added yet.
   *
   * @param resource - The resource to add.
   * @returns This transaction.
   */
  addResource(resource) {
    if (isCoin(resource)) {
      this.addCoinInput(resource);
    } else {
      this.addMessageInput(resource);
    }
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addResources(resources) {
    resources.forEach((resource) => this.addResource(resource));
    return this;
  }
  /**
   * Adds multiple resources to the transaction by adding coin/message inputs and change
   * outputs from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addPredicateResource(resource, predicate) {
    if (isCoin(resource)) {
      this.addCoinInput(resource, predicate);
    } else {
      this.addMessageInput(resource, predicate);
    }
    return this;
  }
  /**
   * Adds multiple predicate coin/message inputs to the transaction and change outputs
   * from the related assetIds.
   *
   * @param resources - The resources to add.
   * @returns This transaction.
   */
  addPredicateResources(resources, predicate) {
    resources.forEach((resource) => this.addPredicateResource(resource, predicate));
    return this;
  }
  /**
   * Adds a coin output to the transaction.
   *
   * @param to - Address of the owner.
   * @param amount - Amount of coin.
   * @param assetId - Asset ID of coin.
   */
  addCoinOutput(to, amount, assetId = BaseAssetId2) {
    this.pushOutput({
      type: OutputType2.Coin,
      to: addressify(to).toB256(),
      amount,
      assetId
    });
    return this;
  }
  /**
   * Adds multiple coin outputs to the transaction.
   *
   * @param to - Address of the destination.
   * @param quantities - Quantities of coins.
   */
  addCoinOutputs(to, quantities) {
    quantities.map(coinQuantityfy).forEach((quantity) => {
      this.pushOutput({
        type: OutputType2.Coin,
        to: addressify(to).toB256(),
        amount: quantity.amount,
        assetId: quantity.assetId
      });
    });
    return this;
  }
  /**
   * Adds a change output to the transaction.
   *
   * @param to - Address of the owner.
   * @param assetId - Asset ID of coin.
   */
  addChangeOutput(to, assetId = BaseAssetId2) {
    const changeOutput = this.getChangeOutputs().find(
      (output) => hexlify7(output.assetId) === assetId
    );
    if (!changeOutput) {
      this.pushOutput({
        type: OutputType2.Change,
        to: addressify(to).toB256(),
        assetId
      });
    }
  }
  /**
   * @hidden
   */
  byteSize() {
    return this.toTransactionBytes().length;
  }
  /**
   * @hidden
   */
  metadataGas(_gasCosts) {
    throw new Error("Not implemented");
  }
  /**
   * @hidden
   */
  calculateMinGas(chainInfo) {
    const { gasCosts, consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    return getMinGas({
      gasPerByte,
      gasCosts,
      inputs: this.inputs,
      txBytesSize: this.byteSize(),
      metadataGas: this.metadataGas(gasCosts)
    });
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit
    });
  }
  /**
   * Funds the transaction with fake UTXOs for each assetId and amount in the
   * quantities array.
   *
   * @param quantities - CoinQuantity Array.
   */
  fundWithFakeUtxos(quantities, resourcesOwner) {
    let idCounter = 0;
    const generateId = () => {
      const counterString = String(idCounter++);
      const id = ZeroBytes324.slice(0, -counterString.length).concat(counterString);
      return id;
    };
    const findAssetInput = (assetId) => this.inputs.find((input) => {
      if ("assetId" in input) {
        return input.assetId === assetId;
      }
      return false;
    });
    const updateAssetInput = (assetId, quantity) => {
      const assetInput = findAssetInput(assetId);
      if (assetInput && "assetId" in assetInput) {
        assetInput.id = generateId();
        assetInput.amount = quantity;
      } else {
        this.addResources([
          {
            id: generateId(),
            amount: quantity,
            assetId,
            owner: resourcesOwner || Address.fromRandom(),
            maturity: 0,
            blockCreated: bn6(1),
            txCreatedIdx: bn6(1)
          }
        ]);
      }
    };
    updateAssetInput(BaseAssetId2, bn6(1e11));
    quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));
  }
  /**
   * Retrieves an array of CoinQuantity for each coin output present in the transaction.
   * a transaction.
   *
   * @returns  CoinQuantity array.
   */
  getCoinOutputsQuantities() {
    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
      amount: bn6(amount),
      assetId: assetId.toString()
    }));
    return coinsQuantities;
  }
  /**
   * Return the minimum amount in native coins required to create
   * a transaction.
   *
   * @returns The transaction as a JSON object.
   */
  toJSON() {
    return normalizeJSON(this);
  }
  updatePredicateInputs(inputs) {
    this.inputs.forEach((i) => {
      let correspondingInput;
      switch (i.type) {
        case InputType2.Coin:
          correspondingInput = inputs.find((x) => x.type === InputType2.Coin && x.owner === i.owner);
          break;
        case InputType2.Message:
          correspondingInput = inputs.find(
            (x) => x.type === InputType2.Message && x.sender === i.sender
          );
          break;
        default:
          return;
      }
      if (correspondingInput && "predicateGasUsed" in correspondingInput && bn6(correspondingInput.predicateGasUsed).gt(0)) {
        i.predicate = correspondingInput.predicate;
        i.predicateData = correspondingInput.predicateData;
        i.predicateGasUsed = correspondingInput.predicateGasUsed;
      }
    });
  }
};

// src/providers/transaction-request/create-transaction-request.ts
import { ZeroBytes32 as ZeroBytes326 } from "@fuel-ts/address/configs";
import { bn as bn8 } from "@fuel-ts/math";
import { TransactionType as TransactionType3, OutputType as OutputType4 } from "@fuel-ts/transactions";
import { arrayify as arrayify6, hexlify as hexlify9 } from "@fuel-ts/utils";

// src/providers/transaction-request/hash-transaction.ts
import { ZeroBytes32 as ZeroBytes325 } from "@fuel-ts/address/configs";
import { uint64ToBytesBE } from "@fuel-ts/hasher";
import { bn as bn7 } from "@fuel-ts/math";
import { TransactionType as TransactionType2, InputType as InputType3, OutputType as OutputType3, TransactionCoder as TransactionCoder2 } from "@fuel-ts/transactions";
import { concat as concat2 } from "@fuel-ts/utils";
import { sha256 } from "ethers";
import { clone as clone2 } from "ramda";
function hashTransaction(transactionRequest, chainId) {
  const transaction = transactionRequest.toTransaction();
  if (transaction.type === TransactionType2.Script) {
    transaction.receiptsRoot = ZeroBytes325;
  }
  transaction.inputs = transaction.inputs.map((input) => {
    const inputClone = clone2(input);
    switch (inputClone.type) {
      case InputType3.Coin: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.predicateGasUsed = bn7(0);
        return inputClone;
      }
      case InputType3.Message: {
        inputClone.predicateGasUsed = bn7(0);
        return inputClone;
      }
      case InputType3.Contract: {
        inputClone.txPointer = {
          blockHeight: 0,
          txIndex: 0
        };
        inputClone.txID = ZeroBytes325;
        inputClone.outputIndex = 0;
        inputClone.balanceRoot = ZeroBytes325;
        inputClone.stateRoot = ZeroBytes325;
        return inputClone;
      }
      default:
        return inputClone;
    }
  });
  transaction.outputs = transaction.outputs.map((output) => {
    const outputClone = clone2(output);
    switch (outputClone.type) {
      case OutputType3.Contract: {
        outputClone.balanceRoot = ZeroBytes325;
        outputClone.stateRoot = ZeroBytes325;
        return outputClone;
      }
      case OutputType3.Change: {
        outputClone.amount = bn7(0);
        return outputClone;
      }
      case OutputType3.Variable: {
        outputClone.to = ZeroBytes325;
        outputClone.amount = bn7(0);
        outputClone.assetId = ZeroBytes325;
        return outputClone;
      }
      default:
        return outputClone;
    }
  });
  transaction.witnessesCount = 0;
  transaction.witnesses = [];
  const chainIdBytes = uint64ToBytesBE(chainId);
  const concatenatedData = concat2([chainIdBytes, new TransactionCoder2().encode(transaction)]);
  return sha256(concatenatedData);
}

// src/providers/transaction-request/storage-slot.ts
import { arrayify as arrayify5, hexlify as hexlify8 } from "@fuel-ts/utils";
var getStorageValue = (value) => {
  const v = new Uint8Array(32);
  v.set(arrayify5(value));
  return v;
};
var storageSlotify = (storageSlot) => {
  let key;
  let value;
  if (Array.isArray(storageSlot)) {
    key = storageSlot[0];
    value = storageSlot[1];
  } else {
    key = storageSlot.key;
    value = storageSlot.value;
  }
  return {
    key: hexlify8(key),
    value: hexlify8(getStorageValue(value))
  };
};

// src/providers/transaction-request/create-transaction-request.ts
var CreateTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /** Type of the transaction */
  type = TransactionType3.Create;
  /** Witness index of contract bytecode to create */
  bytecodeWitnessIndex;
  /** Salt */
  salt;
  /** List of storage slots to initialize */
  storageSlots;
  /**
   * Creates an instance `CreateTransactionRequest`.
   *
   * @param createTransactionRequestLike - The initial values for the instance
   */
  constructor({
    bytecodeWitnessIndex,
    salt,
    storageSlots,
    ...rest
  } = {}) {
    super(rest);
    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
    this.salt = hexlify9(salt ?? ZeroBytes326);
    this.storageSlots = [...storageSlots ?? []];
  }
  /**
   * Converts the transaction request to a `TransactionCreate`.
   *
   * @returns The transaction create object.
   */
  toTransaction() {
    const baseTransaction = this.getBaseTransaction();
    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
    return {
      type: TransactionType3.Create,
      ...baseTransaction,
      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
      bytecodeWitnessIndex,
      storageSlotsCount: storageSlots.length,
      salt: this.salt ? hexlify9(this.salt) : ZeroBytes326,
      storageSlots
    };
  }
  /**
   * Get contract created outputs for the transaction.
   *
   * @returns An array of contract created transaction request outputs.
   */
  getContractCreatedOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType4.ContractCreated
    );
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Adds a contract created output to the transaction request.
   *
   * @param contractId - The contract ID.
   * @param stateRoot - The state root.
   */
  addContractCreatedOutput(contractId, stateRoot) {
    this.pushOutput({
      type: OutputType4.ContractCreated,
      contractId,
      stateRoot
    });
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxCreate({
      contractBytesSize: bn8(arrayify6(this.witnesses[this.bytecodeWitnessIndex] || "0x").length),
      gasCosts,
      stateRootSize: this.storageSlots.length,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/script-transaction-request.ts
import { Interface } from "@fuel-ts/abi-coder";
import { addressify as addressify2 } from "@fuel-ts/address";
import { ZeroBytes32 as ZeroBytes327 } from "@fuel-ts/address/configs";
import { bn as bn9 } from "@fuel-ts/math";
import { InputType as InputType4, OutputType as OutputType5, TransactionType as TransactionType4 } from "@fuel-ts/transactions";
import { arrayify as arrayify8, hexlify as hexlify10 } from "@fuel-ts/utils";

// src/providers/transaction-request/scripts.ts
import { arrayify as arrayify7 } from "@fuel-ts/utils";
var returnZeroScript = {
  /*
      Opcode::RET(REG_ZERO)
      Opcode::NOOP
    */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: arrayify7("0x24000000"),
  encodeScriptData: () => new Uint8Array(0)
};
var withdrawScript = {
  /*
          The following code loads some basic values into registers and calls SMO to create an output message
          5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
          5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
          4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
          24000000	- RET                [return 0]
          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
          00000000 00000000 [amount value]
      */
  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
  bytes: arrayify7("0x5040C0105D44C0064C40001124000000"),
  encodeScriptData: () => new Uint8Array(0)
};

// src/providers/transaction-request/script-transaction-request.ts
var ScriptTransactionRequest = class extends BaseTransactionRequest {
  static from(obj) {
    if (obj instanceof this) {
      return obj;
    }
    return new this(obj);
  }
  /** Type of the transaction */
  type = TransactionType4.Script;
  /** Gas limit for transaction */
  gasLimit;
  /** Script to execute */
  script;
  /** Script input data (parameters) */
  scriptData;
  /**
   * Constructor for `ScriptTransactionRequest`.
   *
   * @param scriptTransactionRequestLike - The initial values for the instance.
   */
  constructor({ script, scriptData, gasLimit, ...rest } = {}) {
    super(rest);
    this.gasLimit = bn9(gasLimit);
    this.script = arrayify8(script ?? returnZeroScript.bytes);
    this.scriptData = arrayify8(scriptData ?? returnZeroScript.encodeScriptData());
  }
  /**
   * Converts the transaction request to a `TransactionScript`.
   *
   * @returns The transaction script object.
   */
  toTransaction() {
    const script = arrayify8(this.script ?? "0x");
    const scriptData = arrayify8(this.scriptData ?? "0x");
    return {
      type: TransactionType4.Script,
      scriptGasLimit: this.gasLimit,
      ...super.getBaseTransaction(),
      scriptLength: script.length,
      scriptDataLength: scriptData.length,
      receiptsRoot: ZeroBytes327,
      script: hexlify10(script),
      scriptData: hexlify10(scriptData)
    };
  }
  /**
   * Get contract inputs for the transaction.
   *
   * @returns An array of contract transaction request inputs.
   */
  getContractInputs() {
    return this.inputs.filter(
      (input) => input.type === InputType4.Contract
    );
  }
  /**
   * Get contract outputs for the transaction.
   *
   * @returns An array of contract transaction request outputs.
   */
  getContractOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType5.Contract
    );
  }
  /**
   * Get variable outputs for the transaction.
   *
   * @returns An array of variable transaction request outputs.
   */
  getVariableOutputs() {
    return this.outputs.filter(
      (output) => output.type === OutputType5.Variable
    );
  }
  /**
   * Set the script and its data.
   *
   * @param script - The abstract script request.
   * @param data - The script data.
   */
  setScript(script, data) {
    this.scriptData = script.encodeScriptData(data);
    this.script = script.bytes;
  }
  /**
   * Adds variable outputs to the transaction request.
   *
   * @param numberOfVariables - The number of variables to add.
   * @returns The new length of the outputs array.
   */
  addVariableOutputs(numberOfVariables = 1) {
    let outputsNumber = numberOfVariables;
    while (outputsNumber) {
      this.pushOutput({
        type: OutputType5.Variable
      });
      outputsNumber -= 1;
    }
    return this.outputs.length - 1;
  }
  calculateMaxGas(chainInfo, minGas) {
    const { consensusParameters } = chainInfo;
    const { gasPerByte } = consensusParameters;
    const witnessesLength = this.toTransaction().witnesses.reduce(
      (acc, wit) => acc + wit.dataLength,
      0
    );
    return getMaxGas({
      gasPerByte,
      minGas,
      witnessesLength,
      witnessLimit: this.witnessLimit,
      gasLimit: this.gasLimit
    });
  }
  /**
   * Adds a contract input and output to the transaction request.
   *
   * @param contract - The contract ID.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  addContractInputAndOutput(contract) {
    const contractAddress = addressify2(contract);
    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
      return this;
    }
    const inputIndex = super.pushInput({
      type: InputType4.Contract,
      contractId: contractAddress.toB256(),
      txPointer: "0x00000000000000000000000000000000"
    });
    this.pushOutput({
      type: OutputType5.Contract,
      inputIndex
    });
    return this;
  }
  /**
   * Gets the Transaction Request by hashing the transaction.
   *
   * @param chainId - The chain ID.
   *
   * @returns - A hash of the transaction, which is the transaction ID.
   */
  getTransactionId(chainId) {
    return hashTransaction(this, chainId);
  }
  /**
   * Sets the data for the transaction request.
   *
   * @param abi - Script JSON ABI.
   * @param args - The input arguments.
   * @returns The current instance of the `ScriptTransactionRequest`.
   */
  setData(abi, args) {
    const abiInterface = new Interface(abi);
    this.scriptData = abiInterface.functions.main.encodeArguments(args);
    return this;
  }
  metadataGas(gasCosts) {
    return calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: this.byteSize()
    });
  }
};

// src/providers/transaction-request/utils.ts
import { ErrorCode as ErrorCode6, FuelError as FuelError7 } from "@fuel-ts/errors";
import { TransactionType as TransactionType5 } from "@fuel-ts/transactions";
var transactionRequestify = (obj) => {
  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
    return obj;
  }
  const { type } = obj;
  switch (obj.type) {
    case TransactionType5.Script: {
      return ScriptTransactionRequest.from(obj);
    }
    case TransactionType5.Create: {
      return CreateTransactionRequest.from(obj);
    }
    default: {
      throw new FuelError7(ErrorCode6.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}.`);
    }
  }
};

// src/providers/transaction-response/transaction-response.ts
import { ErrorCode as ErrorCode10, FuelError as FuelError11 } from "@fuel-ts/errors";
import { bn as bn13 } from "@fuel-ts/math";
import { TransactionCoder as TransactionCoder4 } from "@fuel-ts/transactions";
import { arrayify as arrayify10 } from "@fuel-ts/utils";

// src/providers/transaction-summary/assemble-transaction-summary.ts
import { DateTime, hexlify as hexlify11 } from "@fuel-ts/utils";

// src/providers/transaction-summary/calculate-transaction-fee.ts
import { bn as bn10 } from "@fuel-ts/math";
import { PolicyType as PolicyType2, TransactionCoder as TransactionCoder3, TransactionType as TransactionType6 } from "@fuel-ts/transactions";
import { arrayify as arrayify9 } from "@fuel-ts/utils";
var calculateTransactionFee = (params) => {
  const {
    gasUsed,
    rawPayload,
    consensusParameters: { gasCosts, feeParams }
  } = params;
  const gasPerByte = bn10(feeParams.gasPerByte);
  const gasPriceFactor = bn10(feeParams.gasPriceFactor);
  const transactionBytes = arrayify9(rawPayload);
  const [transaction] = new TransactionCoder3().decode(transactionBytes, 0);
  if (transaction.type === TransactionType6.Mint) {
    return {
      fee: bn10(0),
      minFee: bn10(0),
      maxFee: bn10(0),
      feeFromGasUsed: bn10(0)
    };
  }
  const { type, witnesses, inputs, policies } = transaction;
  let metadataGas = bn10(0);
  let gasLimit = bn10(0);
  if (type === TransactionType6.Create) {
    const { bytecodeWitnessIndex, storageSlots } = transaction;
    const contractBytesSize = bn10(arrayify9(witnesses[bytecodeWitnessIndex].data).length);
    metadataGas = calculateMetadataGasForTxCreate({
      contractBytesSize,
      gasCosts,
      stateRootSize: storageSlots.length || 0,
      txBytesSize: transactionBytes.length
    });
  } else {
    const { scriptGasLimit } = transaction;
    if (scriptGasLimit) {
      gasLimit = scriptGasLimit;
    }
    metadataGas = calculateMetadataGasForTxScript({
      gasCosts,
      txBytesSize: transactionBytes.length
    });
  }
  const minGas = getMinGas({
    gasCosts,
    gasPerByte: bn10(gasPerByte),
    inputs,
    metadataGas,
    txBytesSize: transactionBytes.length
  });
  const gasPrice = bn10(policies.find((policy) => policy.type === PolicyType2.GasPrice)?.data);
  const witnessLimit = policies.find((policy) => policy.type === PolicyType2.WitnessLimit)?.data;
  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);
  const maxGas = getMaxGas({
    gasPerByte,
    minGas,
    witnessesLength,
    gasLimit,
    witnessLimit
  });
  const feeFromGasUsed = calculatePriceWithFactor(gasUsed, gasPrice, gasPriceFactor);
  const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor);
  const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor);
  const fee = minFee.add(feeFromGasUsed);
  return {
    fee,
    minFee,
    maxFee,
    feeFromGasUsed
  };
};

// src/providers/transaction-summary/operations.ts
import { ZeroBytes32 as ZeroBytes328 } from "@fuel-ts/address/configs";
import { ErrorCode as ErrorCode8, FuelError as FuelError9 } from "@fuel-ts/errors";
import { bn as bn12 } from "@fuel-ts/math";
import { ReceiptType as ReceiptType3, TransactionType as TransactionType7 } from "@fuel-ts/transactions";

// src/providers/transaction-summary/call.ts
import { Interface as Interface2, calculateVmTxMemory } from "@fuel-ts/abi-coder";
import { bn as bn11 } from "@fuel-ts/math";
var getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }) => {
  const abiInterface = new Interface2(abi);
  const callFunctionSelector = receipt.param1.toHex(8);
  const functionFragment = abiInterface.getFunction(callFunctionSelector);
  const inputs = functionFragment.jsonFn.inputs;
  let encodedArgs;
  if (functionFragment.isInputDataPointer) {
    if (rawPayload) {
      const argsOffset = bn11(receipt.param2).sub(calculateVmTxMemory({ maxInputs: maxInputs.toNumber() })).toNumber();
      encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
    }
  } else {
    encodedArgs = receipt.param2.toHex();
  }
  let argumentsProvided;
  if (encodedArgs) {
    const data = functionFragment.decodeArguments(encodedArgs);
    if (data) {
      argumentsProvided = inputs.reduce((prev, input, index) => {
        const value = data[index];
        const name = input.name;
        if (name) {
          return {
            ...prev,
            // reparse to remove bn
            [name]: JSON.parse(JSON.stringify(value))
          };
        }
        return prev;
      }, {});
    }
  }
  const call = {
    functionSignature: functionFragment.signature,
    functionName: functionFragment.name,
    argumentsProvided,
    ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
  };
  return call;
};

// src/providers/transaction-summary/input.ts
import { ErrorCode as ErrorCode7, FuelError as FuelError8 } from "@fuel-ts/errors";
import { InputType as InputType5 } from "@fuel-ts/transactions";
function getInputsByTypes(inputs, types) {
  return inputs.filter((i) => types.includes(i.type));
}
function getInputsByType(inputs, type) {
  return inputs.filter((i) => i.type === type);
}
function getInputsCoin(inputs) {
  return getInputsByType(inputs, InputType5.Coin);
}
function getInputsMessage(inputs) {
  return getInputsByType(inputs, InputType5.Message);
}
function getInputsCoinAndMessage(inputs) {
  return getInputsByTypes(inputs, [InputType5.Coin, InputType5.Message]);
}
function getInputsContract(inputs) {
  return getInputsByType(inputs, InputType5.Contract);
}
function getInputFromAssetId(inputs, assetId) {
  const coinInputs = getInputsCoin(inputs);
  const messageInputs = getInputsMessage(inputs);
  const coinInput = coinInputs.find((i) => i.assetId === assetId);
  const messageInput = messageInputs.find(
    (_) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
  );
  return coinInput || messageInput;
}
function getInputContractFromIndex(inputs, inputIndex) {
  if (inputIndex == null) {
    return void 0;
  }
  const contractInput = inputs?.[inputIndex];
  if (!contractInput) {
    return void 0;
  }
  if (contractInput.type !== InputType5.Contract) {
    throw new FuelError8(
      ErrorCode7.INVALID_TRANSACTION_INPUT,
      `Contract input should be of type 'contract'.`
    );
  }
  return contractInput;
}
function getInputAccountAddress(input) {
  if (input.type === InputType5.Coin) {
    return input.owner.toString();
  }
  if (input.type === InputType5.Message) {
    return input.recipient.toString();
  }
  return "";
}

// src/providers/transaction-summary/output.ts
import { OutputType as OutputType6 } from "@fuel-ts/transactions";
function getOutputsByType(outputs, type) {
  return outputs.filter((o) => o.type === type);
}
function getOutputsContractCreated(outputs) {
  return getOutputsByType(outputs, OutputType6.ContractCreated);
}
function getOutputsCoin(outputs) {
  return getOutputsByType(outputs, OutputType6.Coin);
}
function getOutputsChange(outputs) {
  return getOutputsByType(outputs, OutputType6.Change);
}
function getOutputsContract(outputs) {
  return getOutputsByType(outputs, OutputType6.Contract);
}

// src/providers/transaction-summary/operations.ts
function getReceiptsByType(receipts, type) {
  return (receipts ?? []).filter((r) => r.type === type);
}
function getTransactionTypeName(transactionType) {
  switch (transactionType) {
    case TransactionType7.Mint:
      return "Mint" /* Mint */;
    case TransactionType7.Create:
      return "Create" /* Create */;
    case TransactionType7.Script:
      return "Script" /* Script */;
    default:
      throw new FuelError9(
        ErrorCode8.INVALID_TRANSACTION_TYPE,
        `Invalid transaction type: ${transactionType}.`
      );
  }
}
function isType(transactionType, type) {
  const txType = getTransactionTypeName(transactionType);
  return txType === type;
}
function isTypeMint(transactionType) {
  return isType(transactionType, "Mint" /* Mint */);
}
function isTypeCreate(transactionType) {
  return isType(transactionType, "Create" /* Create */);
}
function isTypeScript(transactionType) {
  return isType(transactionType, "Script" /* Script */);
}
function getReceiptsCall(receipts) {
  return getReceiptsByType(receipts, ReceiptType3.Call);
}
function getReceiptsMessageOut(receipts) {
  return getReceiptsByType(receipts, ReceiptType3.MessageOut);
}
var mergeAssets = (op1, op2) => {
  const assets1 = op1.assetsSent || [];
  const assets2 = op2.assetsSent || [];
  const filteredAssets = assets2.filter(
    (asset2) => !assets1.some((asset1) => asset1.assetId === asset2.assetId)
  );
  const mergedAssets = assets1.map((asset1) => {
    const matchingAsset = assets2.find((asset2) => asset2.assetId === asset1.assetId);
    if (!matchingAsset) {
      return asset1;
    }
    const mergedAmount = bn12(asset1.amount).add(matchingAsset.amount);
    return { ...asset1, amount: mergedAmount };
  });
  return mergedAssets.concat(filteredAssets);
};
function isSameOperation(a, b) {
  return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
}
function addOperation(operations, toAdd) {
  const allOperations = [...operations];
  const index = allOperations.findIndex((op) => isSameOperation(op, toAdd));
  if (allOperations[index]) {
    const existentOperation = { ...allOperations[index] };
    if (toAdd.assetsSent?.length) {
      existentOperation.assetsSent = existentOperation.assetsSent?.length ? mergeAssets(existentOperation, toAdd) : toAdd.assetsSent;
    }
    if (toAdd.calls?.length) {
      existentOperation.calls = [...existentOperation.calls || [], ...toAdd.calls];
    }
    allOperations[index] = existentOperation;
  } else {
    allOperations.push(toAdd);
  }
  return allOperations;
}
function getWithdrawFromFuelOperations({
  inputs,
  receipts
}) {
  const messageOutReceipts = getReceiptsMessageOut(receipts);
  const withdrawFromFuelOperations = messageOutReceipts.reduce(
    (prevWithdrawFromFuelOps, receipt) => {
      const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
      const input = getInputFromAssetId(inputs, assetId);
      if (input) {
        const inputAddress = getInputAccountAddress(input);
        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
          name: "Withdraw from Fuel" /* withdrawFromFuel */,
          from: {
            type: 1 /* account */,
            address: inputAddress
          },
          to: {
            type: 1 /* account */,
            address: receipt.recipient.toString(),
            chain: "ethereum" /* ethereum */
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId
            }
          ]
        });
        return newWithdrawFromFuelOps;
      }
      return prevWithdrawFromFuelOps;
    },
    []
  );
  return withdrawFromFuelOperations;
}
function getContractCallOperations({
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  const contractCallReceipts = getReceiptsCall(receipts);
  const contractOutputs = getOutputsContract(outputs);
  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output) => {
    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);
    if (contractInput) {
      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
        if (receipt.to === contractInput.contractID) {
          const input = getInputFromAssetId(inputs, receipt.assetId);
          if (input) {
            const inputAddress = getInputAccountAddress(input);
            const calls = [];
            const abi = abiMap?.[contractInput.contractID];
            if (abi) {
              calls.push(
                getFunctionCall({
                  abi,
                  receipt,
                  rawPayload,
                  maxInputs
                })
              );
            }
            const newContractCallOps = addOperation(prevContractCallOps, {
              name: "Contract call" /* contractCall */,
              from: {
                type: 1 /* account */,
                address: inputAddress
              },
              to: {
                type: 0 /* contract */,
                address: receipt.to
              },
              // if no amount is forwarded to the contract, skip showing assetsSent
              assetsSent: receipt.amount?.isZero() ? void 0 : [
                {
                  amount: receipt.amount,
                  assetId: receipt.assetId
                }
              ],
              calls
            });
            return newContractCallOps;
          }
        }
        return prevContractCallOps;
      }, prevOutputCallOps);
      return newCallOps;
    }
    return prevOutputCallOps;
  }, []);
  return contractCallOperations;
}
function extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {
  const { to: toAddress, assetId, amount } = receipt;
  let { from: fromAddress } = receipt;
  const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 /* contract */ : 1 /* account */;
  if (ZeroBytes328 === fromAddress) {
    const change = changeOutputs.find((output) => output.assetId === assetId);
    fromAddress = change?.to || fromAddress;
  }
  const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 /* contract */ : 1 /* account */;
  return {
    name: "Transfer asset" /* transfer */,
    from: {
      type: fromType,
      address: fromAddress
    },
    to: {
      type: toType,
      address: toAddress
    },
    assetsSent: [
      {
        assetId: assetId.toString(),
        amount
      }
    ]
  };
}
function getTransferOperations({
  inputs,
  outputs,
  receipts
}) {
  let operations = [];
  const coinOutputs = getOutputsCoin(outputs);
  const contractInputs = getInputsContract(inputs);
  const changeOutputs = getOutputsChange(outputs);
  coinOutputs.forEach((output) => {
    const { amount, assetId, to } = output;
    const changeOutput = changeOutputs.find((change) => change.assetId === assetId);
    if (changeOutput) {
      operations = addOperation(operations, {
        name: "Transfer asset" /* transfer */,
        from: {
          type: 1 /* account */,
          address: changeOutput.to
        },
        to: {
          type: 1 /* account */,
          address: to
        },
        assetsSent: [
          {
            assetId,
            amount
          }
        ]
      });
    }
  });
  const transferReceipts = getReceiptsByType(
    receipts,
    ReceiptType3.Transfer
  );
  const transferOutReceipts = getReceiptsByType(
    receipts,
    ReceiptType3.TransferOut
  );
  [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {
    const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);
    operations = addOperation(operations, operation);
  });
  return operations;
}
function getPayProducerOperations(outputs) {
  const coinOutputs = getOutputsCoin(outputs);
  const payProducerOperations = coinOutputs.reduce((prev, output) => {
    const operations = addOperation(prev, {
      name: "Pay network fee to block producer" /* payBlockProducer */,
      from: {
        type: 1 /* account */,
        address: "Network"
      },
      to: {
        type: 1 /* account */,
        address: output.to.toString()
      },
      assetsSent: [
        {
          assetId: output.assetId.toString(),
          amount: output.amount
        }
      ]
    });
    return operations;
  }, []);
  return payProducerOperations;
}
function getContractCreatedOperations({ inputs, outputs }) {
  const contractCreatedOutputs = getOutputsContractCreated(outputs);
  const input = getInputsCoinAndMessage(inputs)[0];
  const fromAddress = getInputAccountAddress(input);
  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
    const operations = addOperation(prev, {
      name: "Contract created" /* contractCreated */,
      from: {
        type: 1 /* account */,
        address: fromAddress
      },
      to: {
        type: 0 /* contract */,
        address: contractCreatedOutput?.contractId || ""
      }
    });
    return operations;
  }, []);
  return contractCreatedOperations;
}
function getOperations({
  transactionType,
  inputs,
  outputs,
  receipts,
  abiMap,
  rawPayload,
  maxInputs
}) {
  if (isTypeCreate(transactionType)) {
    return [
      ...getContractCreatedOperations({ inputs, outputs }),
      ...getTransferOperations({ inputs, outputs, receipts })
    ];
  }
  if (isTypeScript(transactionType)) {
    return [
      ...getTransferOperations({ inputs, outputs, receipts }),
      ...getContractCallOperations({
        inputs,
        outputs,
        receipts,
        abiMap,
        rawPayload,
        maxInputs
      }),
      ...getWithdrawFromFuelOperations({ inputs, receipts })
    ];
  }
  return [...getPayProducerOperations(outputs)];
}

// src/providers/transaction-summary/receipt.ts
import { ReceiptType as ReceiptType4 } from "@fuel-ts/transactions";
var processGqlReceipt = (gqlReceipt) => {
  const receipt = assembleReceiptByType(gqlReceipt);
  switch (receipt.type) {
    case ReceiptType4.ReturnData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    case ReceiptType4.LogData: {
      return {
        ...receipt,
        data: gqlReceipt.data || "0x"
      };
    }
    default:
      return receipt;
  }
};
var extractMintedAssetsFromReceipts = (receipts) => {
  const mintedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType4.Mint) {
      mintedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return mintedAssets;
};
var extractBurnedAssetsFromReceipts = (receipts) => {
  const burnedAssets = [];
  receipts.forEach((receipt) => {
    if (receipt.type === ReceiptType4.Burn) {
      burnedAssets.push({
        subId: receipt.subId,
        contractId: receipt.contractId,
        assetId: receipt.assetId,
        amount: receipt.val
      });
    }
  });
  return burnedAssets;
};

// src/providers/transaction-summary/status.ts
import { ErrorCode as ErrorCode9, FuelError as FuelError10 } from "@fuel-ts/errors";
var getTransactionStatusName = (gqlStatus) => {
  switch (gqlStatus) {
    case "FailureStatus":
      return "failure" /* failure */;
    case "SuccessStatus":
      return "success" /* success */;
    case "SubmittedStatus":
      return "submitted" /* submitted */;
    case "SqueezedOutStatus":
      return "squeezedout" /* squeezedout */;
    default:
      throw new FuelError10(
        ErrorCode9.INVALID_TRANSACTION_STATUS,
        `Invalid transaction status: ${gqlStatus}.`
      );
  }
};
var processGraphqlStatus = (gqlTransactionStatus) => {
  let time;
  let blockId;
  let status;
  let isStatusFailure = false;
  let isStatusSuccess = false;
  let isStatusPending = false;
  if (gqlTransactionStatus?.type) {
    status = getTransactionStatusName(gqlTransactionStatus.type);
    switch (gqlTransactionStatus.type) {
      case "SuccessStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusSuccess = true;
        break;
      case "FailureStatus":
        time = gqlTransactionStatus.time;
        blockId = gqlTransactionStatus.block.id;
        isStatusFailure = true;
        break;
      case "SubmittedStatus":
        time = gqlTransactionStatus.time;
        isStatusPending = true;
        break;
      default:
    }
  }
  const processedGraphqlStatus = {
    time,
    blockId,
    status,
    isStatusFailure,
    isStatusSuccess,
    isStatusPending
  };
  return processedGraphqlStatus;
};

// src/providers/transaction-summary/assemble-transaction-summary.ts
function assembleTransactionSummary(params) {
  const {
    id,
    receipts,
    gasPerByte,
    gasPriceFactor,
    transaction,
    transactionBytes,
    gqlTransactionStatus,
    abiMap = {},
    maxInputs,
    gasCosts
  } = params;
  const gasUsed = getGasUsedFromReceipts(receipts);
  const rawPayload = hexlify11(transactionBytes);
  const operations = getOperations({
    transactionType: transaction.type,
    inputs: transaction.inputs || [],
    outputs: transaction.outputs || [],
    receipts,
    rawPayload,
    abiMap,
    maxInputs
  });
  const typeName = getTransactionTypeName(transaction.type);
  const { fee } = calculateTransactionFee({
    gasUsed,
    rawPayload,
    consensusParameters: {
      gasCosts,
      feeParams: {
        gasPerByte,
        gasPriceFactor
      }
    }
  });
  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus(gqlTransactionStatus);
  const mintedAssets = extractMintedAssetsFromReceipts(receipts);
  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
  let date;
  if (time) {
    date = DateTime.fromTai64(time);
  }
  const transactionSummary = {
    id,
    fee,
    gasUsed,
    operations,
    type: typeName,
    blockId,
    time,
    status,
    receipts,
    mintedAssets,
    burnedAssets,
    isTypeMint: isTypeMint(transaction.type),
    isTypeCreate: isTypeCreate(transaction.type),
    isTypeScript: isTypeScript(transaction.type),
    isStatusFailure,
    isStatusSuccess,
    isStatusPending,
    date,
    transaction
  };
  return transactionSummary;
}

// src/providers/transaction-response/transaction-response.ts
var TransactionResponse = class {
  /** Transaction ID */
  id;
  /** Current provider */
  provider;
  /** Gas used on the transaction */
  gasUsed = bn13(0);
  /** The graphql Transaction with receipts object. */
  gqlTransaction;
  /**
   * Constructor for `TransactionResponse`.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  constructor(id, provider) {
    this.id = id;
    this.provider = provider;
  }
  /**
   * Async constructor for `TransactionResponse`. This method can be used to create
   * an instance of `TransactionResponse` and wait for the transaction to be fetched
   * from the chain, ensuring that the `gqlTransaction` property is set.
   *
   * @param id - The transaction ID.
   * @param provider - The provider.
   */
  static async create(id, provider) {
    const response = new TransactionResponse(id, provider);
    await response.fetch();
    return response;
  }
  /**
   * Fetch the transaction with receipts from the provider.
   *
   * @returns Transaction with receipts query result.
   */
  async fetch() {
    const response = await this.provider.operations.getTransactionWithReceipts({
      transactionId: this.id
    });
    if (!response.transaction) {
      const subscription = this.provider.operations.statusChange({
        transactionId: this.id
      });
      for await (const { statusChange } of subscription) {
        if (statusChange) {
          break;
        }
      }
      return this.fetch();
    }
    this.gqlTransaction = response.transaction;
    return response.transaction;
  }
  /**
   * Decode the raw payload of the transaction.
   *
   * @param transactionWithReceipts - The transaction with receipts object.
   * @returns The decoded transaction.
   */
  decodeTransaction(transactionWithReceipts) {
    return new TransactionCoder4().decode(
      arrayify10(transactionWithReceipts.rawPayload),
      0
    )?.[0];
  }
  /**
   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
   * fetch it from the provider
   *
   * @param contractsAbiMap - The contracts ABI map.
   * @returns
   */
  async getTransactionSummary(contractsAbiMap) {
    let transaction = this.gqlTransaction;
    if (!transaction) {
      transaction = await this.fetch();
    }
    const decodedTransaction = this.decodeTransaction(
      transaction
    );
    const receipts = transaction.receipts?.map(processGqlReceipt) || [];
    const { gasPerByte, gasPriceFactor, gasCosts } = this.provider.getGasConfig();
    const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
    const transactionSummary = assembleTransactionSummary({
      id: this.id,
      receipts,
      transaction: decodedTransaction,
      transactionBytes: arrayify10(transaction.rawPayload),
      gqlTransactionStatus: transaction.status,
      gasPerByte,
      gasPriceFactor,
      abiMap: contractsAbiMap,
      maxInputs,
      gasCosts
    });
    return transactionSummary;
  }
  async waitForStatusChange() {
    const status = this.gqlTransaction?.status?.type;
    if (status && status !== "SubmittedStatus") {
      return;
    }
    const subscription = this.provider.operations.statusChange({
      transactionId: this.id
    });
    for await (const { statusChange } of subscription) {
      if (statusChange.type !== "SubmittedStatus") {
        break;
      }
    }
    await this.fetch();
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @returns The completed transaction result
   */
  async waitForResult(contractsAbiMap) {
    await this.waitForStatusChange();
    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
    const transactionResult = {
      gqlTransaction: this.gqlTransaction,
      ...transactionSummary
    };
    return transactionResult;
  }
  /**
   * Waits for transaction to complete and returns the result.
   *
   * @param contractsAbiMap - The contracts ABI map.
   */
  async wait(contractsAbiMap) {
    const result = await this.waitForResult(contractsAbiMap);
    if (result.isStatusFailure) {
      throw new FuelError11(
        ErrorCode10.TRANSACTION_FAILED,
        `Transaction failed: ${result.gqlTransaction.status.reason}`
      );
    }
    return result;
  }
};

// src/providers/transaction-response/getDecodedLogs.ts
import { BigNumberCoder } from "@fuel-ts/abi-coder";
import { ReceiptType as ReceiptType5 } from "@fuel-ts/transactions";

// src/providers/utils/auto-retry-fetch.ts
function getWaitDelay(options, retryAttemptNum) {
  const duration = options.baseDelay ?? 150;
  switch (options.backoff) {
    case "linear":
      return duration * retryAttemptNum;
    case "fixed":
      return duration;
    case "exponential":
    default:
      return 2 ** (retryAttemptNum - 1) * duration;
  }
}
function autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {
  if (options === void 0) {
    return fetchFn;
  }
  return async (...args) => {
    try {
      return await fetchFn(...args);
    } catch (_error) {
      const error = _error;
      if (error.cause?.code !== "ECONNREFUSED") {
        throw error;
      }
      const retryNum = retryAttemptNum + 1;
      if (retryNum > options.maxRetries) {
        throw error;
      }
      const delay = getWaitDelay(options, retryNum);
      await sleep(delay);
      return autoRetryFetch(fetchFn, options, retryNum)(...args);
    }
  };
}

// src/providers/utils/merge-quantities.ts
var mergeQuantities = (arr1, arr2) => {
  const resultMap = {};
  function addToMap({ amount, assetId }) {
    if (resultMap[assetId]) {
      resultMap[assetId] = resultMap[assetId].add(amount);
    } else {
      resultMap[assetId] = amount;
    }
  }
  arr1.forEach(addToMap);
  arr2.forEach(addToMap);
  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
};

// src/providers/provider.ts
var MAX_RETRIES = 10;
var processGqlChain = (chain) => {
  const { name, daHeight, consensusParameters, latestBlock } = chain;
  const { contractParams, feeParams, predicateParams, scriptParams, txParams, gasCosts } = consensusParameters;
  return {
    name,
    baseChainHeight: bn14(daHeight),
    consensusParameters: {
      contractMaxSize: bn14(contractParams.contractMaxSize),
      maxInputs: bn14(txParams.maxInputs),
      maxOutputs: bn14(txParams.maxOutputs),
      maxWitnesses: bn14(txParams.maxWitnesses),
      maxGasPerTx: bn14(txParams.maxGasPerTx),
      maxScriptLength: bn14(scriptParams.maxScriptLength),
      maxScriptDataLength: bn14(scriptParams.maxScriptDataLength),
      maxStorageSlots: bn14(contractParams.maxStorageSlots),
      maxPredicateLength: bn14(predicateParams.maxPredicateLength),
      maxPredicateDataLength: bn14(predicateParams.maxPredicateDataLength),
      maxGasPerPredicate: bn14(predicateParams.maxGasPerPredicate),
      gasPriceFactor: bn14(feeParams.gasPriceFactor),
      gasPerByte: bn14(feeParams.gasPerByte),
      maxMessageDataLength: bn14(predicateParams.maxMessageDataLength),
      chainId: bn14(consensusParameters.chainId),
      gasCosts
    },
    gasCosts,
    latestBlock: {
      id: latestBlock.id,
      height: bn14(latestBlock.header.height),
      time: latestBlock.header.time,
      transactions: latestBlock.transactions.map((i) => ({
        id: i.id
      }))
    }
  };
};
var _cacheInputs, cacheInputs_fn;
var _Provider = class {
  /**
   * Constructor to initialize a Provider.
   *
   * @param url - GraphQL endpoint of the Fuel node
   * @param chainInfo - Chain info of the Fuel node
   * @param options - Additional options for the provider
   * @hidden
   */
  constructor(url, options = {}) {
    this.url = url;
    /**
     * @hidden
     */
    __privateAdd(this, _cacheInputs);
    __publicField(this, "operations");
    __publicField(this, "cache");
    __publicField(this, "options", {
      timeout: void 0,
      cacheUtxo: void 0,
      fetch: void 0,
      retryOptions: void 0
    });
    this.options = { ...this.options, ...options };
    this.url = url;
    this.operations = this.createOperations();
    this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : void 0;
  }
  static clearChainAndNodeCaches() {
    _Provider.nodeInfoCache = {};
    _Provider.chainInfoCache = {};
  }
  static getFetchFn(options) {
    const { retryOptions, timeout } = options;
    return autoRetryFetch((...args) => {
      if (options.fetch) {
        return options.fetch(...args);
      }
      const url = args[0];
      const request = args[1];
      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;
      return fetch(url, { ...request, signal });
    }, retryOptions);
  }
  /**
   * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
   * @param url - GraphQL endpoint of the Fuel node
   * @param options - Additional options for the provider
   */
  static async create(url, options = {}) {
    const provider = new _Provider(url, options);
    await provider.fetchChainAndNodeInfo();
    return provider;
  }
  /**
   * Returns the cached chainInfo for the current URL.
   */
  getChain() {
    const chain = _Provider.chainInfoCache[this.url];
    if (!chain) {
      throw new FuelError12(
        ErrorCode11.CHAIN_INFO_CACHE_EMPTY,
        "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return chain;
  }
  /**
   * Returns the cached nodeInfo for the current URL.
   */
  getNode() {
    const node = _Provider.nodeInfoCache[this.url];
    if (!node) {
      throw new FuelError12(
        ErrorCode11.NODE_INFO_CACHE_EMPTY,
        "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
      );
    }
    return node;
  }
  /**
   * Returns some helpful parameters related to gas fees.
   */
  getGasConfig() {
    const { minGasPrice } = this.getNode();
    const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte, gasCosts } = this.getChain().consensusParameters;
    return {
      minGasPrice,
      maxGasPerTx,
      maxGasPerPredicate,
      gasPriceFactor,
      gasPerByte,
      gasCosts
    };
  }
  /**
   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
   */
  async connect(url, options) {
    this.url = url;
    this.options = options ?? this.options;
    this.operations = this.createOperations();
    await this.fetchChainAndNodeInfo();
  }
  /**
   * Fetches both the chain and node information, saves it to the cache, and return it.
   *
   * @returns NodeInfo and Chain
   */
  async fetchChainAndNodeInfo() {
    const chain = await this.fetchChain();
    const nodeInfo = await this.fetchNode();
    _Provider.ensureClientVersionIsSupported(nodeInfo);
    return {
      chain,
      nodeInfo
    };
  }
  static ensureClientVersionIsSupported(nodeInfo) {
    const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
    if (!isMajorSupported || !isMinorSupported) {
      throw new FuelError12(
        FuelError12.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,
        `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`
      );
    }
  }
  /**
   * Create GraphQL client and set operations.
   *
   * @returns The operation SDK object
   */
  createOperations() {
    const fetchFn = _Provider.getFetchFn(this.options);
    const gqlClient = new GraphQLClient(this.url, {
      fetch: (url, requestInit) => fetchFn(url, requestInit, this.options)
    });
    const executeQuery = (query, vars) => {
      const opDefinition = query.definitions.find((x) => x.kind === "OperationDefinition");
      const isSubscription = opDefinition?.operation === "subscription";
      if (isSubscription) {
        return new FuelGraphqlSubscriber({
          url: this.url,
          query,
          fetchFn: (url, requestInit) => fetchFn(url, requestInit, this.options),
          variables: vars
        });
      }
      return gqlClient.request(query, vars);
    };
    return getSdk(executeQuery);
  }
  /**
   * Returns the version of the connected node.
   *
   * @returns A promise that resolves to the version string.
   */
  async getVersion() {
    const {
      nodeInfo: { nodeVersion }
    } = await this.operations.getVersion();
    return nodeVersion;
  }
  /**
   * @hidden
   *
   * Returns the network configuration of the connected Fuel node.
   *
   * @returns A promise that resolves to the network configuration object
   */
  async getNetwork() {
    const {
      name,
      consensusParameters: { chainId }
    } = await this.getChain();
    const network = new Network(name, chainId.toNumber());
    return Promise.resolve(network);
  }
  /**
   * Returns the block number.
   *
   * @returns A promise that resolves to the block number
   */
  async getBlockNumber() {
    const { chain } = await this.operations.getChain();
    return bn14(chain.latestBlock.header.height, 10);
  }
  /**
   * Returns the chain information.
   * @param url - The URL of the Fuel node
   * @returns NodeInfo object
   */
  async fetchNode() {
    const { nodeInfo } = await this.operations.getNodeInfo();
    const processedNodeInfo = {
      maxDepth: bn14(nodeInfo.maxDepth),
      maxTx: bn14(nodeInfo.maxTx),
      minGasPrice: bn14(nodeInfo.minGasPrice),
      nodeVersion: nodeInfo.nodeVersion,
      utxoValidation: nodeInfo.utxoValidation,
      vmBacktrace: nodeInfo.vmBacktrace,
      peers: nodeInfo.peers
    };
    _Provider.nodeInfoCache[this.url] = processedNodeInfo;
    return processedNodeInfo;
  }
  /**
   * Fetches the `chainInfo` for the given node URL.
   * @param url - The URL of the Fuel node
   * @returns ChainInfo object
   */
  async fetchChain() {
    const { chain } = await this.operations.getChain();
    const processedChain = processGqlChain(chain);
    _Provider.chainInfoCache[this.url] = processedChain;
    return processedChain;
  }
  /**
   * Returns the chain ID
   * @returns A promise that resolves to the chain ID number
   */
  getChainId() {
    const {
      consensusParameters: { chainId }
    } = this.getChain();
    return chainId.toNumber();
  }
  /**
   * Submits a transaction to the chain to be executed.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @returns A promise that resolves to the transaction response object.
   */
  // #region Provider-sendTransaction
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution = false } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    __privateMethod(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
    if (estimateTxDependencies) {
      await this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = hexlify12(transactionRequest.toTransactionBytes());
    if (awaitExecution) {
      const subscription = this.operations.submitAndAwait({ encodedTransaction });
      for await (const { submitAndAwait } of subscription) {
        if (submitAndAwait.type !== "SubmittedStatus") {
          break;
        }
      }
      const transactionId2 = transactionRequest.getTransactionId(this.getChainId());
      const response = new TransactionResponse(transactionId2, this);
      await response.fetch();
      return response;
    }
    const {
      submit: { id: transactionId }
    } = await this.operations.submit({ encodedTransaction });
    return new TransactionResponse(transactionId, this);
  }
  /**
   * Executes a transaction without actually submitting it to the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added.
   *
   * @param transactionRequestLike - The transaction request object.
   * @param utxoValidation - Additional provider call parameters.
   * @returns A promise that resolves to the call result object.
   */
  async call(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = hexlify12(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: utxoValidation || false
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  /**
   * Verifies whether enough gas is available to complete transaction.
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise that resolves to the estimated transaction request object.
   */
  async estimatePredicates(transactionRequest) {
    const shouldEstimatePredicates = Boolean(
      transactionRequest.inputs.find(
        (input) => "predicate" in input && input.predicate && !equalBytes(arrayify11(input.predicate), arrayify11("0x")) && new BN(input.predicateGasUsed).isZero()
      )
    );
    if (!shouldEstimatePredicates) {
      return transactionRequest;
    }
    const encodedTransaction = hexlify12(transactionRequest.toTransactionBytes());
    const response = await this.operations.estimatePredicates({
      encodedTransaction
    });
    const {
      estimatePredicates: { inputs }
    } = response;
    if (inputs) {
      inputs.forEach((input, index) => {
        if ("predicateGasUsed" in input && bn14(input.predicateGasUsed).gt(0)) {
          transactionRequest.inputs[index].predicateGasUsed = input.predicateGasUsed;
        }
      });
    }
    return transactionRequest;
  }
  /**
   * Will dryRun a transaction and check for missing dependencies.
   *
   * If there are missing variable outputs,
   * `addVariableOutputs` is called on the transaction.
   *
   * @privateRemarks
   * TODO: Investigate support for missing contract IDs
   * TODO: Add support for missing output messages
   *
   * @param transactionRequest - The transaction request object.
   * @returns A promise.
   */
  async estimateTxDependencies(transactionRequest) {
    if (transactionRequest.type === TransactionType8.Create) {
      return {
        receipts: [],
        outputVariables: 0,
        missingContractIds: []
      };
    }
    await this.estimatePredicates(transactionRequest);
    let receipts = [];
    const missingContractIds = [];
    let outputVariables = 0;
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction: hexlify12(transactionRequest.toTransactionBytes()),
        utxoValidation: false
      });
      receipts = gqlReceipts.map(processGqlReceipt);
      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
      const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;
      if (hasMissingOutputs) {
        outputVariables += missingOutputVariables.length;
        transactionRequest.addVariableOutputs(missingOutputVariables.length);
        missingOutputContractIds.forEach(({ contractId }) => {
          transactionRequest.addContractInputAndOutput(Address2.fromString(contractId));
          missingContractIds.push(contractId);
        });
      } else {
        break;
      }
    }
    return {
      receipts,
      outputVariables,
      missingContractIds
    };
  }
  /**
   * Executes a signed transaction without applying the states changes
   * on the chain.
   *
   * If the transaction is missing any dependencies,
   * the transaction will be mutated and those dependencies will be added
   *
   * @param transactionRequestLike - The transaction request object.
   * @returns A promise that resolves to the call result object.
   */
  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      return this.estimateTxDependencies(transactionRequest);
    }
    const encodedTransaction = hexlify12(transactionRequest.toTransactionBytes());
    const { dryRun: gqlReceipts } = await this.operations.dryRun({
      encodedTransaction,
      utxoValidation: true
    });
    const receipts = gqlReceipts.map(processGqlReceipt);
    return {
      receipts
    };
  }
  /**
   * Returns a transaction cost to enable user
   * to set gasLimit and also reserve balance amounts
   * on the the transaction.
   *
   * @privateRemarks
   * The tolerance is add on top of the gasUsed calculated
   * from the node, this create a safe margin costs like
   * change states on transfer that don't occur on the dryRun
   * transaction. The default value is 0.2 or 20%
   *
   * @param transactionRequestLike - The transaction request object.
   * @param tolerance - The tolerance to add on top of the gasUsed.
   * @returns A promise that resolves to the transaction cost object.
   */
  async getTransactionCost(transactionRequestLike, forwardingQuantities = [], {
    estimateTxDependencies = true,
    estimatePredicates = true,
    resourcesOwner
  } = {}) {
    const txRequestClone = clone3(transactionRequestify(transactionRequestLike));
    const chainInfo = this.getChain();
    const { gasPriceFactor, minGasPrice, maxGasPerTx } = this.getGasConfig();
    const gasPrice = max(txRequestClone.gasPrice, minGasPrice);
    const isScriptTransaction = txRequestClone.type === TransactionType8.Script;
    const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();
    const allQuantities = mergeQuantities(coinOutputsQuantities, forwardingQuantities);
    txRequestClone.fundWithFakeUtxos(allQuantities, resourcesOwner?.address);
    if (estimatePredicates) {
      if (isScriptTransaction) {
        txRequestClone.gasLimit = bn14(0);
      }
      if (resourcesOwner && "populateTransactionPredicateData" in resourcesOwner) {
        resourcesOwner.populateTransactionPredicateData(txRequestClone);
      }
      await this.estimatePredicates(txRequestClone);
    }
    const minGas = txRequestClone.calculateMinGas(chainInfo);
    const maxGas = txRequestClone.calculateMaxGas(chainInfo, minGas);
    let receipts = [];
    let missingContractIds = [];
    let outputVariables = 0;
    if (isScriptTransaction && estimateTxDependencies) {
      txRequestClone.gasPrice = bn14(0);
      txRequestClone.gasLimit = bn14(maxGasPerTx.sub(maxGas).toNumber() * 0.9);
      const result = await this.estimateTxDependencies(txRequestClone);
      receipts = result.receipts;
      outputVariables = result.outputVariables;
      missingContractIds = result.missingContractIds;
    }
    const gasUsed = isScriptTransaction ? getGasUsedFromReceipts(receipts) : minGas;
    const usedFee = calculatePriceWithFactor(
      gasUsed,
      gasPrice,
      gasPriceFactor
    ).normalizeZeroToOne();
    const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
    const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor).normalizeZeroToOne();
    return {
      requiredQuantities: allQuantities,
      receipts,
      gasUsed,
      minGasPrice,
      gasPrice,
      minGas,
      maxGas,
      usedFee,
      minFee,
      maxFee,
      estimatedInputs: txRequestClone.inputs,
      outputVariables,
      missingContractIds
    };
  }
  async getResourcesForTransaction(owner, transactionRequestLike, forwardingQuantities = []) {
    const ownerAddress = Address2.fromAddressOrString(owner);
    const transactionRequest = transactionRequestify(clone3(transactionRequestLike));
    const transactionCost = await this.getTransactionCost(transactionRequest, forwardingQuantities);
    transactionRequest.addResources(
      await this.getResourcesToSpend(ownerAddress, transactionCost.requiredQuantities)
    );
    const { requiredQuantities, ...txCost } = await this.getTransactionCost(
      transactionRequest,
      forwardingQuantities
    );
    const resources = await this.getResourcesToSpend(ownerAddress, requiredQuantities);
    return {
      resources,
      requiredQuantities,
      ...txCost
    };
  }
  /**
   * Returns coins for the given owner.
   */
  async getCoins(owner, assetId, paginationArgs) {
    const ownerAddress = Address2.fromAddressOrString(owner);
    const result = await this.operations.getCoins({
      first: 10,
      ...paginationArgs,
      filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify12(assetId) }
    });
    const coins = result.coins.edges.map((edge) => edge.node);
    return coins.map((coin) => ({
      id: coin.utxoId,
      assetId: coin.assetId,
      amount: bn14(coin.amount),
      owner: Address2.fromAddressOrString(coin.owner),
      maturity: bn14(coin.maturity).toNumber(),
      blockCreated: bn14(coin.blockCreated),
      txCreatedIdx: bn14(coin.txCreatedIdx)
    }));
  }
  /**
   * Returns resources for the given owner satisfying the spend query.
   *
   * @param owner - The address to get resources for.
   * @param quantities - The quantities to get.
   * @param excludedIds - IDs of excluded resources from the selection.
   * @returns A promise that resolves to the resources.
   */
  async getResourcesToSpend(owner, quantities, excludedIds) {
    const ownerAddress = Address2.fromAddressOrString(owner);
    const excludeInput = {
      messages: excludedIds?.messages?.map((nonce) => hexlify12(nonce)) || [],
      utxos: excludedIds?.utxos?.map((id) => hexlify12(id)) || []
    };
    if (this.cache) {
      const uniqueUtxos = new Set(
        excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify12(id)))
      );
      excludeInput.utxos = Array.from(uniqueUtxos);
    }
    const coinsQuery = {
      owner: ownerAddress.toB256(),
      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
        assetId: hexlify12(assetId),
        amount: amount.toString(10),
        max: maxPerAsset ? maxPerAsset.toString(10) : void 0
      })),
      excludedIds: excludeInput
    };
    const result = await this.operations.getCoinsToSpend(coinsQuery);
    const coins = result.coinsToSpend.flat().map((coin) => {
      switch (coin.__typename) {
        case "MessageCoin":
          return {
            amount: bn14(coin.amount),
            assetId: coin.assetId,
            daHeight: bn14(coin.daHeight),
            sender: Address2.fromAddressOrString(coin.sender),
            recipient: Address2.fromAddressOrString(coin.recipient),
            nonce: coin.nonce
          };
        case "Coin":
          return {
            id: coin.utxoId,
            amount: bn14(coin.amount),
            assetId: coin.assetId,
            owner: Address2.fromAddressOrString(coin.owner),
            maturity: bn14(coin.maturity).toNumber(),
            blockCreated: bn14(coin.blockCreated),
            txCreatedIdx: bn14(coin.txCreatedIdx)
          };
        default:
          return null;
      }
    }).filter((v) => !!v);
    return coins;
  }
  /**
   * Returns block matching the given ID or height.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlock(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { height: bn14(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { height: (await this.getBlockNumber()).toString(10) };
    } else if (idOrHeight.length === 66) {
      variables = { blockId: idOrHeight };
    } else {
      variables = { blockId: bn14(idOrHeight).toString(10) };
    }
    const { block } = await this.operations.getBlock(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: bn14(block.header.height),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id)
    };
  }
  /**
   * Returns all the blocks matching the given parameters.
   *
   * @param params - The parameters to query blocks.
   * @returns A promise that resolves to the blocks.
   */
  async getBlocks(params) {
    const { blocks: fetchedData } = await this.operations.getBlocks(params);
    const blocks = fetchedData.edges.map(({ node: block }) => ({
      id: block.id,
      height: bn14(block.header.height),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id)
    }));
    return blocks;
  }
  /**
   * Returns block matching the given ID or type, including transaction data.
   *
   * @param idOrHeight - ID or height of the block.
   * @returns A promise that resolves to the block.
   */
  async getBlockWithTransactions(idOrHeight) {
    let variables;
    if (typeof idOrHeight === "number") {
      variables = { blockHeight: bn14(idOrHeight).toString(10) };
    } else if (idOrHeight === "latest") {
      variables = { blockHeight: (await this.getBlockNumber()).toString() };
    } else {
      variables = { blockId: idOrHeight };
    }
    const { block } = await this.operations.getBlockWithTransactions(variables);
    if (!block) {
      return null;
    }
    return {
      id: block.id,
      height: bn14(block.header.height, 10),
      time: block.header.time,
      transactionIds: block.transactions.map((tx) => tx.id),
      transactions: block.transactions.map(
        (tx) => new TransactionCoder5().decode(arrayify11(tx.rawPayload), 0)?.[0]
      )
    };
  }
  /**
   * Get transaction with the given ID.
   *
   * @param transactionId - ID of the transaction.
   * @returns A promise that resolves to the transaction.
   */
  async getTransaction(transactionId) {
    const { transaction } = await this.operations.getTransaction({ transactionId });
    if (!transaction) {
      return null;
    }
    return new TransactionCoder5().decode(
      arrayify11(transaction.rawPayload),
      0
    )?.[0];
  }
  /**
   * Get deployed contract with the given ID.
   *
   * @param contractId - ID of the contract.
   * @returns A promise that resolves to the contract.
   */
  async getContract(contractId) {
    const { contract } = await this.operations.getContract({ contractId });
    if (!contract) {
      return null;
    }
    return contract;
  }
  /**
   * Returns the balance for the given contract for the given asset ID.
   *
   * @param contractId - The contract ID to get the balance for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getContractBalance(contractId, assetId) {
    const { contractBalance } = await this.operations.getContractBalance({
      contract: Address2.fromAddressOrString(contractId).toB256(),
      asset: hexlify12(assetId)
    });
    return bn14(contractBalance.amount, 10);
  }
  /**
   * Returns the balance for the given owner for the given asset ID.
   *
   * @param owner - The address to get coins for.
   * @param assetId - The asset ID of coins to get.
   * @returns A promise that resolves to the balance.
   */
  async getBalance(owner, assetId) {
    const { balance } = await this.operations.getBalance({
      owner: Address2.fromAddressOrString(owner).toB256(),
      assetId: hexlify12(assetId)
    });
    return bn14(balance.amount, 10);
  }
  /**
   * Returns balances for the given owner.
   *
   * @param owner - The address to get coins for.
   * @param paginationArgs - Pagination arguments.
   * @returns A promise that resolves to the balances.
   */
  async getBalances(owner, paginationArgs) {
    const result = await this.operations.getBalances({
      first: 10,
      ...paginationArgs,
      filter: { owner: Address2.fromAddressOrString(owner).toB256() }
    });
    const balances = result.balances.edges.map((edge) => edge.node);
    return balances.map((balance) => ({
      assetId: balance.assetId,
      amount: bn14(balance.amount)
    }));
  }
  /**
   * Returns message for the given address.
   *
   * @param address - The address to get message from.
   * @param paginationArgs - Pagination arguments.
   * @returns A promise that resolves to the messages.
   */
  async getMessages(address, paginationArgs) {
    const result = await this.operations.getMessages({
      first: 10,
      ...paginationArgs,
      owner: Address2.fromAddressOrString(address).toB256()
    });
    const messages = result.messages.edges.map((edge) => edge.node);
    return messages.map((message) => ({
      messageId: InputMessageCoder.getMessageId({
        sender: message.sender,
        recipient: message.recipient,
        nonce: message.nonce,
        amount: bn14(message.amount),
        data: message.data
      }),
      sender: Address2.fromAddressOrString(message.sender),
      recipient: Address2.fromAddressOrString(message.recipient),
      nonce: message.nonce,
      amount: bn14(message.amount),
      data: InputMessageCoder.decodeData(message.data),
      daHeight: bn14(message.daHeight)
    }));
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param transactionId - The transaction to get message from.
   * @param messageId - The message id from MessageOut receipt.
   * @param commitBlockId - The commit block id.
   * @param commitBlockHeight - The commit block height.
   * @returns A promise that resolves to the message proof.
   */
  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {
    let inputObject = {
      transactionId,
      nonce
    };
    if (commitBlockId && commitBlockHeight) {
      throw new FuelError12(
        ErrorCode11.INVALID_INPUT_PARAMETERS,
        "commitBlockId and commitBlockHeight cannot be used together"
      );
    }
    if (commitBlockId) {
      inputObject = {
        ...inputObject,
        commitBlockId
      };
    }
    if (commitBlockHeight) {
      inputObject = {
        ...inputObject,
        // Conver BN into a number string required on the query
        // This should problably be fixed on the fuel client side
        commitBlockHeight: commitBlockHeight.toNumber().toString()
      };
    }
    const result = await this.operations.getMessageProof(inputObject);
    if (!result.messageProof) {
      return null;
    }
    const {
      messageProof,
      messageBlockHeader,
      commitBlockHeader,
      blockProof,
      sender,
      recipient,
      amount,
      data
    } = result.messageProof;
    return {
      messageProof: {
        proofIndex: bn14(messageProof.proofIndex),
        proofSet: messageProof.proofSet
      },
      blockProof: {
        proofIndex: bn14(blockProof.proofIndex),
        proofSet: blockProof.proofSet
      },
      messageBlockHeader: {
        id: messageBlockHeader.id,
        daHeight: bn14(messageBlockHeader.daHeight),
        transactionsCount: bn14(messageBlockHeader.transactionsCount),
        transactionsRoot: messageBlockHeader.transactionsRoot,
        height: bn14(messageBlockHeader.height),
        prevRoot: messageBlockHeader.prevRoot,
        time: messageBlockHeader.time,
        applicationHash: messageBlockHeader.applicationHash,
        messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
        messageReceiptCount: bn14(messageBlockHeader.messageReceiptCount)
      },
      commitBlockHeader: {
        id: commitBlockHeader.id,
        daHeight: bn14(commitBlockHeader.daHeight),
        transactionsCount: bn14(commitBlockHeader.transactionsCount),
        transactionsRoot: commitBlockHeader.transactionsRoot,
        height: bn14(commitBlockHeader.height),
        prevRoot: commitBlockHeader.prevRoot,
        time: commitBlockHeader.time,
        applicationHash: commitBlockHeader.applicationHash,
        messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
        messageReceiptCount: bn14(commitBlockHeader.messageReceiptCount)
      },
      sender: Address2.fromAddressOrString(sender),
      recipient: Address2.fromAddressOrString(recipient),
      nonce,
      amount: bn14(amount),
      data
    };
  }
  /**
   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
   *
   * @param nonce - The nonce of the message to get status from.
   * @returns A promise that resolves to the message status
   */
  async getMessageStatus(nonce) {
    const result = await this.operations.getMessageStatus({ nonce });
    return result.messageStatus;
  }
  /**
   * Lets you produce blocks with custom timestamps and the block number of the last block produced.
   *
   * @param amount - The amount of blocks to produce
   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block
   * @returns A promise that resolves to the block number of the last produced block.
   */
  async produceBlocks(amount, startTime) {
    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
      blocksToProduce: bn14(amount).toString(10),
      startTimestamp: startTime ? DateTime2.fromUnixMilliseconds(startTime).toTai64() : void 0
    });
    return bn14(latestBlockHeight);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async getTransactionResponse(transactionId) {
    return new TransactionResponse(transactionId, this);
  }
};
var Provider = _Provider;
_cacheInputs = new WeakSet();
cacheInputs_fn = function(inputs) {
  if (!this.cache) {
    return;
  }
  inputs.forEach((input) => {
    if (input.type === InputType6.Coin) {
      this.cache?.set(input.id);
    }
  });
};
__publicField(Provider, "chainInfoCache", {});
__publicField(Provider, "nodeInfoCache", {});

// src/providers/transaction-summary/get-transaction-summary.ts
import { ErrorCode as ErrorCode12, FuelError as FuelError13 } from "@fuel-ts/errors";
import { bn as bn15 } from "@fuel-ts/math";
import { TransactionCoder as TransactionCoder6 } from "@fuel-ts/transactions";
import { arrayify as arrayify12 } from "@fuel-ts/utils";

// src/providers/chains.ts
var CHAIN_IDS = {
  eth: {
    sepolia: 11155111,
    foundry: 31337
  },
  fuel: {
    beta5: 0,
    devnet: 10
  }
};

// src/providers/assets/index.ts
var assets = [
  {
    name: "Ethereum",
    symbol: "ETH",
    icon: "eth.svg",
    networks: [
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.sepolia,
        decimals: 18
      },
      {
        type: "ethereum",
        chainId: CHAIN_IDS.eth.foundry,
        decimals: 18
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.beta5,
        decimals: 9,
        assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
      },
      {
        type: "fuel",
        chainId: CHAIN_IDS.fuel.devnet,
        decimals: 9,
        assetId: "0x0000000000000000000000000000000000000000000000000000000000000000"
      }
    ]
  }
];

// src/utils/formatTransferToContractScriptData.ts
import { BigNumberCoder as BigNumberCoder2 } from "@fuel-ts/abi-coder";
import { BN as BN2 } from "@fuel-ts/math";
import { arrayify as arrayify13 } from "@fuel-ts/utils";
import * as asm from "@fuels/vm-asm";
var formatTransferToContractScriptData = (params) => {
  const { assetId, amountToTransfer, hexlifiedContractId } = params;
  const numberCoder = new BigNumberCoder2("u64");
  const encoded = numberCoder.encode(new BN2(amountToTransfer).toNumber());
  const scriptData = Uint8Array.from([
    ...arrayify13(hexlifiedContractId),
    ...encoded,
    ...arrayify13(assetId)
  ]);
  return scriptData;
};
var assembleTransferToContractScript = async (params) => {
  const scriptData = formatTransferToContractScriptData(params);
  await asm.initWasm();
  const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
  const addi2 = asm.addi(17, 16, 32);
  const lw2 = asm.lw(18, 17, 0);
  const addi22 = asm.addi(19, 17, 8);
  const tr2 = asm.tr(16, 18, 19);
  const ret2 = asm.ret(1);
  const script = Uint8Array.from([
    ...gtf2.to_bytes(),
    ...addi2.to_bytes(),
    ...lw2.to_bytes(),
    ...addi22.to_bytes(),
    ...tr2.to_bytes(),
    ...ret2.to_bytes()
  ]);
  return { script, scriptData };
};

// src/account.ts
var Account = class extends AbstractAccount {
  /**
   * The address associated with the account.
   */
  address;
  /**
   * The provider used to interact with the network.
   */
  _provider;
  _connector;
  /**
   * Creates a new Account instance.
   *
   * @param address - The address of the account.
   * @param provider - A Provider instance  (optional).
   */
  constructor(address, provider, connector) {
    super();
    this._provider = provider;
    this._connector = connector;
    this.address = Address3.fromDynamicInput(address);
  }
  /**
   * The provider used to interact with the network.
   *
   * @returns A Provider instance.
   *
   * @throws `FuelError` if the provider is not set.
   */
  get provider() {
    if (!this._provider) {
      throw new FuelError14(ErrorCode13.MISSING_PROVIDER, "Provider not set");
    }
    return this._provider;
  }
  /**
   * Sets the provider for the account.
   *
   * @param provider - A Provider instance.
   */
  set provider(provider) {
    this._provider = provider;
  }
  /**
   * Changes the provider connection for the account.
   *
   * @param provider - A Provider instance.
   * @returns The updated Provider instance.
   */
  connect(provider) {
    this._provider = provider;
    return this.provider;
  }
  /**
   * Retrieves resources satisfying the spend query for the account.
   *
   * @param quantities - IDs of coins to exclude.
   * @param excludedIds - IDs of resources to be excluded from the query.
   * @returns A promise that resolves to an array of Resources.
   */
  async getResourcesToSpend(quantities, excludedIds) {
    return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
  }
  /**
   * Retrieves coins owned by the account.
   *
   * @param assetId - The asset ID of the coins to retrieve.
   * @returns A promise that resolves to an array of Coins.
   */
  async getCoins(assetId) {
    const coins = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageCoins = await this.provider.getCoins(this.address, assetId, {
        first: pageSize,
        after: cursor
      });
      coins.push(...pageCoins);
      const hasNextPage = pageCoins.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError14(
        ErrorCode13.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
      );
    }
    return coins;
  }
  /**
   * Retrieves messages owned by the account.
   *
   * @returns A promise that resolves to an array of Messages.
   */
  async getMessages() {
    const messages = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageMessages = await this.provider.getMessages(this.address, {
        first: pageSize,
        after: cursor
      });
      messages.push(...pageMessages);
      const hasNextPage = pageMessages.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError14(
        ErrorCode13.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
      );
    }
    return messages;
  }
  /**
   * Retrieves the balance of the account for the given asset.
   *
   * @param assetId - The asset ID to check the balance for.
   * @returns A promise that resolves to the balance amount.
   */
  async getBalance(assetId = BaseAssetId3) {
    const amount = await this.provider.getBalance(this.address, assetId);
    return amount;
  }
  /**
   * Retrieves all the balances for the account.
   *
   * @returns A promise that resolves to an array of Coins and their quantities.
   */
  async getBalances() {
    const balances = [];
    const pageSize = 9999;
    let cursor;
    for (; ; ) {
      const pageBalances = await this.provider.getBalances(this.address, {
        first: pageSize,
        after: cursor
      });
      balances.push(...pageBalances);
      const hasNextPage = pageBalances.length >= pageSize;
      if (!hasNextPage) {
        break;
      }
      throw new FuelError14(
        ErrorCode13.NOT_SUPPORTED,
        `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
      );
    }
    return balances;
  }
  /**
   * Adds resources to the transaction enough to fund it.
   *
   * @param request - The transaction request.
   * @param coinQuantities - The coin quantities required to execute the transaction.
   * @param fee - The estimated transaction fee.
   * @returns A promise that resolves when the resources are added to the transaction.
   */
  async fund(request, coinQuantities, fee) {
    const updatedQuantities = addAmountToAsset({
      amount: bn16(fee),
      assetId: BaseAssetId3,
      coinQuantities
    });
    const quantitiesDict = {};
    updatedQuantities.forEach(({ amount, assetId }) => {
      quantitiesDict[assetId] = {
        required: amount,
        owned: bn16(0)
      };
    });
    const cachedUtxos = [];
    const cachedMessages = [];
    const owner = this.address.toB256();
    request.inputs.forEach((input) => {
      const isResource = "amount" in input;
      if (isResource) {
        const isCoin2 = "owner" in input;
        if (isCoin2) {
          const assetId = String(input.assetId);
          if (input.owner === owner && quantitiesDict[assetId]) {
            const amount = bn16(input.amount);
            quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(amount);
            cachedUtxos.push(input.id);
          }
        } else if (input.recipient === owner && input.amount && quantitiesDict[BaseAssetId3]) {
          quantitiesDict[BaseAssetId3].owned = quantitiesDict[BaseAssetId3].owned.add(input.amount);
          cachedMessages.push(input.nonce);
        }
      }
    });
    const missingQuantities = [];
    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {
      if (owned.lt(required)) {
        missingQuantities.push({
          assetId,
          amount: required.sub(owned)
        });
      }
    });
    const needsToBeFunded = missingQuantities.length;
    if (needsToBeFunded) {
      const resources = await this.getResourcesToSpend(missingQuantities, {
        messages: cachedMessages,
        utxos: cachedUtxos
      });
      request.addResources(resources);
    }
  }
  /**
   * A helper that creates a transfer transaction request and returns it.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the prepared transaction request.
   */
  async createTransfer(destination, amount, assetId = BaseAssetId3, txParams = {}) {
    const { minGasPrice } = this.provider.getGasConfig();
    const params = { gasPrice: minGasPrice, ...txParams };
    const request = new ScriptTransactionRequest(params);
    request.addCoinOutput(Address3.fromAddressOrString(destination), amount, assetId);
    const { maxFee, requiredQuantities, gasUsed, estimatedInputs } = await this.provider.getTransactionCost(request, [], {
      estimateTxDependencies: true,
      resourcesOwner: this
    });
    request.gasPrice = bn16(txParams.gasPrice ?? minGasPrice);
    request.gasLimit = bn16(txParams.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    request.updatePredicateInputs(estimatedInputs);
    return request;
  }
  /**
   * Transfers coins to a destination address.
   *
   * @param destination - The address of the destination.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
   * @returns A promise that resolves to the transaction response.
   */
  async transfer(destination, amount, assetId = BaseAssetId3, txParams = {}) {
    const request = await this.createTransfer(destination, amount, assetId, txParams);
    return this.sendTransaction(request, { estimateTxDependencies: false });
  }
  /**
   * Transfers coins to a contract address.
   *
   * @param contractId - The address of the contract.
   * @param amount - The amount of coins to transfer.
   * @param assetId - The asset ID of the coins to transfer.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async transferToContract(contractId, amount, assetId = BaseAssetId3, txParams = {}) {
    const contractAddress = Address3.fromAddressOrString(contractId);
    const { minGasPrice } = this.provider.getGasConfig();
    const params = { gasPrice: minGasPrice, ...txParams };
    const { script, scriptData } = await assembleTransferToContractScript({
      hexlifiedContractId: contractAddress.toB256(),
      amountToTransfer: bn16(amount),
      assetId
    });
    const request = new ScriptTransactionRequest({
      ...params,
      script,
      scriptData
    });
    request.addContractInputAndOutput(contractAddress);
    const { maxFee, requiredQuantities, gasUsed } = await this.provider.getTransactionCost(
      request,
      [{ amount: bn16(amount), assetId: String(assetId) }]
    );
    request.gasLimit = bn16(params.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  /**
   * Withdraws an amount of the base asset to the base chain.
   *
   * @param recipient - Address of the recipient on the base chain.
   * @param amount - Amount of base asset.
   * @param txParams - The optional transaction parameters.
   * @returns A promise that resolves to the transaction response.
   */
  async withdrawToBaseLayer(recipient, amount, txParams = {}) {
    const { minGasPrice } = this.provider.getGasConfig();
    const recipientAddress = Address3.fromAddressOrString(recipient);
    const recipientDataArray = arrayify14(
      "0x".concat(recipientAddress.toHexString().substring(2).padStart(64, "0"))
    );
    const amountDataArray = arrayify14(
      "0x".concat(bn16(amount).toHex().substring(2).padStart(16, "0"))
    );
    const script = new Uint8Array([
      ...arrayify14(withdrawScript.bytes),
      ...recipientDataArray,
      ...amountDataArray
    ]);
    const params = { script, gasPrice: minGasPrice, ...txParams };
    const request = new ScriptTransactionRequest(params);
    const forwardingQuantities = [{ amount: bn16(amount), assetId: BaseAssetId3 }];
    const { requiredQuantities, maxFee, gasUsed } = await this.provider.getTransactionCost(
      request,
      forwardingQuantities
    );
    request.gasLimit = bn16(params.gasLimit ?? gasUsed);
    this.validateGas({
      gasUsed,
      gasPrice: request.gasPrice,
      gasLimit: request.gasLimit,
      minGasPrice
    });
    await this.fund(request, requiredQuantities, maxFee);
    return this.sendTransaction(request);
  }
  async signMessage(message) {
    if (!this._connector) {
      throw new FuelError14(ErrorCode13.MISSING_CONNECTOR, "A connector is required to sign messages.");
    }
    return this._connector.signMessage(this.address.toString(), message);
  }
  /**
   * Sends a transaction to the network.
   *
   * @param transactionRequestLike - The transaction request to be sent.
   * @returns A promise that resolves to the transaction response.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
    if (this._connector) {
      return this.provider.getTransactionResponse(
        await this._connector.sendTransaction(this.address.toString(), transactionRequestLike)
      );
    }
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(transactionRequest, {
      awaitExecution,
      estimateTxDependencies: false
    });
  }
  /**
   * Simulates a transaction.
   *
   * @param transactionRequestLike - The transaction request to be simulated.
   * @returns A promise that resolves to the call result.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });
  }
  validateGas({
    gasUsed,
    gasPrice,
    gasLimit,
    minGasPrice
  }) {
    if (minGasPrice.gt(gasPrice)) {
      throw new FuelError14(
        ErrorCode13.GAS_PRICE_TOO_LOW,
        `Gas price '${gasPrice}' is lower than the required: '${minGasPrice}'.`
      );
    }
    if (gasUsed.gt(gasLimit)) {
      throw new FuelError14(
        ErrorCode13.GAS_LIMIT_TOO_LOW,
        `Gas limit '${gasLimit}' is lower than the required: '${gasUsed}'.`
      );
    }
  }
};

// src/signer/signer.ts
import { Address as Address4 } from "@fuel-ts/address";
import { randomBytes } from "@fuel-ts/crypto";
import { hash } from "@fuel-ts/hasher";
import { toBytes } from "@fuel-ts/math";
import { hexlify as hexlify13, concat as concat3, arrayify as arrayify15 } from "@fuel-ts/utils";
import { secp256k1 } from "@noble/curves/secp256k1";
var Signer = class {
  address;
  publicKey;
  compressedPublicKey;
  privateKey;
  /**
   * Create a Signer instance from a given private key
   *
   * @param privateKey - The private key to use for signing
   * @returns A new Signer instance
   */
  constructor(privateKey) {
    if (typeof privateKey === "string") {
      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
        privateKey = `0x${privateKey}`;
      }
    }
    const privateKeyBytes = toBytes(privateKey, 32);
    this.privateKey = hexlify13(privateKeyBytes);
    this.publicKey = hexlify13(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));
    this.compressedPublicKey = hexlify13(secp256k1.getPublicKey(privateKeyBytes, true));
    this.address = Address4.fromPublicKey(this.publicKey);
  }
  /**
   * Sign data using the Signer instance
   *
   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.
   * @ignore
   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
   *
   * @param data - The data to be sign
   * @returns hashed signature
   */
  sign(data) {
    const signature = secp256k1.sign(arrayify15(data), arrayify15(this.privateKey));
    const r = toBytes(`0x${signature.r.toString(16)}`, 32);
    const s = toBytes(`0x${signature.s.toString(16)}`, 32);
    s[0] |= (signature.recovery || 0) << 7;
    return hexlify13(concat3([r, s]));
  }
  /**
   * Add point on the current elliptic curve
   *
   * @param point - Point to add on the curve
   * @returns compressed point on the curve
   */
  addPoint(point) {
    const p0 = secp256k1.ProjectivePoint.fromHex(arrayify15(this.compressedPublicKey));
    const p1 = secp256k1.ProjectivePoint.fromHex(arrayify15(point));
    const result = p0.add(p1);
    return `0x${result.toHex(true)}`;
  }
  /**
   * Recover the public key from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - hashed signature
   * @returns public key from signature from the
   */
  static recoverPublicKey(data, signature) {
    const signedMessageBytes = arrayify15(signature);
    const r = signedMessageBytes.slice(0, 32);
    const s = signedMessageBytes.slice(32, 64);
    const recoveryParam = (s[0] & 128) >> 7;
    s[0] &= 127;
    const sig = new secp256k1.Signature(BigInt(hexlify13(r)), BigInt(hexlify13(s))).addRecoveryBit(
      recoveryParam
    );
    const publicKey = sig.recoverPublicKey(arrayify15(data)).toRawBytes(false).slice(1);
    return hexlify13(publicKey);
  }
  /**
   * Recover the address from a signature performed with [`sign`](#sign).
   *
   * @param data - Data
   * @param signature - Signature
   * @returns Address from signature
   */
  static recoverAddress(data, signature) {
    return Address4.fromPublicKey(Signer.recoverPublicKey(data, signature));
  }
  /**
   * Generate a random privateKey
   *
   * @param entropy - Adds extra entropy to generate the privateKey
   * @returns random 32-byte hashed
   */
  static generatePrivateKey(entropy) {
    return entropy ? hash(concat3([randomBytes(32), arrayify15(entropy)])) : randomBytes(32);
  }
  /**
   * Extended publicKey from a compact publicKey
   *
   * @param publicKey - Compact publicKey
   * @returns extended publicKey
   */
  static extendPublicKey(publicKey) {
    const point = secp256k1.ProjectivePoint.fromHex(arrayify15(publicKey));
    return hexlify13(point.toRawBytes(false).slice(1));
  }
};

// src/wallet/keystore-wallet.ts
import { Address as Address5 } from "@fuel-ts/address";
import {
  bufferFromString,
  keccak256,
  randomBytes as randomBytes2,
  scrypt,
  stringFromBuffer,
  decryptJsonWalletData,
  encryptJsonWalletData
} from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode14, FuelError as FuelError15 } from "@fuel-ts/errors";
import { hexlify as hexlify14 } from "@fuel-ts/utils";
import { v4 as uuidv4 } from "uuid";
var DEFAULT_KDF_PARAMS_LOG_N = 13;
var DEFAULT_KDF_PARAMS_R = 8;
var DEFAULT_KDF_PARAMS_P = 1;
var DEFAULT_KEY_SIZE = 32;
var DEFAULT_IV_SIZE = 16;
var removeHexPrefix = (hexString) => {
  if (/^0x/.test(hexString)) {
    return hexString.slice(2);
  }
  return hexString;
};
async function encryptKeystoreWallet(privateKey, address, password) {
  const privateKeyBuffer = bufferFromString(removeHexPrefix(privateKey), "hex");
  const ownerAddress = Address5.fromAddressOrString(address);
  const salt = randomBytes2(DEFAULT_KEY_SIZE);
  const key = scrypt({
    password: bufferFromString(password),
    salt,
    dklen: DEFAULT_KEY_SIZE,
    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
    r: DEFAULT_KDF_PARAMS_R,
    p: DEFAULT_KDF_PARAMS_P
  });
  const iv = randomBytes2(DEFAULT_IV_SIZE);
  const ciphertext = await encryptJsonWalletData(privateKeyBuffer, key, iv);
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
  const macHashUint8Array = keccak256(data);
  const mac = stringFromBuffer(macHashUint8Array, "hex");
  const keystore = {
    id: uuidv4(),
    version: 3,
    address: removeHexPrefix(ownerAddress.toHexString()),
    crypto: {
      cipher: "aes-128-ctr",
      mac,
      cipherparams: { iv: stringFromBuffer(iv, "hex") },
      ciphertext: stringFromBuffer(ciphertext, "hex"),
      kdf: "scrypt",
      kdfparams: {
        dklen: DEFAULT_KEY_SIZE,
        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
        p: DEFAULT_KDF_PARAMS_P,
        r: DEFAULT_KDF_PARAMS_R,
        salt: stringFromBuffer(salt, "hex")
      }
    }
  };
  return JSON.stringify(keystore);
}
async function decryptKeystoreWallet(jsonWallet, password) {
  const keystoreWallet = JSON.parse(jsonWallet);
  const {
    crypto: {
      mac,
      ciphertext,
      cipherparams: { iv },
      kdfparams: { dklen, n, r, p, salt }
    }
  } = keystoreWallet;
  const ciphertextBuffer = bufferFromString(ciphertext, "hex");
  const ivBuffer = bufferFromString(iv, "hex");
  const saltBuffer = bufferFromString(salt, "hex");
  const passwordBuffer = bufferFromString(password);
  const key = scrypt({
    password: passwordBuffer,
    salt: saltBuffer,
    n,
    p,
    r,
    dklen
  });
  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
  const macHashUint8Array = keccak256(data);
  const macHash = stringFromBuffer(macHashUint8Array, "hex");
  if (mac !== macHash) {
    throw new FuelError15(
      ErrorCode14.INVALID_PASSWORD,
      "Failed to decrypt the keystore wallet, the provided password is incorrect."
    );
  }
  const buffer = await decryptJsonWalletData(ciphertextBuffer, key, ivBuffer);
  const privateKey = hexlify14(buffer);
  return privateKey;
}

// src/wallet/base-wallet-unlocked.ts
var BaseWalletUnlocked = class extends Account {
  /**
   * A function that returns the wallet's signer.
   */
  signer;
  /**
   * Creates a new BaseWalletUnlocked instance.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   */
  constructor(privateKey, provider) {
    const signer = new Signer(privateKey);
    super(signer.address, provider);
    this.signer = () => signer;
  }
  /**
   * Gets the private key of the wallet.
   *
   * @returns The private key of the wallet.
   */
  get privateKey() {
    return this.signer().privateKey;
  }
  /**
   * Gets the public key of the wallet.
   *
   * @returns
   */
  get publicKey() {
    return this.signer().publicKey;
  }
  /**
   * Signs a message with the wallet's private key.
   *
   * @param message - The message to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signMessage(message) {
    const signedMessage = await this.signer().sign(hashMessage(message));
    return hexlify15(signedMessage);
  }
  /**
   * Signs a transaction with the wallet's private key.
   *
   * @param transactionRequestLike - The transaction request to sign.
   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
   */
  async signTransaction(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const chainId = this.provider.getChain().consensusParameters.chainId.toNumber();
    const hashedTransaction = transactionRequest.getTransactionId(chainId);
    const signature = await this.signer().sign(hashedTransaction);
    return hexlify15(signature);
  }
  /**
   * Populates a transaction with the witnesses signature.
   *
   * @param transactionRequestLike - The transaction request to populate.
   * @returns The populated transaction request.
   */
  async populateTransactionWitnessesSignature(transactionRequestLike) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const signedTransaction = await this.signTransaction(transactionRequest);
    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
    return transactionRequest;
  }
  /**
   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
   *
   * @param transactionRequestLike - The transaction request to send.
   * @returns A promise that resolves to the TransactionResponse object.
   */
  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, awaitExecution } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.sendTransaction(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      { awaitExecution, estimateTxDependencies: false }
    );
  }
  /**
   * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
   *
   * @param transactionRequestLike - The transaction request to simulate.
   * @returns A promise that resolves to the CallResult object.
   */
  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    if (estimateTxDependencies) {
      await this.provider.estimateTxDependencies(transactionRequest);
    }
    return this.provider.call(
      await this.populateTransactionWitnessesSignature(transactionRequest),
      {
        utxoValidation: true,
        estimateTxDependencies: false
      }
    );
  }
  async encrypt(password) {
    return encryptKeystoreWallet(this.privateKey, this.address, password);
  }
};
/**
 * Default HDWallet path.
 */
__publicField(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");

// src/hdwallet/hdwallet.ts
import { ErrorCode as ErrorCode17, FuelError as FuelError18 } from "@fuel-ts/errors";
import { bn as bn17, toBytes as toBytes2, toHex } from "@fuel-ts/math";
import { arrayify as arrayify18, hexlify as hexlify17, concat as concat5 } from "@fuel-ts/utils";
import {
  toBeHex,
  dataSlice as dataSlice2,
  encodeBase58 as encodeBase582,
  decodeBase58,
  sha256 as sha2564,
  computeHmac as computeHmac2,
  ripemd160
} from "ethers";

// src/mnemonic/mnemonic.ts
import { randomBytes as randomBytes3 } from "@fuel-ts/crypto";
import { ErrorCode as ErrorCode16, FuelError as FuelError17 } from "@fuel-ts/errors";
import { arrayify as arrayify17, hexlify as hexlify16, concat as concat4 } from "@fuel-ts/utils";
import { dataSlice, pbkdf2, sha256 as sha2563, computeHmac, encodeBase58 } from "ethers";

// src/wordlists/words/english.ts
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// src/mnemonic/utils.ts
import { ErrorCode as ErrorCode15, FuelError as FuelError16 } from "@fuel-ts/errors";
import { arrayify as arrayify16 } from "@fuel-ts/utils";
import { sha256 as sha2562 } from "ethers";
function toUtf8Bytes(stri) {
  const str = stri.normalize("NFKD");
  const result = [];
  for (let i = 0; i < str.length; i += 1) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) === 55296) {
      i += 1;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new FuelError16(
          ErrorCode15.INVALID_INPUT_PARAMETERS,
          "Invalid UTF-8 in the input string."
        );
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return Uint8Array.from(result);
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getWords(mnemonic) {
  if (!Array.isArray(mnemonic)) {
    return mnemonic.split(/\s+/);
  }
  return mnemonic;
}
function getPhrase(mnemonic) {
  if (Array.isArray(mnemonic)) {
    return mnemonic.join(" ");
  }
  return mnemonic;
}
function entropyToMnemonicIndices(entropy) {
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i += 1) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify16(sha2562(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return indices;
}
function mnemonicWordsToEntropy(words, wordlist) {
  const size = Math.ceil(11 * words.length / 8);
  const entropy = arrayify16(new Uint8Array(size));
  let offset = 0;
  for (let i = 0; i < words.length; i += 1) {
    const index = wordlist.indexOf(words[i].normalize("NFKD"));
    if (index === -1) {
      throw new FuelError16(
        ErrorCode15.INVALID_MNEMONIC,
        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
      );
    }
    for (let bit = 0; bit < 11; bit += 1) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset += 1;
    }
  }
  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify16(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new FuelError16(
      ErrorCode15.INVALID_CHECKSUM,
      "Checksum validation failed for the provided mnemonic."
    );
  }
  return entropy.slice(0, entropyBits / 8);
}

// src/mnemonic/mnemonic.ts
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var MainnetPRV = "0x0488ade4";
var TestnetPRV = "0x04358394";
var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
function assertWordList(wordlist) {
  if (wordlist.length !== 2048) {
    throw new FuelError17(
      ErrorCode16.INVALID_WORD_LIST,
      `Expected word list length of 2048, but got ${wordlist.length}.`
    );
  }
}
function assertEntropy(entropy) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new FuelError17(
      ErrorCode16.INVALID_ENTROPY,
      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
    );
  }
}
function assertMnemonic(words) {
  if (!MNEMONIC_SIZES.includes(words.length)) {
    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
      ", "
    )}] words, but got ${words.length}.`;
    throw new FuelError17(ErrorCode16.INVALID_MNEMONIC, errorMsg);
  }
}
var Mnemonic = class {
  wordlist;
  /**
   *
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic instance
   */
  constructor(wordlist = english) {
    this.wordlist = wordlist;
    assertWordList(this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns Entropy hash
   */
  mnemonicToEntropy(phrase) {
    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
  }
  /**
   *
   * @param entropy - Entropy source to the mnemonic phrase.
   * @returns Mnemonic phrase
   */
  entropyToMnemonic(entropy) {
    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
  }
  /**
   *
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
   * @returns Mnemonic phrase
   */
  static mnemonicToEntropy(phrase, wordlist = english) {
    const words = getWords(phrase);
    assertMnemonic(words);
    return hexlify16(mnemonicWordsToEntropy(words, wordlist));
  }
  /**
   * @param entropy - Entropy source to the mnemonic phrase.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static entropyToMnemonic(entropy, wordlist = english) {
    const entropyBytes = arrayify17(entropy);
    assertWordList(wordlist);
    assertEntropy(entropyBytes);
    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToSeed(phrase, passphrase = "") {
    assertMnemonic(getWords(phrase));
    const phraseBytes = toUtf8Bytes(getPhrase(phrase));
    const salt = toUtf8Bytes(`mnemonic${passphrase}`);
    return pbkdf2(phraseBytes, salt, 2048, 64, "sha512");
  }
  /**
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static mnemonicToMasterKeys(phrase, passphrase = "") {
    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
    return Mnemonic.masterKeysFromSeed(seed);
  }
  /**
   * Validates if given mnemonic is  valid
   * @param phrase - Mnemonic phrase composed by words from the provided wordlist
   * @returns true if phrase is a valid mnemonic
   */
  static isMnemonicValid(phrase) {
    const words = getWords(phrase);
    let i = 0;
    try {
      assertMnemonic(words);
    } catch {
      return false;
    }
    while (i < words.length) {
      if (Mnemonic.binarySearch(words[i]) === false) {
        return false;
      }
      i += 1;
    }
    return true;
  }
  static binarySearch(target) {
    const words = english;
    let left = 0;
    let right = words.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (words[mid] === target) {
        return true;
      }
      if (target < words[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return false;
  }
  /**
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
   * @returns 64-byte array contains privateKey and chainCode as described on BIP39
   */
  static masterKeysFromSeed(seed) {
    const seedArray = arrayify17(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new FuelError17(
        ErrorCode16.INVALID_SEED,
        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
      );
    }
    return arrayify17(computeHmac("sha512", MasterSecret, seedArray));
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param seed - BIP39 seed
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  static seedToExtendedKey(seed, testnet = false) {
    const masterKey = Mnemonic.masterKeysFromSeed(seed);
    const prefix = arrayify17(testnet ? TestnetPRV : MainnetPRV);
    const depth = "0x00";
    const fingerprint = "0x00000000";
    const index = "0x00000000";
    const chainCode = masterKey.slice(32);
    const privateKey = masterKey.slice(0, 32);
    const extendedKey = concat4([
      prefix,
      depth,
      fingerprint,
      index,
      chainCode,
      concat4(["0x00", privateKey])
    ]);
    const checksum = dataSlice(sha2563(sha2563(extendedKey)), 0, 4);
    return encodeBase58(concat4([extendedKey, checksum]));
  }
  /**
   *  Create a new mnemonic using a randomly generated number as entropy.
   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
   *  If not provided, the default entropy length will be set to 256 bits.
   *  The return is a list of words that encodes the generated entropy.
   *
   *
   * @param size - Number of bytes used as an entropy
   * @param extraEntropy - Optional extra entropy to increase randomness
   * @returns A randomly generated mnemonic
   */
  static generate(size = 32, extraEntropy = "") {
    const entropy = extraEntropy ? sha2563(concat4([randomBytes3(size), arrayify17(extraEntropy)])) : randomBytes3(size);
    return Mnemonic.entropyToMnemonic(entropy);
  }
};
var mnemonic_default = Mnemonic;

// src/hdwallet/hdwallet.ts
var HARDENED_INDEX = 2147483648;
var MainnetPRV2 = hexlify17("0x0488ade4");
var MainnetPUB = hexlify17("0x0488b21e");
var TestnetPRV2 = hexlify17("0x04358394");
var TestnetPUB = hexlify17("0x043587cf");
function base58check(data) {
  return encodeBase582(concat5([data, dataSlice2(sha2564(sha2564(data)), 0, 4)]));
}
function getExtendedKeyPrefix(isPublic = false, testnet = false) {
  if (isPublic) {
    return testnet ? TestnetPUB : MainnetPUB;
  }
  return testnet ? TestnetPRV2 : MainnetPRV2;
}
function isPublicExtendedKey(extendedKey) {
  return [MainnetPUB, TestnetPUB].includes(hexlify17(extendedKey.slice(0, 4)));
}
function isValidExtendedKey(extendedKey) {
  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
    hexlify17(extendedKey.slice(0, 4))
  );
}
function parsePath(path2, depth = 0) {
  const components = path2.split("/");
  if (components.length === 0 || components[0] === "m" && depth !== 0) {
    throw new FuelError18(ErrorCode17.HD_WALLET_ERROR, `invalid path - ${path2}`);
  }
  if (components[0] === "m") {
    components.shift();
  }
  return components.map(
    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
  );
}
var HDWallet = class {
  depth = 0;
  index = 0;
  fingerprint = hexlify17("0x00000000");
  parentFingerprint = hexlify17("0x00000000");
  privateKey;
  publicKey;
  chainCode;
  /**
   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
   *
   * @param config - Wallet configurations
   */
  constructor(config) {
    if (config.privateKey) {
      const signer = new Signer(config.privateKey);
      this.publicKey = hexlify17(signer.compressedPublicKey);
      this.privateKey = hexlify17(config.privateKey);
    } else {
      if (!config.publicKey) {
        throw new FuelError18(
          ErrorCode17.HD_WALLET_ERROR,
          "Both public and private Key cannot be missing. At least one should be provided."
        );
      }
      this.publicKey = hexlify17(config.publicKey);
    }
    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
    this.fingerprint = dataSlice2(ripemd160(sha2564(this.publicKey)), 0, 4);
    this.depth = config.depth || this.depth;
    this.index = config.index || this.index;
    this.chainCode = config.chainCode;
  }
  get extendedKey() {
    return this.toExtendedKey();
  }
  /**
   * Derive the current HDWallet instance navigating only on the index.
   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param index - Index of the child HDWallet.
   * @returns A new instance of HDWallet on the derived index
   */
  deriveIndex(index) {
    const privateKey = this.privateKey && arrayify18(this.privateKey);
    const publicKey = arrayify18(this.publicKey);
    const chainCode = arrayify18(this.chainCode);
    const data = new Uint8Array(37);
    if (index & HARDENED_INDEX) {
      if (!privateKey) {
        throw new FuelError18(
          ErrorCode17.HD_WALLET_ERROR,
          "Cannot derive a hardened index without a private Key."
        );
      }
      data.set(privateKey, 1);
    } else {
      data.set(arrayify18(this.publicKey));
    }
    data.set(toBytes2(index, 4), 33);
    const bytes = arrayify18(computeHmac2("sha512", chainCode, data));
    const IL = bytes.slice(0, 32);
    const IR = bytes.slice(32);
    if (privateKey) {
      const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
      const ki = bn17(IL).add(privateKey).mod(N).toBytes(32);
      return new HDWallet({
        privateKey: ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    const signer = new Signer(hexlify17(IL));
    const Ki = signer.addPoint(publicKey);
    return new HDWallet({
      publicKey: Ki,
      chainCode: IR,
      index,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint
    });
  }
  /**
   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
   *
   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
   * @returns A new instance of HDWallet on the derived path
   */
  derivePath(path2) {
    const paths = parsePath(path2, this.depth);
    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
  }
  /**
   * Get the extendKey as defined on BIP-32 from the provided seed
   *
   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
   * @returns BIP-32 extended private key
   */
  toExtendedKey(isPublic = false, testnet = false) {
    if (this.depth >= 256) {
      throw new FuelError18(
        ErrorCode17.HD_WALLET_ERROR,
        `Exceeded max depth of 255. Current depth: ${this.depth}.`
      );
    }
    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
    const depth = hexlify17(Uint8Array.from([this.depth]));
    const parentFingerprint = this.parentFingerprint;
    const index = toHex(this.index, 4);
    const chainCode = this.chainCode;
    const key = this.privateKey != null && !isPublic ? concat5(["0x00", this.privateKey]) : this.publicKey;
    const extendedKey = arrayify18(concat5([prefix, depth, parentFingerprint, index, chainCode, key]));
    return base58check(extendedKey);
  }
  /**
   * Create HDWallet instance from seed
   *
   * @param seed - Seed
   * @returns A new instance of HDWallet
   */
  static fromSeed(seed) {
    const masterKey = mnemonic_default.masterKeysFromSeed(seed);
    return new HDWallet({
      chainCode: arrayify18(masterKey.slice(32)),
      privateKey: arrayify18(masterKey.slice(0, 32))
    });
  }
  static fromExtendedKey(extendedKey) {
    const decoded = toBeHex(decodeBase58(extendedKey));
    const bytes = arrayify18(decoded);
    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;
    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {
      throw new FuelError18(ErrorCode17.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
    }
    if (!validChecksum) {
      throw new FuelError18(ErrorCode17.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify17(bytes.slice(5, 9));
    const index = parseInt(hexlify17(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify17(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);
    if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
      throw new FuelError18(
        ErrorCode17.HD_WALLET_ERROR,
        "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
      );
    }
    if (isPublicExtendedKey(bytes)) {
      if (key[0] !== 3) {
        throw new FuelError18(ErrorCode17.HD_WALLET_ERROR, "Invalid public extended key.");
      }
      return new HDWallet({
        publicKey: key,
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
    if (key[0] !== 0) {
      throw new FuelError18(ErrorCode17.HD_WALLET_ERROR, "Invalid private extended key.");
    }
    return new HDWallet({
      privateKey: key.slice(1),
      chainCode,
      index,
      depth,
      parentFingerprint
    });
  }
};
var hdwallet_default = HDWallet;

// src/wallet/wallets.ts
var WalletLocked = class extends Account {
  /**
   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
   *
   * @param privateKey - The private key used to unlock the wallet.
   * @returns An instance of WalletUnlocked.
   */
  unlock(privateKey) {
    return new WalletUnlocked(privateKey, this._provider);
  }
};
var WalletUnlocked = class extends BaseWalletUnlocked {
  /**
   * Locks the wallet and returns an instance of WalletLocked.
   *
   * @returns An instance of WalletLocked.
   */
  lock() {
    this.signer = () => new Signer("0x00");
    return new WalletLocked(this.address, this._provider);
  }
  /**
   * Generate a new Wallet Unlocked with a random key pair.
   *
   * @param generateOptions - Options to customize the generation process (optional).
   * @returns An instance of WalletUnlocked.
   */
  static generate(generateOptions) {
    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);
    return new WalletUnlocked(privateKey, generateOptions?.provider);
  }
  /**
   * Create a Wallet Unlocked from a seed.
   *
   * @param seed - The seed phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromSeed(seed, path2, provider) {
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from a mnemonic phrase.
   *
   * @param mnemonic - The mnemonic phrase.
   * @param provider - A Provider instance (optional).
   * @param path - The derivation path (optional).
   * @param passphrase - The passphrase for the mnemonic (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromMnemonic(mnemonic, path2, passphrase, provider) {
    const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
    const hdWallet = hdwallet_default.fromSeed(seed);
    const childWallet = hdWallet.derivePath(path2 || WalletUnlocked.defaultPath);
    return new WalletUnlocked(childWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an extended key.
   *
   * @param extendedKey - The extended key.
   * @param provider - A Provider instance (optional).
   * @returns An instance of WalletUnlocked.
   */
  static fromExtendedKey(extendedKey, provider) {
    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
    return new WalletUnlocked(hdWallet.privateKey, provider);
  }
  /**
   * Create a Wallet Unlocked from an encrypted JSON.
   *
   * @param jsonWallet - The encrypted JSON keystore.
   * @param password - The password to decrypt the JSON.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static async fromEncryptedJson(jsonWallet, password, provider) {
    const privateKey = await decryptKeystoreWallet(jsonWallet, password);
    return new WalletUnlocked(privateKey, provider);
  }
};

// src/wallet/wallet.ts
var Wallet = class {
  /**
   * Creates a locked wallet instance from an address and a provider.
   *
   * @param address - The address of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns A locked wallet instance.
   */
  static fromAddress(address, provider) {
    return new WalletLocked(address, provider);
  }
  /**
   * Creates an unlocked wallet instance from a private key and a provider.
   *
   * @param privateKey - The private key of the wallet.
   * @param provider - A Provider instance (optional).
   * @returns An unlocked wallet instance.
   */
  static fromPrivateKey(privateKey, provider) {
    return new WalletUnlocked(privateKey, provider);
  }
};
/**
 * Generate a new Wallet Unlocked with a random key pair.
 *
 * @param generateOptions - Options to customize the generation process (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "generate", WalletUnlocked.generate);
/**
 * Create a Wallet Unlocked from a seed.
 *
 * @param seed - The seed phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromSeed", WalletUnlocked.fromSeed);
/**
 * Create a Wallet Unlocked from a mnemonic phrase.
 *
 * @param mnemonic - The mnemonic phrase.
 * @param provider - A Provider instance (optional).
 * @param path - The derivation path (optional).
 * @param passphrase - The passphrase for the mnemonic (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
/**
 * Create a Wallet Unlocked from an extended key.
 *
 * @param extendedKey - The extended key.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
/**
 * Create a Wallet Unlocked from an encrypted JSON.
 *
 * @param jsonWallet - The encrypted JSON keystore.
 * @param password - The password to decrypt the JSON.
 * @param provider - A Provider instance (optional).
 * @returns An unlocked wallet instance.
 */
__publicField(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

// src/test-utils/seedTestWallet.ts
import { randomBytes as randomBytes4 } from "@fuel-ts/crypto";
var seedTestWallet = async (wallet, quantities) => {
  const genesisWallet = new WalletUnlocked(
    process.env.GENESIS_SECRET || randomBytes4(32),
    wallet.provider
  );
  const resources = await genesisWallet.getResourcesToSpend(quantities);
  const { minGasPrice } = genesisWallet.provider.getGasConfig();
  const request = new ScriptTransactionRequest({
    gasLimit: 1e4,
    gasPrice: minGasPrice
  });
  request.addResources(resources);
  quantities.map(coinQuantityfy).forEach(({ amount, assetId }) => request.addCoinOutput(wallet.address, amount, assetId));
  await genesisWallet.sendTransaction(request, { awaitExecution: true });
};

// src/test-utils/generateTestWallet.ts
var generateTestWallet = async (provider, quantities) => {
  const wallet = Wallet.generate({ provider });
  if (quantities) {
    await seedTestWallet(wallet, quantities);
  }
  return wallet;
};

// src/test-utils/launchNode.ts
import { BaseAssetId as BaseAssetId4 } from "@fuel-ts/address/configs";
import { toHex as toHex2 } from "@fuel-ts/math";
import { defaultChainConfig, defaultConsensusKey, hexlify as hexlify18 } from "@fuel-ts/utils";
import { findBinPath } from "@fuel-ts/utils/cli-utils";
import { spawn } from "child_process";
import { randomUUID } from "crypto";
import { existsSync, mkdirSync, rmSync, writeFileSync } from "fs";
import os from "os";
import path from "path";
import { getPortPromise } from "portfinder";
import treeKill from "tree-kill";
var getFlagValueFromArgs = (args, flag) => {
  const flagIndex = args.indexOf(flag);
  if (flagIndex === -1) {
    return void 0;
  }
  return args[flagIndex + 1];
};
var extractRemainingArgs = (args, flagsToRemove) => {
  const newArgs = [...args];
  flagsToRemove.forEach((flag) => {
    const flagIndex = newArgs.indexOf(flag);
    if (flagIndex !== -1) {
      newArgs.splice(flagIndex, 2);
    }
  });
  return newArgs;
};
var killNode = (params) => {
  const { child, configPath, state, killFn } = params;
  if (!state.isDead) {
    if (child.pid) {
      state.isDead = true;
      killFn(Number(child.pid));
    }
    child.stdout.removeAllListeners();
    child.stderr.removeAllListeners();
    if (existsSync(configPath)) {
      rmSync(configPath, { recursive: true });
    }
  }
};
var launchNode = async ({
  ip,
  port,
  args = [],
  useSystemFuelCore = false,
  loggingEnabled = true,
  debugEnabled = false,
  basePath
}) => (
  // eslint-disable-next-line no-async-promise-executor
  new Promise(async (resolve, reject) => {
    const remainingArgs = extractRemainingArgs(args, [
      "--chain",
      "--consensus-key",
      "--db-type",
      "--poa-instant"
    ]);
    const chainConfigPath = getFlagValueFromArgs(args, "--chain");
    const consensusKey = getFlagValueFromArgs(args, "--consensus-key") || defaultConsensusKey;
    const dbTypeFlagValue = getFlagValueFromArgs(args, "--db-type");
    const useInMemoryDb = dbTypeFlagValue === "in-memory" || dbTypeFlagValue === void 0;
    const poaInstantFlagValue = getFlagValueFromArgs(args, "--poa-instant");
    const poaInstant = poaInstantFlagValue === "true" || poaInstantFlagValue === void 0;
    const graphQLStartSubstring = "Binding GraphQL provider to";
    const binPath = findBinPath("fuels-core", __dirname);
    const command = useSystemFuelCore ? "fuel-core" : binPath;
    const ipToUse = ip || "0.0.0.0";
    const portToUse = port || (await getPortPromise({
      port: 4e3,
      // tries 4000 first, then 4001, then 4002, etc.
      stopPort: 5e3
      // don't try ports above 5000
    })).toString();
    let chainConfigPathToUse;
    const prefix = basePath || os.tmpdir();
    const suffix = basePath ? "" : randomUUID();
    const tempDirPath = path.join(prefix, ".fuels", suffix);
    if (chainConfigPath) {
      chainConfigPathToUse = chainConfigPath;
    } else {
      if (!existsSync(tempDirPath)) {
        mkdirSync(tempDirPath, { recursive: true });
      }
      const tempChainConfigFilePath = path.join(tempDirPath, "chainConfig.json");
      let chainConfig = defaultChainConfig;
      if (!process.env.GENESIS_SECRET) {
        const pk = Signer.generatePrivateKey();
        const signer = new Signer(pk);
        process.env.GENESIS_SECRET = hexlify18(pk);
        chainConfig = {
          ...defaultChainConfig,
          initial_state: {
            ...defaultChainConfig.initial_state,
            coins: [
              ...defaultChainConfig.initial_state.coins,
              {
                owner: signer.address.toHexString(),
                amount: toHex2(1e9),
                asset_id: BaseAssetId4
              }
            ]
          }
        };
      }
      writeFileSync(tempChainConfigFilePath, JSON.stringify(chainConfig), "utf8");
      chainConfigPathToUse = tempChainConfigFilePath;
    }
    const child = spawn(
      command,
      [
        "run",
        ["--ip", ipToUse],
        ["--port", portToUse],
        useInMemoryDb ? ["--db-type", "in-memory"] : ["--db-path", tempDirPath],
        ["--min-gas-price", "0"],
        poaInstant ? ["--poa-instant", "true"] : [],
        ["--consensus-key", consensusKey],
        ["--chain", chainConfigPathToUse],
        "--vm-backtrace",
        "--utxo-validation",
        "--debug",
        ...remainingArgs
      ].flat(),
      {
        stdio: "pipe"
      }
    );
    if (loggingEnabled) {
      child.stderr.pipe(process.stderr);
    }
    if (debugEnabled) {
      child.stdout.pipe(process.stdout);
    }
    const cleanupConfig = {
      child,
      configPath: tempDirPath,
      killFn: treeKill,
      state: {
        isDead: false
      }
    };
    child.stderr.on("data", (chunk) => {
      if (chunk.indexOf(graphQLStartSubstring) !== -1) {
        resolve({
          cleanup: () => killNode(cleanupConfig),
          ip: ipToUse,
          port: portToUse,
          chainConfigPath: chainConfigPathToUse
        });
      }
      if (/error/i.test(chunk)) {
        reject(chunk.toString());
      }
    });
    process.on("exit", () => killNode(cleanupConfig));
    process.on("SIGINT", () => killNode(cleanupConfig));
    process.on("SIGUSR1", () => killNode(cleanupConfig));
    process.on("SIGUSR2", () => killNode(cleanupConfig));
    process.on("beforeExit", () => killNode(cleanupConfig));
    process.on("uncaughtException", () => killNode(cleanupConfig));
    child.on("error", reject);
  })
);
var generateWallets = async (count, provider) => {
  const wallets = [];
  for (let i = 0; i < count; i += 1) {
    const wallet = await generateTestWallet(provider, [[1e3, BaseAssetId4]]);
    wallets.push(wallet);
  }
  return wallets;
};
var launchNodeAndGetWallets = async ({
  launchNodeOptions,
  walletCount = 10
} = {}) => {
  const { cleanup: closeNode, ip, port } = await launchNode(launchNodeOptions || {});
  const provider = await Provider.create(`http://${ip}:${port}/graphql`);
  const wallets = await generateWallets(walletCount, provider);
  const cleanup = () => {
    closeNode();
  };
  return { wallets, stop: cleanup, provider };
};
export {
  generateTestWallet,
  killNode,
  launchNode,
  launchNodeAndGetWallets,
  seedTestWallet
};
//# sourceMappingURL=test-utils.mjs.map